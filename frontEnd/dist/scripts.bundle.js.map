{"version":3,"sources":["/home/devon/Desktop/frontEnd/frontEnd/node_modules/auth0-js/build/auth0.js","/home/devon/Desktop/frontEnd/frontEnd/node_modules/chart.js/dist/Chart.js","/home/devon/Desktop/frontEnd/frontEnd/node_modules/hammerjs/hammer.min.js","/home/devon/Desktop/frontEnd/frontEnd/node_modules/script-loader/addScript.js","/home/devon/Desktop/frontEnd/frontEnd/node_modules/auth0-js/build/auth0.js?b1d2","/home/devon/Desktop/frontEnd/frontEnd/node_modules/chart.js/dist/Chart.js?6f9c","/home/devon/Desktop/frontEnd/frontEnd/node_modules/hammerjs/hammer.min.js?1154"],"names":[],"mappings":";;;;;AAAA,6EAA6E,kGAAkG,+FAA+F,gFAAgF,0CAA0C,GAAG,oBAAoB,sCAAsC,2FAA2F,mGAAmG,+JAA+J,qIAAqI,4BAA4B,8EAA8E,0JAA0J,yFAAyF,iGAAiG,cAAc,gIAAgI,uGAAuG,2FAA2F,yGAAyG,YAAY,2JAA2J,+CAA+C,aAAa,kEAAkE,wEAAwE,uCAAuC,yFAAyF,uXAAuX,wCAAwC,KAAK,gCAAgC,6CAA6C,sGAAsG,4FAA4F,mHAAmH,6FAA6F,uBAAuB,OAAO,8BAA8B,8BAA8B,yBAAyB,mDAAmD,6EAA6E,uCAAuC,SAAS,2DAA2D,0CAA0C,QAAQ,SAAS,EAAE,aAAa,kEAAkE,0KAA0K,+CAA+C,qCAAqC,8CAA8C,0BAA0B,kCAAkC,SAAS,oBAAoB,OAAO,IAAI,EAAE,KAAK,iDAAiD,0BAA0B,4BAA4B,8CAA8C,+BAA+B,SAAS,OAAO,wBAAwB,KAAK,oCAAoC,sBAAsB,4BAA4B,8BAA8B,OAAO,oBAAoB,KAAK,2BAA2B,2CAA2C,uBAAuB,EAAE,yDAAyD,KAAK,sCAAsC,cAAc,yFAAyF,2DAA2D,4CAA4C,SAAS,QAAQ,KAAK,qDAAqD,0DAA0D,kDAAkD,+BAA+B,SAAS,iBAAiB,OAAO,IAAI,EAAE,KAAK,oCAAoC,sBAAsB,oBAAoB,eAAe,+BAA+B,kCAAkC,sCAAsC,qCAAqC,yIAAyI,wBAAwB,6CAA6C,SAAS,OAAO,6CAA6C,SAAS,iDAAiD,oDAAoD,gBAAgB,OAAO,wBAAwB,KAAK,oCAAoC,iCAAiC,0CAA0C,0DAA0D,OAAO,iBAAiB,KAAK,kDAAkD,oFAAoF,sBAAsB,OAAO,oCAAoC,8DAA8D,8EAA8E,6CAA6C,iBAAiB,OAAO,IAAI,EAAE,KAAK,kDAAkD,oFAAoF,sBAAsB,OAAO,wCAAwC,8DAA8D,8EAA8E,6CAA6C,iBAAiB,OAAO,IAAI,EAAE,KAAK,0BAA0B,wLAAwL,aAAa,6CAA6C,oDAAoD,wBAAwB,mCAAmC,KAAK,gCAAgC,oCAAoC,KAAK,8BAA8B,2BAA2B,KAAK,0BAA0B,wFAAwF,oCAAoC,4BAA4B,aAAa,EAAE,gBAAgB,6CAA6C,+CAA+C,iDAAiD,gDAAgD,yCAAyC,8BAA8B,OAAO,KAAK,0CAA0C,8BAA8B,8BAA8B,OAAO,KAAK,yCAAyC,qCAAqC,8BAA8B,OAAO,KAAK,+CAA+C,kCAAkC,iDAAiD,OAAO,mDAAmD,2CAA2C,+BAA+B,qBAAqB,WAAW,8BAA8B,gDAAgD,yEAAyE,yEAAyE,yCAAyC,+EAA+E,eAAe,aAAa,WAAW,SAAS,OAAO,KAAK,yLAAyL,MAAM,yDAAyD,mCAAmC,oCAAoC,OAAO,2DAA2D,KAAK,oCAAoC,mCAAmC,KAAK,0BAA0B,6JAA6J,aAAa,kEAAkE,mBAAmB,gDAAgD,wCAAwC,yCAAyC,0BAA0B,gFAAgF,aAAa,kEAAkE,0CAA0C,8CAA8C,4CAA4C,8BAA8B,iFAAiF,sCAAsC,mBAAmB,gCAAgC,kFAAkF,SAAS,mCAAmC,yBAAyB,sBAAsB,SAAS,qCAAqC,qBAAqB,sBAAsB,SAAS,sBAAsB,oBAAoB,qCAAqC,4DAA4D,wDAAwD,WAAW,4DAA4D,wDAAwD,WAAW,sDAAsD,oCAAoC,WAAW,4BAA4B,0BAA0B,WAAW,0FAA0F,4NAA4N,6BAA6B,mCAAmC,WAAW,+BAA+B,uCAAuC,WAAW,gCAAgC,SAAS,yFAAyF,qCAAqC,SAAS,uCAAuC,6CAA6C,SAAS,yEAAyE,QAAQ,KAAK,sCAAsC,aAAa,6CAA6C,mBAAmB,+CAA+C,iCAAiC,0BAA0B,kDAAkD,uCAAuC,iEAAiE,aAAa,wCAAwC,6BAA6B,aAAa,SAAS,4DAA4D,aAAa,6CAA6C,mBAAmB,kDAAkD,qCAAqC,uBAAuB,uBAAuB,SAAS,OAAO,mFAAmF,SAAS,yBAAyB,KAAK,IAAI,4DAA4D,6EAA6E,uBAAuB,mBAAmB,OAAO,mDAAmD,mCAAmC,aAAa,SAAS,uBAAuB,MAAM,4DAA4D,sBAAsB,0BAA0B,SAAS,6CAA6C,wCAAwC,oCAAoC,aAAa,uCAAuC,6GAA6G,0CAA0C,iBAAiB,aAAa,OAAO,wCAAwC,aAAa,8BAA8B,SAAS,6CAA6C,2CAA2C,SAAS,qCAAqC,8DAA8D,iEAAiE,SAAS,iEAAiE,+CAA+C,0CAA0C,qEAAqE,4EAA4E,qBAAqB,OAAO,0CAA0C,qBAAqB,iBAAiB,OAAO,qCAAqC,iBAAiB,aAAa,EAAE,0BAA0B,SAAS,mEAAmE,oCAAoC,qEAAqE,mEAAmE,aAAa,OAAO,iCAAiC,aAAa,uBAAuB,SAAS,eAAe,MAAM,yCAAyC,aAAa,gEAAgE,SAAS,YAAY,uBAAuB,SAAS,MAAM,yCAAyC,gNAAgN,uBAAuB,SAAS,qEAAqE,yBAAyB,uBAAuB,mBAAmB,OAAO,yCAAyC,8TAA8T,wCAAwC,yBAAyB,aAAa,+BAA+B,wCAAwC,yBAAyB,aAAa,gCAAgC,sFAAsF,yBAAyB,aAAa,gDAAgD,4HAA4H,yBAAyB,aAAa,uBAAuB,iFAAiF,uJAAuJ,wCAAwC,uBAAuB,MAAM,sDAAsD,sDAAsD,uBAAuB,SAAS,wCAAwC,uCAAuC,4BAA4B,gCAAgC,SAAS,2BAA2B,qCAAqC,+BAA+B,+BAA+B,gBAAgB,OAAO,2DAA2D,kEAAkE,iBAAiB,0CAA0C,2CAA2C,iBAAiB,aAAa,iCAAiC,SAAS,wCAAwC,qCAAqC,uDAAuD,SAAS,EAAE,uBAAuB,MAAM,2CAA2C,yEAAyE,MAAM,2CAA2C,yDAAyD,yBAAyB,SAAS,oGAAoG,MAAM,aAAa,6CAA6C,wBAAwB,gBAAgB,aAAa,mEAAmE,sFAAsF,4CAA4C,yCAAyC,gHAAgH,yBAAyB,+BAA+B,yBAAyB,4BAA4B,iCAAiC,KAAK,qDAAqD,2BAA2B,MAAM,yDAAyD,yBAAyB,MAAM,uDAAuD,uBAAuB,MAAM,sDAAsD,sBAAsB,MAAM,0DAA0D,0BAA0B,MAAM,wGAAwG,yBAAyB,KAAK,yDAAyD,kDAAkD,kBAAkB,MAAM,oDAAoD,6CAA6C,kBAAkB,MAAM,2DAA2D,oDAAoD,kBAAkB,MAAM,iDAAiD,0CAA0C,8CAA8C,MAAM,oHAAoH,6FAA6F,2DAA2D,6EAA6E,2CAA2C,KAAK,6FAA6F,8BAA8B,kCAAkC,8BAA8B,OAAO,qCAAqC,8EAA8E,+CAA+C,yBAAyB,iBAAiB,OAAO,uEAAuE,OAAO,oCAAoC,qFAAqF,OAAO,iDAAiD,gFAAgF,OAAO,4BAA4B,MAAM,gEAAgE,+CAA+C,0CAA0C,sDAAsD,8CAA8C,MAAM,+DAA+D,oFAAoF,MAAM,gEAAgE,qFAAqF,MAAM,iEAAiE,sFAAsF,MAAM,wCAAwC,aAAa,8CAA8C,qEAAqE,qDAAqD,KAAK,oDAAoD,iCAAiC,eAAe,OAAO,gCAAgC,MAAM,8BAA8B,aAAa,mEAAmE,mBAAmB,2CAA2C,kDAAkD,wBAAwB,qPAAqP,yEAAyE,qBAAqB,2HAA2H,2BAA2B,kBAAkB,OAAO,gCAAgC,6FAA6F,6BAA6B,6BAA6B,4CAA4C,6DAA6D,aAAa,OAAO,0DAA0D,2DAA2D,aAAa,qCAAqC,2DAA2D,aAAa,OAAO,+BAA+B,aAAa,SAAS,uBAAuB,MAAM,8EAA8E,4BAA4B,uBAAuB,SAAS,qCAAqC,oBAAoB,4BAA4B,qBAAqB,+DAA+D,SAAS,OAAO,kEAAkE,sHAAsH,gDAAgD,mPAAmP,yBAAyB,8DAA8D,aAAa,OAAO,kEAAkE,aAAa,SAAS,uBAAuB,MAAM,+EAA+E,wBAAwB,mBAAmB,SAAS,mJAAmJ,2EAA2E,sCAAsC,0EAA0E,iEAAiE,sEAAsE,qBAAqB,oNAAoN,+CAA+C,2BAA2B,iBAAiB,aAAa,kCAAkC,SAAS,oGAAoG,2EAA2E,mBAAmB,+FAA+F,+CAA+C,2BAA2B,iBAAiB,aAAa,kCAAkC,SAAS,0FAA0F,4DAA4D,SAAS,mDAAmD,MAAM,+CAA+C,iCAAiC,qHAAqH,iEAAiE,SAAS,oJAAoJ,2FAA2F,+GAA+G,4DAA4D,qGAAqG,4GAA4G,wHAAwH,oIAAoI,+HAA+H,gJAAgJ,2EAA2E,mEAAmE,SAAS,oFAAoF,kEAAkE,yGAAyG,uBAAuB,iBAAiB,OAAO,8BAA8B,+DAA+D,oDAAoD,SAAS,sCAAsC,MAAM,aAAa,mEAAmE,mBAAmB,2CAA2C,yCAAyC,qCAAqC,6CAA6C,2EAA2E,SAAS,iDAAiD,sFAAsF,SAAS,0CAA0C,oEAAoE,SAAS,MAAM,+CAA+C,wBAAwB,+JAA+J,8EAA8E,SAAS,iEAAiE,iUAAiU,yBAAyB,2CAA2C,sCAAsC,SAAS,gCAAgC,qCAAqC,SAAS,yBAAyB,qCAAqC,+EAA+E,aAAa,yBAAyB,SAAS,wHAAwH,0BAA0B,2EAA2E,6EAA6E,aAAa,sEAAsE,SAAS,4BAA4B,6CAA6C,0BAA0B,SAAS,wBAAwB,oCAAoC,6BAA6B,SAAS,OAAO,wCAAwC,oDAAoD,SAAS,2BAA2B,oBAAoB,OAAO,iCAAiC,qDAAqD,yBAAyB,aAAa,yCAAyC,qdAAqd,aAAa,OAAO,ueAAue,aAAa,SAAS,0BAA0B,MAAM,kDAAkD,yBAAyB,iCAAiC,qHAAqH,iEAAiE,SAAS,8GAA8G,4IAA4I,wGAAwG,4FAA4F,iGAAiG,4EAA4E,6FAA6F,yHAAyH,oIAAoI,oDAAoD,6CAA6C,SAAS,sFAAsF,mEAAmE,SAAS,2DAA2D,oBAAoB,mBAAmB,uDAAuD,oCAAoC,kCAAkC,SAAS,0CAA0C,oCAAoC,6BAA6B,SAAS,0BAA0B,0DAA0D,sBAAsB,SAAS,4BAA4B,2DAA2D,8CAA8C,SAAS,iCAAiC,iEAAiE,SAAS,OAAO,oCAAoC,SAAS,yEAAyE,2BAA2B,uCAAuC,SAAS,uBAAuB,+BAA+B,SAAS,2BAA2B,oBAAoB,OAAO,iCAAiC,qDAAqD,yBAAyB,aAAa,gZAAgZ,SAAS,wCAAwC,MAAM,aAAa,8CAA8C,iEAAiE,OAAO,oBAAoB,QAAQ,0DAA0D,qDAAqD,KAAK,kCAAkC,aAAa,8CAA8C,mXAAmX,SAAS,OAAO,qEAAqE,wHAAwH,kDAAkD,gFAAgF,iXAAiX,mCAAmC,+HAA+H,oCAAoC,0UAA0U,OAAO,kBAAkB,uRAAuR,mCAAmC,+HAA+H,+BAA+B,8MAA8M,yBAAyB,wCAAwC,oHAAoH,kDAAkD,2DAA2D,SAAS,UAAU,qHAAqH,iCAAiC,wCAAwC,uVAAuV,UAAU,uBAAuB,2GAA2G,6GAA6G,sIAAsI,6BAA6B,2MAA2M,gEAAgE,aAAa,mEAAmE,2CAA2C,+BAA+B,iCAAiC,wBAAwB,0BAA0B,mBAAmB,OAAO,sDAAsD,KAAK,2CAA2C,wBAAwB,qBAAqB,kBAAkB,OAAO,gDAAgD,OAAO,oBAAoB,KAAK,yCAAyC,sCAAsC,qBAAqB,gBAAgB,OAAO,mCAAmC,OAAO,iBAAiB,KAAK,sCAAsC,mBAAmB,yBAAyB,gBAAgB,OAAO,uCAAuC,uDAAuD,OAAO,qBAAqB,KAAK,oCAAoC,8DAA8D,EAAE,2BAA2B,8CAA8C,OAAO,+EAA+E,uBAAuB,KAAK,sCAAsC,uGAAuG,gGAAgG,qEAAqE,OAAO,YAAY,KAAK,mCAAmC,8DAA8D,KAAK,0BAA0B,4PAA4P,aAAa,mEAAmE,mEAAmE,wCAAwC,sCAAsC,KAAK,wCAAwC,gCAAgC,KAAK,OAAO,kHAAkH,kBAAkB,KAAK,8CAA8C,8CAA8C,2CAA2C,6CAA6C,+CAA+C,8CAA8C,wDAAwD,kHAAkH,sDAAsD,2DAA2D,OAAO,wDAAwD,kDAAkD,OAAO,kDAAkD,KAAK,kCAAkC,6EAA6E,sIAAsI,kCAAkC,OAAO,OAAO,aAAa,+CAA+C,EAAE,YAAY,aAAa,gDAAgD,EAAE,YAAY,aAAa,gDAAgD,EAAE,YAAY,aAAa,4CAA4C,EAAE,YAAY,OAAO,6EAA6E,MAAM,oGAAoG,OAAO,kBAAkB,OAAO,yEAAyE,iBAAiB,EAAE,qBAAqB,wCAAwC,GAAG,iEAAiE,OAAO,oBAAoB,OAAO,2DAA2D,qCAAqC,qBAAqB,4BAA4B,sDAAsD,OAAO,6BAA6B,KAAK,gHAAgH,MAAM,qBAAqB,OAAO,mBAAmB,MAAM,sEAAsE,wBAAwB,iCAAiC,mCAAmC,mDAAmD,WAAW,EAAE,SAAS,0BAA0B,kCAAkC,kFAAkF,WAAW,SAAS,OAAO,yFAAyF,SAAS,OAAO,yBAAyB,4CAA4C,OAAO,KAAK,kGAAkG,uFAAuF,OAAO,qBAAqB,OAAO,+DAA+D,mBAAmB,iCAAiC,eAAe,cAAc,6CAA6C,SAAS,OAAO,wBAAwB,gCAAgC,wBAAwB,6CAA6C,SAAS,OAAO,2GAA2G,SAAS,OAAO,qBAAqB,KAAK,iFAAiF,kGAAkG,sCAAsC,wPAAwP,qHAAqH,yCAAyC,aAAa,2CAA2C,sGAAsG,2GAA2G,sBAAsB,0BAA0B,cAAc,wCAAwC,iGAAiG,sHAAsH,OAAO,oBAAoB,OAAO,6DAA6D,uCAAuC,sBAAsB,gBAAgB,eAAe,gBAAgB,cAAc,sBAAsB,8DAA8D,SAAS,OAAO,wBAAwB,kCAAkC,mDAAmD,0CAA0C,4BAA4B,OAAO,wBAAwB,KAAK,qGAAqG,OAAO,qBAAqB,QAAQ,yDAAyD,wCAAwC,KAAK,2PAA2P,uHAAuH,EAAE,4CAA4C,EAAE,oHAAoH,aAAa,mCAAmC,EAAE,+GAA+G,aAAa,iBAAiB,EAAE,4FAA4F,aAAa,mCAAmC,EAAE,yHAAyH,aAAa,iBAAiB,EAAE,qBAAqB,eAAe,mBAAmB,OAAO,kEAAkE,qBAAqB,8BAA8B,kTAAkT,gDAAgD,mCAAmC,kJAAkJ,uBAAuB,OAAO,wCAAwC,iFAAiF,8QAA8Q,6CAA6C,wDAAwD,sCAAsC,OAAO,OAAO,oIAAoI,OAAO,KAAK,yCAAyC,2KAA2K,OAAO,oBAAoB,MAAM,gFAAgF,2CAA2C,4BAA4B,2CAA2C,OAAO,wCAAwC,kDAAkD,OAAO,qGAAqG,MAAM,0FAA0F,MAAM,yEAAyE,yBAAyB,8BAA8B,wBAAwB,8EAA8E,+BAA+B,+BAA+B,0BAA0B,oBAAoB,qBAAqB,MAAM,+EAA+E,oGAAoG,OAAO,sBAAsB,OAAO,oEAAoE,sBAAsB,sCAAsC,2BAA2B,qBAAqB,uBAAuB,sDAAsD,qEAAqE,uBAAuB,uBAAuB,iBAAiB,mCAAmC,SAAS,WAAW,oEAAoE,2BAA2B,2BAA2B,uGAAuG,yKAAyK,sJAAsJ,wCAAwC,oCAAoC,OAAO,mCAAmC,8BAA8B,WAAW,wCAAwC,SAAS,uCAAuC,wBAAwB,aAAa,yCAAyC,gFAAgF,mCAAmC,mCAAmC,wCAAwC,WAAW,SAAS,WAAW,sBAAsB,yEAAyE,0GAA0G,sCAAsC,SAAS,OAAO,mCAAmC,SAAS,OAAO,EAAE,KAAK,8FAA8F,mCAAmC,mKAAmK,wHAAwH,oIAAoI,qBAAqB,OAAO,qBAAqB,QAAQ,sFAAsF,4DAA4D,kBAAkB,MAAM,+JAA+J,iGAAiG,6GAA6G,qBAAqB,OAAO,uBAAuB,QAAQ,wFAAwF,sDAAsD,kBAAkB,MAAM,4FAA4F,OAAO,oBAAoB,OAAO,iEAAiE,OAAO,2FAA2F,QAAQ,qGAAqG,sDAAsD,0EAA0E,OAAO,qBAAqB,mBAAmB,uEAAuE,OAAO,iCAAiC,6FAA6F,cAAc,uDAAuD,+BAA+B,cAAc,uEAAuE,iBAAiB,uDAAuD,cAAc,SAAS,kBAAkB,MAAM,kJAAkJ,gBAAgB,sBAAsB,cAAc,oBAAoB,QAAQ,sFAAsF,uDAAuD,qCAAqC,kBAAkB,MAAM,iQAAiQ,qBAAqB,0BAA0B,+BAA+B,OAAO,qBAAqB,UAAU,oBAAoB,cAAc,wBAAwB,QAAQ,wGAAwG,iBAAiB,yBAAyB,sEAAsE,SAAS,0EAA0E,OAAO,kBAAkB,MAAM,oDAAoD,4BAA4B,6CAA6C,OAAO,4BAA4B,MAAM,6GAA6G,MAAM,mBAAmB,SAAS,sFAAsF,iJAAiJ,6BAA6B,OAAO,kCAAkC,0BAA0B,oBAAoB,8DAA8D,gCAAgC,OAAO,uBAAuB,MAAM,8IAA8I,2LAA2L,6BAA6B,mCAAmC,+BAA+B,yBAAyB,6BAA6B,MAAM,kKAAkK,+EAA+E,kBAAkB,MAAM,wIAAwI,mFAAmF,MAAM,oJAAoJ,wCAAwC,kBAAkB,qEAAqE,OAAO,2BAA2B,0CAA0C,yBAAyB,kEAAkE,uCAAuC,sCAAsC,WAAW,OAAO,4BAA4B,WAAW,6EAA6E,SAAS,OAAO,MAAM,iHAAiH,OAAO,oBAAoB,QAAQ,iFAAiF,0NAA0N,KAAK,yHAAyH,SAAS,mBAAmB,QAAQ,mFAAmF,4BAA4B,gGAAgG,OAAO,6BAA6B,6DAA6D,wDAAwD,6BAA6B,MAAM,6CAA6C,sBAAsB,4CAA4C,8CAA8C,8BAA8B,mEAAmE,wCAAwC,4DAA4D,mDAAmD,SAAS,8BAA8B,iBAAiB,SAAS,iMAAiM,aAAa,sBAAsB,WAAW,YAAY,EAAE,0BAA0B,qDAAqD,yCAAyC,SAAS,yBAAyB,QAAQ,wEAAwE,0BAA0B,+CAA+C,SAAS,gCAAgC,iCAAiC,OAAO,0CAA0C,aAAa,iEAAiE,2BAA2B,wEAAwE,WAAW,SAAS,WAAW,2RAA2R,OAAO,wCAAwC,6CAA6C,8EAA8E,SAAS,OAAO,gDAAgD,SAAS,OAAO,cAAc,sDAAsD,OAAO,6EAA6E,gJAAgJ,iFAAiF,gGAAgG,YAAY,gDAAgD,4DAA4D,SAAS,8CAA8C,OAAO,oEAAoE,iDAAiD,wDAAwD,OAAO,mCAAmC,8CAA8C,OAAO,wDAAwD,4MAA4M,kBAAkB,MAAM,kFAAkF,OAAO,mBAAmB,eAAe,4BAA4B,SAAS,qBAAqB,QAAQ,uEAAuE,oCAAoC,4DAA4D,gCAAgC,0BAA0B,iBAAiB,MAAM,mFAAmF,OAAO,mBAAmB,eAAe,4BAA4B,SAAS,qBAAqB,QAAQ,wEAAwE,qCAAqC,4DAA4D,+BAA+B,0BAA0B,iBAAiB,MAAM,+FAA+F,OAAO,mBAAmB,eAAe,4BAA4B,SAAS,qBAAqB,QAAQ,2EAA2E,wCAAwC,4DAA4D,+BAA+B,0BAA0B,iBAAiB,MAAM,gGAAgG,OAAO,mBAAmB,MAAM,sBAAsB,SAAS,qBAAqB,QAAQ,6DAA6D,uCAAuC,4DAA4D,+BAA+B,0BAA0B,iBAAiB,MAAM,6BAA6B,4BAA4B,+FAA+F,OAAO,mBAAmB,MAAM,sBAAsB,SAAS,qBAAqB,QAAQ,yEAAyE,sCAAsC,4DAA4D,+BAA+B,0BAA0B,iBAAiB,MAAM,8FAA8F,OAAO,mBAAmB,MAAM,sBAAsB,SAAS,qBAAqB,QAAQ,wEAAwE,qCAAqC,4DAA4D,+BAA+B,0BAA0B,iBAAiB,MAAM,6FAA6F,OAAO,mBAAmB,eAAe,4BAA4B,SAAS,qBAAqB,QAAQ,uEAAuE,oCAAoC,4DAA4D,+BAA+B,0BAA0B,iBAAiB,MAAM,aAAa,8CAA8C,iCAAiC,uDAAuD,8BAA8B,4FAA4F,0DAA0D,0EAA0E,OAAO,kGAAkG,0DAA0D,gFAAgF,OAAO,+EAA+E,+CAA+C,uBAAuB,SAAS,wBAAwB,sEAAsE,kEAAkE,4CAA4C,GAAG,SAAS,GAAG,KAAK,yEAAyE,SAAS,kEAAkE,0CAA0C,IAAI,SAAS,GAAG,KAAK,qCAAqC,uCAAuC,WAAW,SAAS,2BAA2B,OAAO,wEAAwE,aAAa,8JAA8J,6JAA6J,mBAAmB,YAAY,qBAAqB,OAAO,uGAAuG,iJAAiJ,OAAO,8OAA8O,oEAAoE,iEAAiE,2BAA2B,mBAAmB,OAAO,4EAA4E,kCAAkC,0CAA0C,uCAAuC,QAAQ,OAAO,eAAe,+MAA+M,+BAA+B,aAAa,WAAW,WAAW,EAAE,SAAS,eAAe,OAAO,0CAA0C,8BAA8B,+1BAA+1B,oCAAoC,kEAAkE,4DAA4D,sEAAsE,kFAAkF,4CAA4C,SAAS,EAAE,KAAK,oGAAoG,sFAAsF,0EAA0E,uIAAuI,2DAA2D,4CAA4C,gFAAgF,eAAe,KAAK,aAAa,kCAAkC,2BAA2B,4PAA4P,wDAAwD,yDAAyD,8CAA8C,4DAA4D,gDAAgD,mDAAmD,aAAa,oGAAoG,6BAA6B,yCAAyC,aAAa,sDAAsD,oIAAoI,kCAAkC,0BAA0B,yBAAyB,qDAAqD,4BAA4B,iBAAiB,eAAe,aAAa,OAAO,0CAA0C,6BAA6B,EAAE,oEAAoE,4DAA4D,iCAAiC,8EAA8E,2DAA2D,wDAAwD,sBAAsB,qBAAqB,4BAA4B,iBAAiB,4BAA4B,+LAA+L,iBAAiB,eAAe,4CAA4C,aAAa,uDAAuD,uCAAuC,wCAAwC,QAAQ,EAAE,mBAAmB,2CAA2C,eAAe,aAAa,yBAAyB,0BAA0B,iBAAiB,OAAO,4BAA4B,iBAAiB,eAAe,wCAAwC,uDAAuD,eAAe,4BAA4B,0BAA0B,yBAAyB,0BAA0B,4BAA4B,iBAAiB,eAAe,+BAA+B,0BAA0B,yBAAyB,gCAAgC,4BAA4B,iBAAiB,eAAe,aAAa,0DAA0D,wBAAwB,8DAA8D,wBAAwB,uBAAuB,8BAA8B,mBAAmB,YAAY,uEAAuE,iBAAiB,eAAe,cAAc,WAAW,iCAAiC,0BAA0B,+DAA+D,6DAA6D,kCAAkC,wCAAwC,iDAAiD,iDAAiD,aAAa,uCAAuC,8TAA8T,mBAAmB,uCAAuC,eAAe,aAAa,EAAE,kDAAkD,2DAA2D,2BAA2B,uBAAuB,yPAAyP,0CAA0C,mCAAmC,4BAA4B,oBAAoB,EAAE,mBAAmB,EAAE,iBAAiB,KAAK,eAAe,aAAa,mCAAmC,yCAAyC,qBAAqB,gBAAgB,EAAE,eAAe,eAAe,aAAa,yEAAyE,qEAAqE,2JAA2J,sBAAsB,aAAa,EAAE,aAAa,WAAW,wHAAwH,wBAAwB,aAAa,EAAE,eAAe,EAAE,aAAa,8HAA8H,mBAAmB,uHAAuH,eAAe,iBAAiB,EAAE,8BAA8B,wCAAwC,EAAE,6BAA6B,8GAA8G,gBAAgB,EAAE,YAAY,EAAE,cAAc,oDAAoD,oBAAoB,kCAAkC,2DAA2D,eAAe,cAAc,WAAW,UAAU,OAAO,OAAO,gBAAgB,iDAAiD,mCAAmC,6BAA6B,EAAE,KAAK,WAAW,iCAAiC,mCAAmC,6BAA6B,EAAE,KAAK,WAAW,UAAU,OAAO,KAAK,IAAI,8DAA8D,+BAA+B,KAAK,aAAa,mEAAmE,2CAA2C,qDAAqD,oCAAoC,8CAA8C,wCAAwC,iDAAiD,sDAAsD,uCAAuC,iEAAiE,+CAA+C,iGAAiG,OAAO,uBAAuB,OAAO,gDAAgD,OAAO,sHAAsH,OAAO,iHAAiH,OAAO,oJAAoJ,oEAAoE,eAAe,OAAO,uJAAuJ,uFAAuF,eAAe,OAAO,uFAAuF,OAAO,sHAAsH,gDAAgD,6CAA6C,sEAAsE,4DAA4D,UAAU,mBAAmB,uDAAuD,sBAAsB,yDAAyD,0BAA0B,uEAAuE,0BAA0B,uEAAuE,yBAAyB,sEAAsE,mBAAmB,gEAAgE,sBAAsB,mEAAmE,yCAAyC,wIAAwI,4BAA4B,2HAA2H,4BAA4B,0HAA0H,SAAS,QAAQ,8DAA8D,6IAA6I,0EAA0E,8DAA8D,6FAA6F,2EAA2E,gCAAgC,qEAAqE,EAAE,KAAK,mKAAmK,OAAO,uBAAuB,OAAO,kDAAkD,OAAO,wHAAwH,OAAO,+GAA+G,OAAO,kJAAkJ,oEAAoE,eAAe,OAAO,uJAAuJ,uFAAuF,eAAe,OAAO,uDAAuD,0DAA0D,eAAe,OAAO,mFAAmF,sDAAsD,eAAe,OAAO,uFAAuF,OAAO,sHAAsH,iEAAiE,aAAa,uDAAuD,2EAA2E,iBAAiB,kBAAkB,iCAAiC,4DAA4D,EAAE,uOAAuO,yEAAyE,4DAA4D,UAAU,qBAAqB,yDAAyD,yBAAyB,4EAA4E,0BAA0B,6DAA6D,mBAAmB,+GAA+G,wGAAwG,aAAa,WAAW,mBAAmB,sEAAsE,sBAAsB,yEAAyE,SAAS,QAAQ,0GAA0G,6DAA6D,OAAO,mFAAmF,oEAAoE,OAAO,qEAAqE,2EAA2E,yCAAyC,+EAA+E,MAAM,stBAAstB,OAAO,uBAAuB,OAAO,4DAA4D,OAAO,wEAAwE,QAAQ,6FAA6F,uDAAuD,wEAAwE,iBAAiB,kBAAkB,iCAAiC,sGAAsG,EAAE,wFAAwF,EAAE,iFAAiF,6DAA6D,OAAO,iFAAiF,yCAAyC,kFAAkF,MAAM,4DAA4D,MAAM,iFAAiF,OAAO,mDAAmD,OAAO,8KAA8K,OAAO,mFAAmF,OAAO,+DAA+D,OAAO,yOAAyO,MAAM,iFAAiF,OAAO,mDAAmD,OAAO,4KAA4K,OAAO,iFAAiF,OAAO,+DAA+D,OAAO,wWAAwW,OAAO,uBAAuB,OAAO,qFAAqF,OAAO,gFAAgF,OAAO,uFAAuF,OAAO,wHAAwH,cAAc,iEAAiE,qDAAqD,uFAAuF,4CAA4C,4DAA4D,UAAU,qBAAqB,yDAAyD,sBAAsB,yDAAyD,mBAAmB,sEAAsE,sBAAsB,yEAAyE,SAAS,QAAQ,yCAAyC,8CAA8C,MAAM,sIAAsI,OAAO,uBAAuB,OAAO,qFAAqF,OAAO,gFAAgF,OAAO,uFAAuF,OAAO,wHAAwH,OAAO,sIAAsI,cAAc,iEAAiE,qDAAqD,mEAAmE,4CAA4C,4DAA4D,UAAU,qBAAqB,yDAAyD,sBAAsB,yDAAyD,mBAAmB,sDAAsD,mBAAmB,sEAAsE,sBAAsB,yEAAyE,SAAS,QAAQ,iFAAiF,8CAA8C,MAAM,kLAAkL,cAAc,eAAe,iCAAiC,4DAA4D,EAAE,wBAAwB,yDAAyD,EAAE,oEAAoE,uGAAuG,6CAA6C,4DAA4D,UAAU,qBAAqB,yDAAyD,uBAAuB,0DAA0D,mBAAmB,sEAAsE,sBAAsB,yEAAyE,SAAS,QAAQ,iEAAiE,mEAAmE,4CAA4C,4EAA4E,MAAM,oQAAoQ,YAAY,KAAK,gCAAgC,2DAA2D,OAAO,uBAAuB,OAAO,qFAAqF,OAAO,gFAAgF,OAAO,yHAAyH,OAAO,uFAAuF,OAAO,wFAAwF,cAAc,sIAAsI,cAAc,eAAe,gDAAgD,4DAA4D,UAAU,qBAAqB,yDAAyD,sBAAsB,yDAAyD,wBAAwB,2DAA2D,mBAAmB,sEAAsE,SAAS,QAAQ,wBAAwB,yDAAyD,EAAE,iEAAiE,sKAAsK,iEAAiE,0DAA0D,4EAA4E,MAAM,8KAA8K,gBAAgB,sDAAsD,QAAQ,mEAAmE,SAAS,yFAAyF,cAAc,sBAAsB,4DAA4D,mCAAmC,sCAAsC,OAAO,+CAA+C,8FAA8F,EAAE,wBAAwB,yDAAyD,EAAE,sCAAsC,uDAAuD,gFAAgF,EAAE,OAAO,6EAA6E,wCAAwC,kBAAkB,6CAA6C,MAAM,2DAA2D,MAAM,6CAA6C,OAAO,sKAAsK,OAAO,6DAA6D,iBAAiB,kBAAkB,8DAA8D,0EAA0E,cAAc,qCAAqC,gEAAgE,EAAE,wBAAwB,yDAAyD,EAAE,8DAA8D,sIAAsI,qBAAqB,GAAG,MAAM,6DAA6D,MAAM,uFAAuF,OAAO,sPAAsP,OAAO,uBAAuB,OAAO,oDAAoD,OAAO,wIAAwI,OAAO,yIAAyI,OAAO,iJAAiJ,OAAO,uEAAuE,OAAO,yEAAyE,OAAO,sDAAsD,mBAAmB,kBAAkB,2DAA2D,wEAAwE,cAAc,eAAe,gDAAgD,4DAA4D,UAAU,uBAAuB,2DAA2D,SAAS,QAAQ,wBAAwB,yDAAyD,EAAE,gEAAgE,kFAAkF,iEAAiE,4EAA4E,MAAM,4HAA4H,SAAS,sEAAsE,cAAc,4BAA4B,yDAAyD,EAAE,+EAA+E,gEAAgE,MAAM,wCAAwC,aAAa,mEAAmE,2CAA2C,+BAA+B,+BAA+B,wBAAwB,0BAA0B,mBAAmB,OAAO,oDAAoD,KAAK,yCAAyC,sCAAsC,qBAAqB,gBAAgB,OAAO,mCAAmC,OAAO,iBAAiB,KAAK,2CAA2C,sBAAsB,qBAAqB,kBAAkB,OAAO,gDAAgD,OAAO,oBAAoB,KAAK,8BAA8B,kJAAkJ,2BAA2B,8BAA8B,qGAAqG,kFAAkF,KAAK,0BAA0B,+CAA+C,aAAa,8CAA8C,kDAAkD,cAAc,kEAAkE,KAAK,0CAA0C,yDAAyD,KAAK,0BAA0B,qEAAqE,aAAa,mEAAmE,2CAA2C,0CAA0C,kDAAkD,8CAA8C,8BAA8B,8DAA8D,+CAA+C,KAAK,kEAAkE,sBAAsB,4DAA4D,uBAAuB,OAAO,mFAAmF,uBAAuB,OAAO,iGAAiG,4CAA4C,gEAAgE,0CAA0C,OAAO,yBAAyB,MAAM,6FAA6F,qEAAqE,2DAA2D,yDAAyD,sDAAsD,EAAE,kBAAkB,uDAAuD,MAAM,mFAAmF,0BAA0B,0EAA0E,uDAAuD,6BAA6B,MAAM,4CAA4C,aAAa,mEAAmE,yEAAyE,iCAAiC,OAAO,2HAA2H,mCAAmC,QAAQ,8EAA8E,OAAO,sBAAsB,OAAO,+DAA+D,4CAA4C,4CAA4C,SAAS,mBAAmB,OAAO,uFAAuF,OAAO,uBAAuB,SAAS,qBAAqB,QAAQ,8HAA8H,gDAAgD,+FAA+F,oBAAoB,QAAQ,gJAAgJ,OAAO,uBAAuB,SAAS,qBAAqB,QAAQ,sFAAsF,uBAAuB,8BAA8B,oCAAoC,SAAS,yBAAyB,2BAA2B,oBAAoB,QAAQ,2HAA2H,OAAO,uBAAuB,SAAS,qBAAqB,QAAQ,sNAAsN,gDAAgD,wDAAwD,+BAA+B,sBAAsB,SAAS,oFAAoF,oCAAoC,wEAAwE,8CAA8C,sBAAsB,SAAS,uDAAuD,uBAAuB,sBAAsB,OAAO,4BAA4B,0CAA0C,mCAAmC,kBAAkB,WAAW,SAAS,oBAAoB,QAAQ,kFAAkF,OAAO,uBAAuB,MAAM,sBAAsB,QAAQ,8DAA8D,gDAAgD,mGAAmG,8BAA8B,yCAAyC,iDAAiD,SAAS,OAAO,2CAA2C,WAAW,SAAS,0BAA0B,QAAQ,uFAAuF,OAAO,wBAAwB,MAAM,uFAAuF,gDAAgD,kDAAkD,QAAQ,4FAA4F,OAAO,wBAAwB,QAAQ,0FAA0F,+CAA+C,QAAQ,eAAe,mEAAmE,OAAO,2BAA2B,iBAAiB,gEAAgE,OAAO,8DAA8D,0CAA0C,OAAO,YAAY,6DAA6D,OAAO,KAAK,oBAAoB,sHAAsH,0HAA0H,8BAA8B,yCAAyC,8BAA8B,wCAAwC,wCAAwC,yCAAyC,qCAAqC,gBAAgB,WAAW,sFAAsF,8FAA8F,kIAAkI,8BAA8B,+IAA+I,OAAO,oGAAoG,OAAO,qMAAqM,kHAAkH,8BAA8B,0BAA0B,EAAE,qEAAqE,+EAA+E,0EAA0E,mDAAmD,uBAAuB,iJAAiJ,sDAAsD,yEAAyE,4BAA4B,uBAAuB,iIAAiI,4FAA4F,yCAAyC,mBAAmB,kNAAkN,OAAO,6LAA6L,4DAA4D,mDAAmD,+DAA+D,0CAA0C,mBAAmB,iTAAiT,gDAAgD,qEAAqE,0BAA0B,EAAE,0DAA0D,mBAAmB,mIAAmI,OAAO,iJAAiJ,qEAAqE,EAAE,qEAAqE,4DAA4D,wEAAwE,4EAA4E,2BAA2B,uBAAuB,0IAA0I,8DAA8D,uBAAuB,mBAAmB,+HAA+H,OAAO,sIAAsI,2DAA2D,8DAA8D,mBAAmB,gBAAgB,WAAW,IAAI,2FAA2F,MAAM,yDAAyD,OAAO,mIAAmI,kHAAkH,MAAM,oEAAoE,OAAO,gMAAgM,6FAA6F,gGAAgG,iEAAiE,mDAAmD,kDAAkD,+CAA+C,mBAAmB,OAAO,uDAAuD,mBAAmB,eAAe,qHAAqH,QAAQ,qHAAqH,OAAO,sIAAsI,uDAAuD,wEAAwE,6DAA6D,0DAA0D,eAAe,6HAA6H,UAAU,8EAA8E,UAAU,6HAA6H,6DAA6D,2EAA2E,kDAAkD,mDAAmD,wDAAwD,yEAAyE,wEAAwE,qFAAqF,kBAAkB,OAAO,4FAA4F,iHAAiH,uBAAuB,mBAAmB,OAAO,qFAAqF,kBAAkB,UAAU,mFAAmF,uBAAuB,mBAAmB,gDAAgD,gEAAgE,eAAe,kKAAkK,mDAAmD,uEAAuE,+CAA+C,iHAAiH,yDAAyD,eAAe,mHAAmH,UAAU,uHAAuH,mDAAmD,oDAAoD,oDAAoD,mCAAmC,eAAe,8HAA8H,OAAO,yFAAyF,UAAU,+LAA+L,0DAA0D,iCAAiC,+CAA+C,oCAAoC,2CAA2C,4CAA4C,8CAA8C,iFAAiF,iFAAiF,oEAAoE,gDAAgD,wCAAwC,wEAAwE,uBAAuB,mBAAmB,EAAE,6CAA6C,YAAY,UAAU,0EAA0E,qDAAqD,2DAA2D,mBAAmB,+DAA+D,eAAe,WAAW,EAAE,8FAA8F,kGAAkG,iHAAiH,UAAU,oEAAoE,OAAO,4LAA4L,gEAAgE,4EAA4E,oDAAoD,oEAAoE,iCAAiC,cAAc,OAAO,gFAAgF,+DAA+D,gEAAgE,mBAAmB,+CAA+C,eAAe,sHAAsH,OAAO,iEAAiE,UAAU,wLAAwL,yDAAyD,gFAAgF,iEAAiE,iCAAiC,kBAAkB,UAAU,gGAAgG,mBAAmB,yEAAyE,eAAe,YAAY,2GAA2G,oHAAoH,UAAU,oEAAoE,OAAO,qMAAqM,gEAAgE,4EAA4E,oDAAoD,uEAAuE,iCAAiC,cAAc,OAAO,gFAAgF,kEAAkE,mBAAmB,kDAAkD,eAAe,yHAAyH,OAAO,uEAAuE,UAAU,8LAA8L,4DAA4D,sFAAsF,iEAAiE,iCAAiC,qBAAqB,OAAO,+FAA+F,mBAAmB,wEAAwE,eAAe,YAAY,sGAAsG,mHAAmH,UAAU,oEAAoE,OAAO,gMAAgM,gEAAgE,uBAAuB,qFAAqF,mBAAmB,YAAY,8DAA8D,mBAAmB,eAAe,wHAAwH,OAAO,oEAAoE,UAAU,0LAA0L,0DAA0D,6EAA6E,eAAe,YAAY,uMAAuM,OAAO,8LAA8L,8MAA8M,mDAAmD,uFAAuF,uCAAuC,eAAe,+HAA+H,iBAAiB,gMAAgM,+DAA+D,yDAAyD,+HAA+H,8CAA8C,mBAAmB,yEAAyE,oDAAoD,eAAe,8OAA8O,QAAQ,6GAA6G,UAAU,wJAAwJ,oFAAoF,6DAA6D,sEAAsE,6CAA6C,mDAAmD,iDAAiD,qDAAqD,8GAA8G,gCAAgC,wHAAwH,mBAAmB,OAAO,4OAA4O,mBAAmB,uGAAuG,sHAAsH,2EAA2E,0CAA0C,sBAAsB,uBAAuB,+HAA+H,uBAAuB,+HAA+H,mDAAmD,mBAAmB,wHAAwH,eAAe,+GAA+G,OAAO,oIAAoI,mDAAmD,oDAAoD,mDAAmD,mCAAmC,eAAe,+CAA+C,EAAE,2FAA2F,OAAO,uKAAuK,4NAA4N,OAAO,oMAAoM,qDAAqD,4FAA4F,0EAA0E,eAAe,4KAA4K,mDAAmD,gGAAgG,wFAAwF,eAAe,mHAAmH,iBAAiB,+EAA+E,OAAO,oHAAoH,8CAA8C,iEAAiE,yEAAyE,0EAA0E,gEAAgE,eAAe,mNAAmN,iBAAiB,2FAA2F,UAAU,qHAAqH,2DAA2D,2DAA2D,mEAAmE,+EAA+E,kDAAkD,mBAAmB,sGAAsG,kCAAkC,eAAe,+KAA+K,OAAO,oFAAoF,SAAS,kNAAkN,iEAAiE,kDAAkD,oEAAoE,oBAAoB,eAAe,2IAA2I,OAAO,wFAAwF,SAAS,0NAA0N,qEAAqE,kDAAkD,iFAAiF,oBAAoB,eAAe,WAAW,EAAE,kGAAkG,uBAAuB,OAAO,QAAQ,8BAA8B,SAAS,GAAG,WAAW,mEAAmE,OAAO,2BAA2B,iBAAiB,uFAAuF,OAAO,8DAA8D,oDAAoD,OAAO,YAAY,0DAA0D,OAAO,KAAK,4BAA4B,4BAA4B,iDAAiD,4BAA4B,0CAA0C,oCAAoC,8BAA8B,+EAA+E,qBAAqB,0DAA0D,mCAAmC,2CAA2C,sCAAsC,iBAAiB,YAAY,0CAA0C,uCAAuC,uBAAuB,mBAAmB,kCAAkC,eAAe,iDAAiD,2DAA2D,eAAe,4BAA4B,6BAA6B,mCAAmC,mCAAmC,uCAAuC,4EAA4E,uBAAuB,wEAAwE,mCAAmC,mBAAmB,0BAA0B,eAAe,WAAW,IAAI,qDAAqD,wHAAwH,qCAAqC,8DAA8D,eAAe,0DAA0D,wEAAwE,yEAAyE,+BAA+B,+BAA+B,+BAA+B,+BAA+B,+BAA+B,+BAA+B,+BAA+B,qEAAqE,QAAQ,OAAO,mCAAmC,mDAAmD,uBAAuB,OAAO,kDAAkD,qNAAqN,qDAAqD,sNAAsN,4EAA4E,uBAAuB,uDAAuD,4DAA4D,qHAAqH,iHAAiH,iEAAiE,4CAA4C,gCAAgC,4BAA4B,4BAA4B,uCAAuC,4BAA4B,4BAA4B,4BAA4B,wCAAwC,mBAAmB,wFAAwF,wCAAwC,wCAAwC,wCAAwC,wCAAwC,wCAAwC,wCAAwC,wCAAwC,eAAe,6CAA6C,sEAAsE,6CAA6C,4DAA4D,oDAAoD,kHAAkH,yGAAyG,+EAA+E,uDAAuD,4EAA4E,uFAAuF,eAAe,uCAAuC,sDAAsD,mDAAmD,mCAAmC,eAAe,WAAW,EAAE,kHAAkH,iBAAiB,+DAA+D,UAAU,8IAA8I,uDAAuD,+DAA+D,gHAAgH,iBAAiB,kDAAkD,iBAAiB,sDAAsD,UAAU,qJAAqJ,uEAAuE,OAAO,QAAQ,qCAAqC,SAAS,GAAG,WAAW,8CAA8C,8BAA8B,gDAAgD,kBAAkB,MAAM,gDAAgD,mBAAmB,MAAM,gDAAgD,MAAM,oCAAoC,aAAa,8CAA8C,4CAA4C,uCAAuC,qCAAqC,KAAK,mDAAmD,gDAAgD,yCAAyC,qCAAqC,KAAK,qDAAqD,0BAA0B,mGAAmG,aAAa,mEAAmE,2CAA2C,yCAAyC,0CAA0C,gCAAgC,+CAA+C,2CAA2C,kBAAkB,iDAAiD,KAAK,uCAAuC,iEAAiE,4EAA4E,iCAAiC,gBAAgB,kBAAkB,wBAAwB,oBAAoB,WAAW,0EAA0E,mDAAmD,OAAO,oCAAoC,0CAA0C,gCAAgC,aAAa,WAAW,6CAA6C,SAAS,EAAE,KAAK,0BAA0B,mDAAmD,aAAa,mEAAmE,oNAAoN,yCAAyC,8BAA8B,oaAAoa,0BAA0B,0BAA0B,4CAA4C,oBAAoB,iBAAiB,uFAAuF,6CAA6C,mCAAmC,OAAO,OAAO,4CAA4C,OAAO,KAAK,sDAAsD,2CAA2C,2CAA2C,8BAA8B,yDAAyD,kBAAkB,iFAAiF,SAAS,OAAO,gBAAgB,KAAK,mEAAmE,2DAA2D,+CAA+C,iDAAiD,0EAA0E,OAAO,2DAA2D,mEAAmE,0DAA0D,oCAAoC,qBAAqB,OAAO,2DAA2D,+DAA+D,OAAO,mEAAmE,2CAA2C,MAAM,qCAAqC,aAAa,mEAAmE,gDAAgD,yCAAyC,uCAAuC,wCAAwC,6CAA6C,kCAAkC,mFAAmF,OAAO,0BAA0B,OAAO,yHAAyH,OAAO,iIAAiI,OAAO,gGAAgG,OAAO,8HAA8H,OAAO,6KAA6K,qCAAqC,iEAAiE,wDAAwD,mCAAmC,uCAAuC,wCAAwC,gFAAgF,oDAAoD,qGAAqG,OAAO,+DAA+D,+JAA+J,OAAO,KAAK,yDAAyD,MAAM,sEAAsE,QAAQ,wbAAwb,OAAO,wCAAwC,OAAO,oFAAoF,eAAe,oIAAoI,mCAAmC,qCAAqC,8BAA8B,OAAO,oHAAoH,gEAAgE,mCAAmC,+BAA+B,oCAAoC,gCAAgC,gCAAgC,gCAAgC,6CAA6C,yEAAyE,6FAA6F,OAAO,sCAAsC,+FAA+F,OAAO,yCAAyC,gKAAgK,OAAO,iCAAiC,kFAAkF,OAAO,+DAA+D,mEAAmE,0CAA0C,OAAO,4EAA4E,kBAAkB,yBAAyB,SAAS,4DAA4D,uCAAuC,SAAS,wEAAwE,OAAO,EAAE,MAAM,8IAA8I,OAAO,wCAAwC,OAAO,yCAAyC,QAAQ,2HAA2H,2BAA2B,gCAAgC,gCAAgC,8CAA8C,oBAAoB,OAAO,mDAAmD,8BAA8B,gEAAgE,OAAO,2CAA2C,oBAAoB,OAAO,+CAA+C,0BAA0B,mJAAmJ,OAAO,sBAAsB,MAAM,8IAA8I,OAAO,wCAAwC,OAAO,yCAAyC,QAAQ,2HAA2H,2BAA2B,gCAAgC,gCAAgC,8CAA8C,oBAAoB,OAAO,mDAAmD,8BAA8B,gEAAgE,OAAO,mDAAmD,8BAA8B,qIAAqI,OAAO,kBAAkB,MAAM,4EAA4E,uBAAuB,+BAA+B,8CAA8C,sBAAsB,8CAA8C,2BAA2B,oBAAoB,oBAAoB,WAAW,iDAAiD,kEAAkE,SAAS,EAAE,OAAO,OAAO,mDAAmD,mGAAmG,OAAO,MAAM,yDAAyD,OAAO,kBAAkB,OAAO,sDAAsD,OAAO,0CAA0C,OAAO,2JAA2J,OAAO,wCAAwC,aAAa,+GAA+G,mCAAmC,iBAAiB,kBAAkB,mCAAmC,+EAA+E,OAAO,eAAe,6DAA6D,8DAA8D,OAAO,YAAY,2FAA2F,OAAO,kBAAkB,kEAAkE,6FAA6F,QAAQ,MAAM,yCAAyC,aAAa,mEAAmE,kBAAkB,4OAA4O,6EAA6E,iDAAiD,uEAAuE,qFAAqF,gFAAgF,sCAAsC,SAAS,mEAAmE,6BAA6B,EAAE,wcAAwc,2BAA2B,uCAAuC,wCAAwC,iCAAiC,WAAW,mBAAmB,SAAS,uNAAuN,wCAAwC,2BAA2B,mCAAmC,kCAAkC,8BAA8B,0DAA0D,gDAAgD,kCAAkC,WAAW,mBAAmB,SAAS,6JAA6J,wCAAwC,2BAA2B,mCAAmC,kCAAkC,8BAA8B,6CAA6C,qCAAqC,iCAAiC,WAAW,mBAAmB,SAAS,2DAA2D,yFAAyF,wCAAwC,qBAAqB,SAAS,2EAA2E,wCAAwC,qBAAqB,SAAS,cAAc,gFAAgF,qBAAqB,SAAS,4CAA4C,iDAAiD,6CAA6C,2BAA2B,oDAAoD,8CAA8C,gDAAgD,6FAA6F,gCAAgC,kBAAkB,iCAAiC,mBAAmB,SAAS,wBAAwB,iCAAiC,oBAAoB,SAAS,wBAAwB,iCAAiC,oBAAoB,SAAS,wBAAwB,kCAAkC,wBAAwB,EAAE,6BAA6B,yCAAyC,gCAAgC,SAAS,wEAAwE,+BAA+B,QAAQ,qBAAqB,uBAAuB,uBAAuB,SAAS,kGAAkG,qBAAqB,8BAA8B,gCAAgC,8CAA8C,0BAA0B,SAAS,0EAA0E,eAAe,cAAc,UAAU,EAAE,yFAAyF,gBAAgB,4BAA4B,gCAAgC,kCAAkC,8CAA8C,iCAAiC,gCAAgC,gBAAgB,qBAAqB,QAAQ,EAAE,qBAAqB,qBAAqB,+CAA+C,2BAA2B,gDAAgD,uBAAuB,iDAAiD,uBAAuB,aAAa,uBAAuB,wDAAwD,qCAAqC,8DAA8D,iDAAiD,aAAa,sDAAsD,oBAAoB,4CAA4C,WAAW,0CAA0C,wBAAwB,mEAAmE,WAAW,uBAAuB,kDAAkD,SAAS,mFAAmF,iCAAiC,4DAA4D,SAAS,mGAAmG,gEAAgE,gBAAgB,4BAA4B,gCAAgC,gCAAgC,iCAAiC,gCAAgC,sCAAsC,gEAAgE,wCAAwC,uBAAuB,qDAAqD,UAAU,iBAAiB,EAAE,2BAA2B,yBAAyB,gDAAgD,+CAA+C,eAAe,oBAAoB,yCAAyC,4BAA4B,cAAc,KAAK,EAAE,eAAe,iCAAiC,qCAAqC,aAAa,WAAW,2BAA2B,SAAS,0DAA0D,eAAe,+BAA+B,UAAU,EAAE,wDAAwD,sCAAsC,EAAE,wGAAwG,6BAA6B,8BAA8B,yBAAyB,oBAAoB,4CAA4C,6DAA6D,mBAAmB,SAAS,6EAA6E,uBAAuB,+BAA+B,OAAO,SAAS,EAAE,6BAA6B,OAAO,QAAQ,EAAE,6BAA6B,OAAO,QAAQ,EAAE,6BAA6B,OAAO,QAAQ,EAAE,6BAA6B,OAAO,QAAQ,EAAE,mBAAmB,SAAS,6FAA6F,mCAAmC,2EAA2E,SAAS,+EAA+E,gBAAgB,2BAA2B,QAAQ,uBAAuB,sBAAsB,QAAQ,eAAe,yBAAyB,uBAAuB,SAAS,+EAA+E,wBAAwB,YAAY,uBAAuB,qCAAqC,uBAAuB,SAAS,2EAA2E,6BAA6B,+BAA+B,8BAA8B,sEAAsE,2BAA2B,QAAQ,OAAO,yCAAyC,iCAAiC,WAAW,uBAAuB,QAAQ,eAAe,oBAAoB,4BAA4B,uBAAuB,oBAAoB,SAAS,2EAA2E,uBAAuB,yCAAyC,4BAA4B,SAAS,QAAQ,EAAE,6BAA6B,+BAA+B,6BAA6B,8BAA8B,2BAA2B,YAAY,OAAO,2CAA2C,kCAAkC,WAAW,wDAAwD,0BAA0B,oBAAoB,SAAS,uEAAuE,qDAAqD,wBAAwB,8BAA8B,+BAA+B,0BAA0B,WAAW,4BAA4B,qBAAqB,+BAA+B,2BAA2B,iCAAiC,4BAA4B,aAAa,wBAAwB,WAAW,gBAAgB,wBAAwB,4BAA4B,wBAAwB,iCAAiC,4BAA4B,aAAa,qBAAqB,WAAW,2BAA2B,wCAAwC,oCAAoC,kBAAkB,oBAAoB,SAAS,iKAAiK,0CAA0C,sBAAsB,sBAAsB,mCAAmC,oBAAoB,SAAS,wCAAwC,kBAAkB,oBAAoB,uDAAuD,SAAS,6FAA6F,6BAA6B,8BAA8B,mCAAmC,oBAAoB,WAAW,OAAO,2CAA2C,wEAAwE,+BAA+B,6BAA6B,aAAa,WAAW,yDAAyD,kBAAkB,oBAAoB,SAAS,8KAA8K,2BAA2B,+BAA+B,8BAA8B,2BAA2B,uCAAuC,yCAAyC,mBAAmB,WAAW,kCAAkC,+CAA+C,8CAA8C,8CAA8C,oBAAoB,oBAAoB,EAAE,gBAAgB,cAAc,cAAc,EAAE,uBAAuB,2BAA2B,6BAA6B,+DAA+D,oEAAoE,uDAAuD,2BAA2B,mCAAmC,yBAAyB,yBAAyB,WAAW,yCAAyC,uBAAuB,8FAA8F,2BAA2B,kHAAkH,kDAAkD,+CAA+C,2BAA2B,8CAA8C,aAAa,WAAW,yBAAyB,8BAA8B,oDAAoD,WAAW,mBAAmB,oBAAoB,wCAAwC,yEAAyE,SAAS,6DAA6D,wBAAwB,wCAAwC,0EAA0E,mBAAmB,SAAS,yFAAyF,YAAY,EAAE,8BAA8B,uEAAuE,wBAAwB,SAAS,6BAA6B,UAAU,EAAE,6BAA6B,2BAA2B,EAAE,gCAAgC,mBAAmB,gBAAgB,EAAE,8BAA8B,eAAe,gBAAgB,EAAE,iDAAiD,2CAA2C,2CAA2C,yCAAyC,yCAAyC,qDAAqD,wdAAwd,kCAAkC,0BAA0B,kCAAkC,sBAAsB,8DAA8D,0DAA0D,2EAA2E,mFAAmF,sHAAsH,oIAAoI,SAAS,mEAAmE,qBAAqB,iCAAiC,oCAAoC,iCAAiC,qCAAqC,2BAA2B,SAAS,wDAAwD,wBAAwB,wCAAwC,oCAAoC,4EAA4E,mBAAmB,SAAS,wDAAwD,wBAAwB,sBAAsB,yBAAyB,mBAAmB,SAAS,wEAAwE,8FAA8F,wBAAwB,cAAc,OAAO,4FAA4F,wFAAwF,gGAAgG,mDAAmD,+DAA+D,cAAc,UAAU,EAAE,WAAW,oBAAoB,kCAAkC,yDAAyD,SAAS,mCAAmC,wCAAwC,eAAe,gBAAgB,EAAE,kCAAkC,4CAA4C,mBAAmB,gBAAgB,EAAE,uDAAuD,iDAAiD,iDAAiD,+CAA+C,+CAA+C,8EAA8E,6CAA6C,EAAE,mHAAmH,4DAA4D,yEAAyE,sBAAsB,2BAA2B,0BAA0B,+CAA+C,kBAAkB,WAAW,QAAQ,QAAQ,EAAE,WAAW,6BAA6B,SAAS,oFAAoF,gBAAgB,uDAAuD,4BAA4B,+BAA+B,SAAS,wEAAwE,kDAAkD,wDAAwD,8CAA8C,sDAAsD,sDAAsD,oDAAoD,oDAAoD,8CAA8C,wDAAwD,oDAAoD,oDAAoD,oDAAoD,gDAAgD,0CAA0C,wEAAwE,+CAA+C,yCAAyC,qDAAqD,qDAAqD,yCAAyC,qDAAqD,6DAA6D,gCAAgC,2XAA2X,eAAe,gBAAgB,UAAU,EAAE,8EAA8E,0BAA0B,mDAAmD,2CAA2C,WAAW,8CAA8C,wCAAwC,qGAAqG,SAAS,4EAA4E,6CAA6C,EAAE,+FAA+F,6CAA6C,EAAE,mFAAmF,iDAAiD,EAAE,kFAAkF,mCAAmC,yEAAyE,wBAAwB,SAAS,kFAAkF,+BAA+B,iEAAiE,qCAAqC,iCAAiC,yDAAyD,+BAA+B,iCAAiC,2DAA2D,8BAA8B,WAAW,8CAA8C,SAAS,wFAAwF,0BAA0B,+BAA+B,qCAAqC,2DAA2D,wBAAwB,cAAc,OAAO,+BAA+B,uBAAuB,uEAAuE,uBAAuB,aAAa,sBAAsB,2BAA2B,gCAAgC,mCAAmC,oBAAoB,oBAAoB,aAAa,WAAW,qBAAqB,0CAA0C,iCAAiC,WAAW,kDAAkD,SAAS,uFAAuF,sCAAsC,gFAAgF,kBAAkB,mCAAmC,+HAA+H,qDAAqD,4DAA4D,qCAAqC,wFAAwF,eAAe,aAAa,WAAW,gBAAgB,+EAA+E,gCAAgC,2BAA2B,yCAAyC,eAAe,mCAAmC,WAAW,SAAS,yFAAyF,0CAA0C,wBAAwB,kDAAkD,uBAAuB,qHAAqH,2BAA2B,yBAAyB,gDAAgD,+CAA+C,eAAe,oBAAoB,2CAA2C,4BAA4B,cAAc,KAAK,EAAE,eAAe,0CAA0C,0DAA0D,kDAAkD,aAAa,WAAW,mBAAmB,SAAS,kCAAkC,8BAA8B,EAAE,2BAA2B,oCAAoC,EAAE,2BAA2B,oCAAoC,EAAE,yFAAyF,6CAA6C,oBAAoB,OAAO,8BAA8B,4BAA4B,4BAA4B,sBAAsB,YAAY,2BAA2B,yBAAyB,WAAW,gBAAgB,+BAA+B,sBAAsB,SAAS,wBAAwB,sBAAsB,WAAW,+BAA+B,oBAAoB,SAAS,8DAA8D,YAAY,EAAE,2BAA2B,eAAe,4BAA4B,UAAU,EAAE,6DAA6D,YAAY,EAAE,0BAA0B,eAAe,2BAA2B,UAAU,EAAE,8DAA8D,YAAY,EAAE,2BAA2B,eAAe,4BAA4B,UAAU,EAAE,kEAAkE,aAAa,EAAE,8BAA8B,eAAe,+BAA+B,UAAU,EAAE,uDAAuD,wBAAwB,wBAAwB,YAAY,8BAA8B,uBAAuB,wBAAwB,mBAAmB,SAAS,kEAAkE,wBAAwB,wCAAwC,yBAAyB,mBAAmB,SAAS,mEAAmE,wBAAwB,wCAAwC,yBAAyB,mBAAmB,SAAS,oFAAoF,+BAA+B,oBAAoB,+BAA+B,UAAU,SAAS,EAAE,6BAA6B,SAAS,QAAQ,EAAE,4BAA4B,SAAS,QAAQ,EAAE,0BAA0B,SAAS,QAAQ,EAAE,6BAA6B,mBAAmB,SAAS,2GAA2G,wBAAwB,YAAY,iEAAiE,+CAA+C,oBAAoB,SAAS,qEAAqE,oBAAoB,yBAAyB,UAAU,KAAK,EAAE,mBAAmB,SAAS,gFAAgF,wCAAwC,wBAAwB,YAAY,2BAA2B,mBAAmB,SAAS,8EAA8E,wCAAwC,4CAA4C,gDAAgD,SAAS,8EAA8E,8CAA8C,iCAAiC,mBAAmB,SAAS,mEAAmE,gCAAgC,EAAE,sEAAsE,oCAAoC,EAAE,oEAAoE,iCAAiC,EAAE,uEAAuE,qDAAqD,wBAAwB,8BAA8B,+BAA+B,0BAA0B,WAAW,4BAA4B,qBAAqB,+BAA+B,2BAA2B,iCAAiC,4BAA4B,aAAa,wBAAwB,WAAW,gBAAgB,wBAAwB,4BAA4B,wBAAwB,iCAAiC,4BAA4B,aAAa,qBAAqB,WAAW,2BAA2B,+BAA+B,6CAA6C,kBAAkB,oBAAoB,SAAS,2DAA2D,eAAe,iBAAiB,UAAU,EAAE,gEAAgE,eAAe,iBAAiB,UAAU,EAAE,gEAAgE,eAAe,sBAAsB,UAAU,EAAE,2DAA2D,eAAe,kBAAkB,UAAU,EAAE,8DAA8D,eAAe,yBAAyB,UAAU,EAAE,iEAAiE,eAAe,yBAAyB,UAAU,EAAE,iFAAiF,mCAAmC,+BAA+B,gCAAgC,SAAS,6FAA6F,wDAAwD,mBAAmB,uBAAuB,SAAS,+FAA+F,4BAA4B,gDAAgD,uBAAuB,qCAAqC,+BAA+B,iDAAiD,sBAAsB,WAAW,SAAS,8DAA8D,0BAA0B,UAAU,EAAE,gCAAgC,mBAAmB,EAAE,8BAA8B,eAAe,EAAE,6CAA6C,wCAAwC,yCAAyC,yCAAyC,yDAAyD,kCAAkC,EAAE,8KAA8K,yCAAyC,kBAAkB,yCAAyC,kCAAkC,gBAAgB,6BAA6B,OAAO,iDAAiD,kCAAkC,OAAO,gCAAgC,oBAAoB,SAAS,gLAAgL,cAAc,qCAAqC,kBAAkB,0DAA0D,uCAAuC,SAAS,oEAAoE,oBAAoB,2BAA2B,SAAS,qEAAqE,oDAAoD,0BAA0B,kDAAkD,sCAAsC,qBAAqB,SAAS,wCAAwC,+DAA+D,oDAAoD,gBAAgB,eAAe,aAAa,gBAAgB,UAAU,EAAE,SAAS,uCAAuC,UAAU,EAAE,yEAAyE,0CAA0C,gCAAgC,kBAAkB,WAAW,EAAE,8DAA8D,6DAA6D,qEAAqE,6BAA6B,4DAA4D,SAAS,6BAA6B,2CAA2C,eAAe,gBAAgB,EAAE,6BAA6B,+CAA+C,mBAAmB,gBAAgB,EAAE,uDAAuD,iDAAiD,iDAAiD,+CAA+C,+CAA+C,8EAA8E,kDAAkD,8BAA8B,gCAAgC,gCAAgC,iCAAiC,iCAAiC,qBAAqB,kDAAkD,4DAA4D,gDAAgD,6FAA6F,iCAAiC,qBAAqB,2BAA2B,6BAA6B,4BAA4B,2BAA2B,sCAAsC,qBAAqB,aAAa,WAAW,0DAA0D,4BAA4B,yBAAyB,8CAA8C,kBAAkB,gDAAgD,oDAAoD,aAAa,sBAAsB,+BAA+B,SAAS,KAAK,EAAE,8BAA8B,cAAc,KAAK,EAAE,qBAAqB,mFAAmF,0BAA0B,aAAa,kBAAkB,4BAA4B,eAAe,eAAe,QAAQ,EAAE,sCAAsC,OAAO,OAAO,QAAQ,QAAQ,EAAE,iCAAiC,aAAa,qDAAqD,4BAA4B,OAAO,QAAQ,QAAQ,2BAA2B,eAAe,KAAK,EAAE,aAAa,WAAW,6BAA6B,SAAS,0EAA0E,wDAAwD,+CAA+C,kCAAkC,WAAW,OAAO,OAAO,EAAE,+DAA+D,6BAA6B,0BAA0B,qBAAqB,4BAA4B,4BAA4B,WAAW,iCAAiC,8DAA8D,8DAA8D,qCAAqC,2BAA2B,8BAA8B,aAAa,kBAAkB,2BAA2B,8BAA8B,aAAa,WAAW,oCAAoC,mBAAmB,SAAS,4EAA4E,8BAA8B,kDAAkD,6DAA6D,sCAAsC,QAAQ,0BAA0B,mBAAmB,SAAS,gFAAgF,8BAA8B,8EAA8E,8CAA8C,6DAA6D,kCAAkC,+BAA+B,8BAA8B,sBAAsB,gDAAgD,iBAAiB,cAAc,EAAE,gCAAgC,eAAe,gDAAgD,8BAA8B,aAAa,+BAA+B,8BAA8B,sBAAsB,gDAAgD,iBAAiB,cAAc,EAAE,gCAAgC,eAAe,gDAAgD,8BAA8B,aAAa,qCAAqC,2BAA2B,kCAAkC,2BAA2B,aAAa,kBAAkB,2BAA2B,kCAAkC,2BAA2B,aAAa,WAAW,sEAAsE,uDAAuD,0CAA0C,eAAe,6CAA6C,eAAe,SAAS,iqBAAiqB,0DAA0D,sGAAsG,gCAAgC,iEAAiE,sBAAsB,sBAAsB,wDAAwD,yBAAyB,WAAW,sCAAsC,gBAAgB,uCAAuC,0CAA0C,yEAAyE,4BAA4B,gEAAgE,WAAW,kCAAkC,SAAS,8GAA8G,iDAAiD,uCAAuC,kCAAkC,mCAAmC,uBAAuB,wDAAwD,wBAAwB,wBAAwB,OAAO,OAAO,yIAAyI,qCAAqC,0EAA0E,wBAAwB,sDAAsD,wCAAwC,kEAAkE,eAAe,oDAAoD,aAAa,WAAW,sBAAsB,SAAS,8EAA8E,kDAAkD,sDAAsD,wDAAwD,sDAAsD,sDAAsD,8CAA8C,sDAAsD,wDAAwD,kEAAkE,kEAAkE,gDAAgD,0DAA0D,kEAAkE,mDAAmD,qDAAqD,uDAAuD,+CAA+C,yDAAyD,+CAA+C,yCAAyC,yCAAyC,yCAAyC,uCAAuC,yCAAyC,+CAA+C,yCAAyC,qDAAqD,uDAAuD,iEAAiE,mDAAmD,iDAAiD,+CAA+C,mDAAmD,iDAAiD,yCAAyC,mDAAmD,mDAAmD,+CAA+C,qDAAqD,uEAAuE,+CAA+C,uDAAuD,yCAAyC,yCAAyC,iEAAiE,qFAAqF,2gBAA2gB,8BAA8B,8DAA8D,mBAAmB,mBAAmB,kFAAkF,wCAAwC,+CAA+C,gDAAgD,gDAAgD,wDAAwD,OAAO,mGAAmG,2CAA2C,OAAO,iFAAiF,+BAA+B,qBAAqB,cAAc,8DAA8D,4CAA4C,6EAA6E,4CAA4C,oBAAoB,QAAQ,4CAA4C,SAAS,oFAAoF,4GAA4G,oBAAoB,cAAc,4DAA4D,SAAS,SAAS,qCAAqC,6FAA6F,uCAAuC,uCAAuC,SAAS,qBAAqB,wBAAwB,uCAAuC,uCAAuC,OAAO,mCAAmC,+BAA+B,wBAAwB,oCAAoC,iCAAiC,yBAAyB,4BAA4B,6CAA6C,qBAAqB,0BAA0B,SAAS,oFAAoF,OAAO,sCAAsC,cAAc,kBAAkB,eAAe,6BAA6B,OAAO,oCAAoC,2DAA2D,4EAA4E,mBAAmB,mBAAmB,6BAA6B,OAAO,oHAAoH,oBAAoB,kBAAkB,SAAS,2BAA2B,cAAc,kBAAkB,SAAS,OAAO,wDAAwD,sBAAsB,8BAA8B,sBAAsB,SAAS,mBAAmB,mBAAmB,OAAO,+BAA+B,cAAc,oCAAoC,iDAAiD,2BAA2B,wCAAwC,2BAA2B,kDAAkD,OAAO,4CAA4C,wCAAwC,8EAA8E,6BAA6B,OAAO,qKAAqK,iDAAiD,yCAAyC,iBAAiB,8CAA8C,OAAO,OAAO,qCAAqC,yCAAyC,OAAO,SAAS,aAAa,aAAa,mEAAmE,iEAAiE,SAAS,mBAAmB,QAAQ,qEAAqE,iCAAiC,uEAAuE,yCAAyC,KAAK,oCAAoC,aAAa,mEAAmE,kIAAkI,mFAAmF,mHAAmH,iCAAiC,KAAK,sEAAsE,OAAO,oBAAoB,OAAO,uDAAuD,8CAA8C,8CAA8C,OAAO,iBAAiB,KAAK,+DAA+D,QAAQ,4GAA4G,gCAAgC,+CAA+C,yBAAyB,wCAAwC,kBAAkB,MAAM,gKAAgK,SAAS,kFAAkF,wBAAwB,kBAAkB,MAAM,8UAA8U,qBAAqB,OAAO,oBAAoB,QAAQ,iGAAiG,+BAA+B,kBAAkB,MAAM,sLAAsL,SAAS,0FAA0F,4BAA4B,kBAAkB,MAAM,kaAAka,cAAc,QAAQ,yBAAyB,gBAAgB,QAAQ,wGAAwG,oDAAoD,gCAAgC,kCAAkC,oBAAoB,OAAO,sCAAsC,wBAAwB,uEAAuE,kBAAkB,+EAA+E,kBAAkB,+EAA+E,SAAS,OAAO,kBAAkB,MAAM,sKAAsK,OAAO,sBAAsB,QAAQ,kGAAkG,8GAA8G,gCAAgC,+BAA+B,wBAAwB,kBAAkB,MAAM,qDAAqD,QAAQ,0FAA0F,0BAA0B,sCAAsC,wBAAwB,kCAAkC,OAAO,gCAAgC,4BAA4B,6BAA6B,MAAM,sDAAsD,SAAS,uBAAuB,SAAS,yBAAyB,QAAQ,4EAA4E,qCAAqC,wBAAwB,8BAA8B,2JAA2J,SAAS,kFAAkF,sCAAsC,sCAAsC,wBAAwB,WAAW,EAAE,SAAS,EAAE,OAAO,2DAA2D,KAAK,oDAAoD,sCAAsC,MAAM,kGAAkG,eAAe,kBAAkB,KAAK,iDAAiD,uEAAuE,4BAA4B,kBAAkB,MAAM,6DAA6D,iBAAiB,qBAAqB,OAAO,iCAAiC,qCAAqC,OAAO,uDAAuD,MAAM,8FAA8F,OAAO,sBAAsB,OAAO,6EAA6E,+CAA+C,MAAM,sOAAsO,OAAO,sBAAsB,OAAO,gHAAgH,oRAAoR,kDAAkD,oDAAoD,8BAA8B,qBAAqB,cAAc,qBAAqB,OAAO,oBAAoB,QAAQ,+FAA+F,4BAA4B,gCAAgC,oCAAoC,SAAS,oBAAoB,OAAO,8CAA8C,+BAA+B,kBAAkB,MAAM,kLAAkL,qBAAqB,OAAO,+DAA+D,+CAA+C,gCAAgC,kBAAkB,MAAM,8OAA8O,qDAAqD,yBAAyB,yBAAyB,+BAA+B,cAAc,oBAAoB,sCAAsC,oBAAoB,QAAQ,6FAA6F,0GAA0G,mEAAmE,OAAO,2BAA2B,2HAA2H,OAAO,+BAA+B,+BAA+B,qCAAqC,SAAS,oBAAoB,OAAO,mCAAmC,4BAA4B,mCAAmC,SAAS,oBAAoB,OAAO,oFAAoF,kEAAkE,OAAO,qCAAqC,uBAAuB,OAAO,4CAA4C,kBAAkB,MAAM,uFAAuF,QAAQ,sEAAsE,0BAA0B,oBAAoB,OAAO,2BAA2B,mCAAmC,8CAA8C,kCAAkC,yBAAyB,kBAAkB,MAAM,+WAA+W,kGAAkG,iCAAiC,kBAAkB,MAAM,+GAA+G,OAAO,kBAAkB,QAAQ,4FAA4F,6BAA6B,kBAAkB,MAAM,yNAAyN,OAAO,4HAA4H,cAAc,gHAAgH,MAAM,sQAAsQ,gBAAgB,sHAAsH,aAAa,8UAA8U,aAAa,4OAA4O,cAAc,qBAAqB,QAAQ,0FAA0F,iCAAiC,8CAA8C,+BAA+B,wIAAwI,OAAO,qCAAqC,kCAAkC,0BAA0B,SAAS,gCAAgC,0BAA0B,SAAS,OAAO,2DAA2D,sDAAsD,OAAO,4DAA4D,+BAA+B,sCAAsC,SAAS,OAAO,oCAAoC,gFAAgF,4CAA4C,0DAA0D,yFAAyF,SAAS,OAAO,iDAAiD,SAAS,OAAO,OAAO,0BAA0B,OAAO,6CAA6C,oBAAoB,OAAO,+DAA+D,kBAAkB,MAAM,2dAA2d,4CAA4C,gBAAgB,yDAAyD,SAAS,qBAAqB,QAAQ,gGAAgG,sIAAsI,kBAAkB,MAAM,oKAAoK,0BAA0B,eAAe,OAAO,4DAA4D,4BAA4B,gCAAgC,wBAAwB,2BAA2B,mBAAmB,yBAAyB,MAAM,yDAAyD,sBAAsB,+DAA+D,4CAA4C,oEAAoE,SAAS,iBAAiB,OAAO,0FAA0F,2DAA2D,yFAAyF,SAAS,yBAAyB,OAAO,KAAK,aAAa,mEAAmE,2FAA2F,qFAAqF,qHAAqH,iCAAiC,KAAK,sEAAsE,OAAO,oBAAoB,OAAO,uDAAuD,+CAA+C,+CAA+C,OAAO,iBAAiB,KAAK,0EAA0E,OAAO,sBAAsB,OAAO,8EAA8E,gDAAgD,MAAM,8JAA8J,8FAA8F,OAAO,wGAAwG,gIAAgI,mCAAmC,2DAA2D,wDAAwD,4BAA4B,iCAAiC,8BAA8B,2DAA2D,aAAa,SAAS,cAAc,8BAA8B,MAAM,unBAAunB,OAAO,wGAAwG,oCAAoC,4EAA4E,+BAA+B,mDAAmD,4BAA4B,kCAAkC,qCAAqC,qCAAqC,6FAA6F,0DAA0D,uCAAuC,wCAAwC,0CAA0C,2CAA2C,uCAAuC,sCAAsC,MAAM,aAAa,8CAA8C,6GAA6G,iIAAiI,MAAM,mBAAmB,SAAS,uBAAuB,QAAQ,4DAA4D,yEAAyE,8DAA8D,wGAAwG,mBAAmB,MAAM,WAAW,8CAA8C,kFAAkF,OAAO,oBAAoB,OAAO,+DAA+D,2BAA2B,aAAa,MAAM,sEAAsE,OAAO,oBAAoB,OAAO,iEAAiE,2BAA2B,+BAA+B,uCAAuC,gCAAgC,gCAAgC,2CAA2C,mBAAmB,OAAO,IAAI,EAAE,MAAM,gEAAgE,OAAO,oBAAoB,OAAO,qEAAqE,0DAA0D,kCAAkC,KAAK,wCAAwC,0DAA0D,uBAAuB,mBAAmB,OAAO,IAAI,EAAE,MAAM,kFAAkF,OAAO,uBAAuB,OAAO,mGAAmG,oCAAoC,sCAAsC,yCAAyC,4BAA4B,8BAA8B,gCAAgC,OAAO,oBAAoB,MAAM,WAAW,oGAAoG,2CAA2C,kDAAkD,wCAAwC,iDAAiD,iDAAiD,iCAAiC,6BAA6B,KAAK,yDAAyD,MAAM,mFAAmF,OAAO,qDAAqD,OAAO,yCAAyC,OAAO,0KAA0K,OAAO,uBAAuB,OAAO,gDAAgD,OAAO,8CAA8C,OAAO,wFAAwF,OAAO,iIAAiI,eAAe,kBAAkB,uDAAuD,kEAAkE,cAAc,eAAe,mBAAmB,gDAAgD,4DAA4D,UAAU,uBAAuB,2DAA2D,mBAAmB,sDAAsD,sBAAsB,yDAAyD,SAAS,QAAQ,wBAAwB,yDAAyD,EAAE,6EAA6E,kFAAkF,6DAA6D,0FAA0F,iEAAiE,yBAAyB,sCAAsC,OAAO,4EAA4E,MAAM,iEAAiE,MAAM,6MAA6M,OAAO,uBAAuB,OAAO,sIAAsI,OAAO,oFAAoF,uBAAuB,kBAAkB,gEAAgE,0EAA0E,cAAc,eAAe,gDAAgD,4DAA4D,UAAU,uBAAuB,2DAA2D,mBAAmB,sDAAsD,SAAS,QAAQ,wBAAwB,yDAAyD,EAAE,sFAAsF,2GAA2G,iEAAiE,4EAA4E,MAAM,sCAAsC,aAAa,mEAAmE,2CAA2C,kDAAkD,wCAAwC,oCAAoC,iDAAiD,+DAA+D,iCAAiC,6BAA6B,KAAK,iFAAiF,iBAAiB,kBAAkB,0EAA0E,4DAA4D,UAAU,uBAAuB,2DAA2D,8BAA8B,iEAAiE,yBAAyB,iJAAiJ,8BAA8B,aAAa,WAAW,mBAAmB,2IAA2I,oCAAoC,aAAa,WAAW,SAAS,QAAQ,iWAAiW,iFAAiF,6DAA6D,OAAO,qEAAqE,yCAAyC,qGAAqG,MAAM,4EAA4E,cAAc,eAAe,0EAA0E,4DAA4D,UAAU,uBAAuB,2DAA2D,kBAAkB,uLAAuL,yBAAyB,gJAAgJ,mDAAmD,aAAa,WAAW,mBAAmB,0IAA0I,yDAAyD,aAAa,WAAW,wBAAwB,2EAA2E,SAAS,QAAQ,qDAAqD,yDAAyD,EAAE,2EAA2E,0IAA0I,2BAA2B,gDAAgD,2CAA2C,OAAO,iCAAiC,gDAAgD,wDAAwD,OAAO,kCAAkC,gDAAgD,0DAA0D,OAAO,kCAAkC,+BAA+B,wBAAwB,+EAA+E,4EAA4E,MAAM,6EAA6E,cAAc,sBAAsB,0EAA0E,4DAA4D,UAAU,uBAAuB,2DAA2D,8BAA8B,iEAAiE,yBAAyB,iJAAiJ,8BAA8B,aAAa,WAAW,mBAAmB,2IAA2I,oCAAoC,aAAa,WAAW,SAAS,QAAQ,qDAAqD,yDAAyD,EAAE,wKAAwK,2EAA2E,4EAA4E,mFAAmF,MAAM,oDAAoD,aAAa,mEAAmE,iDAAiD,4CAA4C,4CAA4C,eAAe,kBAAkB,qIAAqI,wDAAwD,OAAO,qBAAqB,sDAAsD,0BAA0B,oDAAoD,oBAAoB,gCAAgC,OAAO,OAAO,qBAAqB,OAAO,kGAAkG,SAAS,KAAK,6BAA6B,YAAY,iBAAiB,kBAAkB,8BAA8B,qIAAqI,wDAAwD,OAAO,+DAA+D,GAAG,qBAAqB,oBAAoB,OAAO,4BAA4B,0CAA0C,sDAAsD,SAAS,2CAA2C,kFAAkF,SAAS,OAAO,sBAAsB,KAAK,8BAA8B,2BAA2B,KAAK,0BAA0B,8DAA8D,aAAa,mEAAmE,gDAAgD,yCAAyC,6BAA6B,uCAAuC,kDAAkD,6DAA6D,sEAAsE,yBAAyB,gCAAgC,kCAAkC,gDAAgD,qCAAqC,6GAA6G,6BAA6B,sBAAsB,SAAS,QAAQ,oDAAoD,+DAA+D,OAAO,KAAK,mDAAmD,uBAAuB,6CAA6C,iEAAiE,yCAAyC,iCAAiC,kHAAkH,+BAA+B,QAAQ,2CAA2C,kEAAkE,gBAAgB,mEAAmE,gBAAgB,wGAAwG,OAAO,0GAA0G,yDAAyD,sDAAsD,+BAA+B,OAAO,gBAAgB,MAAM,iEAAiE,uBAAuB,sDAAsD,wDAAwD,eAAe,OAAO,yBAAyB,+BAA+B,MAAM,6DAA6D,qBAAqB,iCAAiC,+BAA+B,OAAO,MAAM,sDAAsD,uBAAuB,6CAA6C,2CAA2C,wDAAwD,kJAAkJ,wDAAwD,OAAO,KAAK,MAAM,uCAAuC,aAAa,8CAA8C,8DAA8D,2BAA2B,oCAAoC,OAAO,+BAA+B,KAAK,+CAA+C,mBAAmB,oDAAoD,uEAAuE,OAAO,kCAAkC,qBAAqB,sBAAsB,OAAO,sCAAsC,8DAA8D,mBAAmB,SAAS,4DAA4D,uDAAuD,iBAAiB,eAAe,6CAA6C,0EAA0E,sDAAsD,8CAA8C,WAAW,SAAS,OAAO,gBAAgB,KAAK,0BAA0B,qEAAqE,aAAa,mEAAmE,gDAAgD,8VAA8V,0oBAA0oB,qDAAqD,0EAA0E,sCAAsC,kKAAkK,OAAO,wBAAwB,KAAK,iDAAiD,oDAAoD,KAAK,0BAA0B,+FAA+F,aAAa,mEAAmE,2CAA2C,kDAAkD,6BAA6B,yBAAyB,yBAAyB,OAAO,sDAAsD,8BAA8B,oFAAoF,0DAA0D,WAAW,wRAAwR,SAAS,gDAAgD,OAAO,KAAK,oEAAoE,qBAAqB,yBAAyB,OAAO,2DAA2D,wCAAwC,SAAS,OAAO,sBAAsB,MAAM,uCAAuC,aAAa,mEAAmE,8HAA8H,mDAAmD,8CAA8C,oCAAoC,iCAAiC,iCAAiC,KAAK,sEAAsE,uCAAuC,yCAAyC,8CAA8C,sGAAsG,iGAAiG,4IAA4I,gJAAgJ,8CAA8C,2CAA2C,kBAAkB,0EAA0E,MAAM,4DAA4D,uBAAuB,8CAA8C,2EAA2E,EAAE,sFAAsF,6CAA6C,uDAAuD,mDAAmD,EAAE,mEAAmE,mCAAmC,OAAO,wFAAwF,iDAAiD,qBAAqB,oCAAoC,QAAQ,qCAAqC,MAAM,4EAA4E,uBAAuB,2EAA2E,EAAE,sFAAsF,2DAA2D,wGAAwG,+DAA+D,+CAA+C,wBAAwB,wEAAwE,oCAAoC,6BAA6B,OAAO,EAAE,wBAAwB,uBAAuB,MAAM,sCAAsC,aAAa,mEAAmE,gDAAgD,uCAAuC,0EAA0E,sBAAsB,wFAAwF,+FAA+F,uBAAuB,oBAAoB,OAAO,wDAAwD,yBAAyB,mBAAmB,OAAO,yDAAyD,OAAO,iCAAiC,KAAK,0BAA0B,sCAAsC,aAAa,mEAAmE,mDAAmD,gBAAgB,oCAAoC,8BAA8B,uCAAuC,OAAO,qBAAqB,KAAK,0BAA0B,8BAA8B,8CAA8C,iDAAiD,OAAO,kCAAkC,4CAA4C,OAAO,sCAAsC,yCAAyC,+CAA+C,OAAO,2BAA2B,yBAAyB,OAAO,MAAM,aAAa,mEAAmE,4CAA4C,mCAAmC,yDAAyD,+BAA+B,MAAM,4DAA4D,yBAAyB,MAAM,gEAAgE,oCAAoC,MAAM,uCAAuC,aAAa,8CAA8C,gCAAgC,qDAAqD,kBAAkB,MAAM,0DAA0D,uDAAuD,sCAAsC,aAAa,mEAAmE,iDAAiD,+CAA+C,gDAAgD,uCAAuC,mCAAmC,6BAA6B,EAAE,mFAAmF,KAAK,wDAAwD,iDAAiD,2DAA2D,eAAe,OAAO,kDAAkD,sEAAsE,0CAA0C,OAAO,OAAO,sEAAsE,2CAA2C,OAAO,MAAM,0DAA0D,WAAW,yCAAyC,OAAO,YAAY,6BAA6B,wBAAwB,iCAAiC,OAAO,MAAM,6DAA6D,WAAW,4CAA4C,OAAO,YAAY,6BAA6B,wBAAwB,oCAAoC,OAAO,MAAM,iEAAiE,WAAW,gDAAgD,OAAO,YAAY,6BAA6B,wBAAwB,wCAAwC,OAAO,MAAM,wCAAwC,aAAa,8CAA8C,wOAAwO,kEAAkE,2DAA2D,yBAAyB,iBAAiB,KAAK,0BAA0B,wCAAwC,aAAa,mEAAmE,mDAAmD,6CAA6C,0CAA0C,yCAAyC,0BAA0B,yHAAyH,aAAa,mEAAmE,2CAA2C,qDAAqD,wCAAwC,iDAAiD,oIAAoI,OAAO,uBAAuB,OAAO,uDAAuD,OAAO,yEAAyE,sEAAsE,4DAA4D,UAAU,mBAAmB,uDAAuD,mBAAmB,sDAAsD,4BAA4B,2HAA2H,4BAA4B,0HAA0H,SAAS,QAAQ,8DAA8D,sCAAsC,qDAAqD,8DAA8D,4FAA4F,KAAK,uDAAuD,MAAM,6EAA6E,OAAO,kHAAkH,OAAO,yDAAyD,aAAa,+IAA+I,cAAc,gCAAgC,2DAA2D,EAAE,wBAAwB,yDAAyD,EAAE,mEAAmE,gEAAgE,qBAAqB,GAAG,MAAM,+JAA+J,OAAO,sBAAsB,OAAO,4BAA4B,aAAa,kBAAkB,yEAAyE,wFAAwF,cAAc,gCAAgC,2DAA2D,EAAE,kCAAkC,iEAAiE,EAAE,wBAAwB,yDAAyD,EAAE,mEAAmE,+DAA+D,8BAA8B,mCAAmC,qBAAqB,GAAG,MAAM,4EAA4E,OAAO,sBAAsB,OAAO,kCAAkC,aAAa,kBAAkB,uEAAuE,qFAAqF,cAAc,sDAAsD,2DAA2D,EAAE,wCAAwC,0FAA0F,EAAE,wBAAwB,yDAAyD,EAAE,0GAA0G,8DAA8D,gCAAgC,mCAAmC,qBAAqB,GAAG,MAAM,oCAAoC,aAAa,mEAAmE,2CAA2C,kDAAkD,8CAA8C,iDAAiD,8DAA8D,6BAA6B,iCAAiC,iDAAiD,KAAK,oCAAoC,+CAA+C,6DAA6D,gDAAgD,+BAA+B,8CAA8C,OAAO,KAAK,0CAA0C,6FAA6F,KAAK,gXAAgX,gBAAgB,qGAAqG,OAAO,8BAA8B,gBAAgB,uDAAuD,OAAO,2EAA2E,OAAO,yEAAyE,OAAO,yCAAyC,OAAO,yHAAyH,yBAAyB,kQAAkQ,uBAAuB,+CAA+C,sEAAsE,8BAA8B,4HAA4H,6BAA6B,qDAAqD,OAAO,wBAAwB,2CAA2C,OAAO,0DAA0D,sBAAsB,wKAAwK,uCAAuC,0DAA0D,OAAO,OAAO,sDAAsD,OAAO,+FAA+F,kBAAkB,oEAAoE,iGAAiG,iCAAiC,SAAS,qGAAqG,qFAAqF,sCAAsC,EAAE,wEAAwE,8DAA8D,kDAAkD,OAAO,EAAE,MAAM,iDAAiD,WAAW,qDAAqD,iDAAiD,wBAAwB,OAAO,YAAY,kBAAkB,OAAO,KAAK,wQAAwQ,mEAAmE,+CAA+C,+DAA+D,sDAAsD,iBAAiB,SAAS,6DAA6D,sDAAsD,8CAA8C,gEAAgE,6CAA6C,WAAW,+BAA+B,OAAO,EAAE,wCAAwC,gBAAgB,gBAAgB,MAAM,mDAAmD,aAAa,mEAAmE,oDAAoD,4CAA4C,wCAAwC,oCAAoC,gDAAgD,8CAA8C,8CAA8C,qDAAqD,iDAAiD,2CAA2C,wCAAwC,8DAA8D,4DAA4D,2FAA2F,OAAO,uBAAuB,OAAO,gDAAgD,OAAO,sHAAsH,OAAO,iHAAiH,OAAO,oJAAoJ,oEAAoE,eAAe,OAAO,uJAAuJ,uFAAuF,eAAe,OAAO,uFAAuF,OAAO,wHAAwH,MAAM,iCAAiC,OAAO,gGAAgG,gFAAgF,aAAa,gDAAgD,sCAAsC,sEAAsE,4DAA4D,UAAU,mBAAmB,uDAAuD,sBAAsB,yDAAyD,0BAA0B,uEAAuE,0BAA0B,uEAAuE,yBAAyB,sEAAsE,mBAAmB,gEAAgE,sBAAsB,mEAAmE,oBAAoB,iEAAiE,qBAAqB,iEAAiE,yCAAyC,wIAAwI,4BAA4B,2HAA2H,4BAA4B,0HAA0H,yCAAyC,uIAAuI,SAAS,QAAQ,kCAAkC,4DAA4D,2DAA2D,YAAY,uBAAuB,yDAAyD,8BAA8B,+DAA+D,WAAW,UAAU,OAAO,8DAA8D,yFAAyF,6IAA6I,kKAAkK,+JAA+J,gLAAgL,yFAAyF,6DAA6D,kEAAkE,qDAAqD,6FAA6F,KAAK,kGAAkG,gBAAgB,qSAAqS,OAAO,uBAAuB,OAAO,oGAAoG,OAAO,gEAAgE,gBAAgB,gCAAgC,OAAO,gEAAgE,gBAAgB,yCAAyC,OAAO,qMAAqM,kBAAkB,mEAAmE,mBAAmB,cAAc,gBAAgB,sBAAsB,2BAA2B,qDAAqD,qBAAqB,qBAAqB,OAAO,OAAO,gCAAgC,OAAO,mFAAmF,iDAAiD,0FAA0F,+CAA+C,uCAAuC,iDAAiD,8EAA8E,iCAAiC,qCAAqC,SAAS,2BAA2B,OAAO,0KAA0K,8BAA8B,OAAO,kDAAkD,4EAA4E,qFAAqF,iFAAiF,8DAA8D,sIAAsI,gCAAgC,uCAAuC,WAAW,wFAAwF,SAAS,EAAE,OAAO,kCAAkC,4CAA4C,mOAAmO,EAAE,kEAAkE,4FAA4F,OAAO,OAAO,4EAA4E,OAAO,MAAM,qEAAqE,cAAc,kbAAkb,KAAK,gEAAgE,MAAM,kEAAkE,OAAO,4KAA4K,OAAO,qBAAqB,OAAO,qBAAqB,sBAAsB,4EAA4E,0CAA0C,yNAAyN,EAAE,gEAAgE,kBAAkB,mDAAmD,SAAS,8BAA8B,OAAO,EAAE,MAAM,kMAAkM,gBAAgB,qUAAqU,OAAO,uBAAuB,OAAO,kDAAkD,OAAO,wHAAwH,OAAO,iHAAiH,OAAO,oJAAoJ,oEAAoE,eAAe,OAAO,uJAAuJ,uFAAuF,eAAe,OAAO,uDAAuD,0DAA0D,eAAe,OAAO,mFAAmF,sDAAsD,eAAe,OAAO,uFAAuF,OAAO,wHAAwH,OAAO,2RAA2R,iEAAiE,gEAAgE,kBAAkB,oDAAoD,qEAAqE,uBAAuB,8RAA8R,+DAA+D,8DAA8D,2BAA2B,yDAAyD,OAAO,gCAAgC,4DAA4D,EAAE,wBAAwB,yDAAyD,EAAE,iCAAiC,uGAAuG,wDAAwD,wHAAwH,EAAE,6DAA6D,uCAAuC,4LAA4L,SAAS,sFAAsF,2FAA2F,2FAA2F,yBAAyB,+DAA+D,MAAM,OAAO,EAAE,MAAM,iIAAiI,OAAO,uBAAuB,OAAO,sIAAsI,OAAO,oFAAoF,uBAAuB,kBAAkB,gEAAgE,qEAAqE,kEAAkE,MAAM,wHAAwH,OAAO,uBAAuB,OAAO,8HAA8H,OAAO,8HAA8H,OAAO,iIAAiI,OAAO,sEAAsE,OAAO,iFAAiF,SAAS,kBAAkB,6DAA6D,wEAAwE,6SAA6S,2EAA2E,yDAAyD,MAAM,6GAA6G,OAAO,uBAAuB,OAAO,gDAAgD,OAAO,8CAA8C,OAAO,wFAAwF,eAAe,kBAAkB,uDAAuD,6DAA6D,0DAA0D,MAAM,+JAA+J,gBAAgB,sFAAsF,OAAO,uBAAuB,OAAO,kDAAkD,OAAO,wHAAwH,OAAO,+GAA+G,OAAO,kJAAkJ,oEAAoE,eAAe,OAAO,uJAAuJ,uFAAuF,eAAe,OAAO,uDAAuD,0DAA0D,eAAe,OAAO,mFAAmF,sDAAsD,eAAe,OAAO,uFAAuF,OAAO,sHAAsH,iEAAiE,4DAA4D,mTAAmT,+CAA+C,4DAA4D,UAAU,yBAAyB,6DAA6D,SAAS,QAAQ,2DAA2D,uEAAuE,MAAM,wPAAwP,OAAO,uBAAuB,OAAO,gDAAgD,OAAO,8CAA8C,OAAO,wFAAwF,cAAc,kBAAkB,uDAAuD,eAAe,qDAAqD,yEAAyE,uBAAuB,kIAAkI,oBAAoB,2BAA2B,WAAW,6CAA6C,kCAAkC,6CAA6C,WAAW,0CAA0C,SAAS,QAAQ,MAAM,mEAAmE,MAAM,2cAA2c,gBAAgB,qGAAqG,OAAO,8BAA8B,gBAAgB,uDAAuD,OAAO,2EAA2E,OAAO,wEAAwE,OAAO,yCAAyC,OAAO,yHAAyH,yBAAyB,gPAAgP,wDAAwD,MAAM,+UAA+U,gBAAgB,qGAAqG,OAAO,8BAA8B,gBAAgB,uDAAuD,OAAO,kFAAkF,OAAO,wEAAwE,OAAO,gEAAgE,OAAO,qGAAqG,yBAAyB,4PAA4P,sDAAsD,4NAA4N,4GAA4G,6DAA6D,MAAM,wSAAwS,gDAAgD,MAAM,oqBAAoqB,OAAO,uBAAuB,OAAO,4DAA4D,OAAO,wEAAwE,QAAQ,+FAA+F,uDAAuD,yDAAyD,iEAAiE,MAAM,2JAA2J,OAAO,uBAAuB,OAAO,6CAA6C,OAAO,sDAAsD,OAAO,kDAAkD,OAAO,sDAAsD,OAAO,sDAAsD,SAAS,4EAA4E,uBAAuB,mTAAmT,+CAA+C,4DAA4D,UAAU,yBAAyB,6DAA6D,SAAS,QAAQ,2DAA2D,oEAAoE,kBAAkB,yBAAyB,SAAS,uFAAuF,OAAO,EAAE,MAAM,iCAAiC,aAAa,mEAAmE,2CAA2C,0CAA0C,gDAAgD,wCAAwC,iDAAiD,+CAA+C,8CAA8C,uCAAuC,qDAAqD,0CAA0C,iCAAiC,mCAAmC,6BAA6B,yFAAyF,4BAA4B,qEAAqE,EAAE,KAAK,6KAA6K,gFAAgF,8BAA8B,+CAA+C,OAAO,oCAAoC,MAAM,mLAAmL,OAAO,4JAA4J,8BAA8B,+CAA+C,iCAAiC,mBAAmB,MAAM,2JAA2J,iCAAiC,oCAAoC,OAAO,wBAAwB,qCAAqC,OAAO,0CAA0C,MAAM,4GAA4G,OAAO,uBAAuB,OAAO,oGAAoG,OAAO,gEAAgE,gBAAgB,gCAAgC,OAAO,gEAAgE,gBAAgB,yCAAyC,OAAO,qMAAqM,gBAAgB,yDAAyD,uBAAuB,mDAAmD,6CAA6C,uBAAuB,iCAAiC,SAAS,EAAE,OAAO,EAAE,MAAM,sNAAsN,OAAO,uBAAuB,OAAO,kDAAkD,OAAO,wHAAwH,OAAO,+GAA+G,OAAO,kJAAkJ,oEAAoE,eAAe,OAAO,uJAAuJ,uFAAuF,eAAe,OAAO,uDAAuD,0DAA0D,eAAe,OAAO,mFAAmF,sDAAsD,eAAe,OAAO,uFAAuF,OAAO,wHAAwH,QAAQ,6IAA6I,kBAAkB,gBAAgB,iEAAiE,8DAA8D,gBAAgB,cAAc,mBAAmB,uBAAuB,8EAA8E,2VAA2V,+CAA+C,4DAA4D,UAAU,yBAAyB,6DAA6D,SAAS,QAAQ,kOAAkO,oFAAoF,8IAA8I,OAAO,OAAO,qEAAqE,sCAAsC,OAAO,qCAAqC,4FAA4F,OAAO,8BAA8B,qDAAqD,OAAO,2DAA2D,+BAA+B,sDAAsD,gDAAgD,yEAAyE,MAAM,yPAAyP,gBAAgB,KAAK,YAAY,yDAAyD,OAAO,uBAAuB,OAAO,iHAAiH,OAAO,gHAAgH,OAAO,uJAAuJ,OAAO,wFAAwF,oBAAoB,4EAA4E,iBAAiB,gBAAgB,cAAc,mBAAmB,0EAA0E,4DAA4D,UAAU,qBAAqB,yEAAyE,yBAAyB,4EAA4E,0BAA0B,6EAA6E,mBAAmB,sEAAsE,sBAAsB,yEAAyE,SAAS,QAAQ,yEAAyE,uSAAuS,sEAAsE,2JAA2J,kEAAkE,8FAA8F,iEAAiE,4CAA4C,iBAAiB,uBAAuB,MAAM,2JAA2J,OAAO,uBAAuB,OAAO,6CAA6C,OAAO,sDAAsD,OAAO,kDAAkD,OAAO,sDAAsD,OAAO,sDAAsD,SAAS,0EAA0E,uBAAuB,8HAA8H,oBAAoB,2BAA2B,WAAW,sEAAsE,sDAAsD,mCAAmC,qCAAqC,0CAA0C,8BAA8B,+DAA+D,SAAS,QAAQ,MAAM,0NAA0N,gBAAgB,KAAK,yBAAyB,mDAAmD,OAAO,uBAAuB,OAAO,gDAAgD,OAAO,8CAA8C,OAAO,wFAAwF,oBAAoB,sEAAsE,uBAAuB,sJAAsJ,0CAA0C,kIAAkI,oBAAoB,8CAA8C,iDAAiD,aAAa,2BAA2B,WAAW,kDAAkD,SAAS,QAAQ,MAAM,+BAA+B,aAAa,mEAAmE,qDAAqD,8CAA8C,uCAAuC,wCAAwC,4CAA4C,iCAAiC,2BAA2B,gCAAgC,qEAAqE,EAAE,KAAK,8DAA8D,MAAM,iFAAiF,OAAO,oDAAoD,OAAO,iDAAiD,eAAe,eAAe,OAAO,+DAA+D,OAAO,sZAAsZ,gBAAgB,KAAK,YAAY,yDAAyD,OAAO,uBAAuB,OAAO,iHAAiH,OAAO,gHAAgH,OAAO,uJAAuJ,OAAO,wFAAwF,oBAAoB,+EAA+E,2BAA2B,0UAA0U,+CAA+C,4DAA4D,UAAU,yBAAyB,6DAA6D,SAAS,QAAQ,oEAAoE,iEAAiE,kBAAkB,yBAAyB,SAAS,+CAA+C,OAAO,EAAE,MAAM,4IAA4I,OAAO,uBAAuB,OAAO,gDAAgD,OAAO,8CAA8C,OAAO,wFAAwF,oBAAoB,yEAAyE,uBAAuB,qEAAqE,kBAAkB,yBAAyB,SAAS,uDAAuD,OAAO,EAAE,MAAM,kCAAkC,aAAa,mEAAmE,kDAAkD,uDAAuD,yDAAyD,kDAAkD,0BAA0B,sEAAsE,KAAK,gEAAgE,sDAAsD,MAAM,0FAA0F,wCAAwC,qTAAqT,kGAAkG,SAAS,uDAAuD,EAAE,8BAA8B,MAAM,8EAA8E,uBAAuB,cAAc,sCAAsC,yCAAyC,iJAAiJ,4BAA4B,eAAe,8IAA8I,qGAAqG,WAAW,SAAS,QAAQ,MAAM,uGAAuG,kCAAkC,0BAA0B,8BAA8B,6EAA6E,SAAS,kFAAkF,oDAAoD,SAAS,OAAO,+CAA+C,SAAS,sCAAsC,QAAQ,MAAM,qDAAqD,aAAa,mEAAmE,2CAA2C,kDAAkD,iDAAiD,iDAAiD,8CAA8C,4CAA4C,iCAAiC,iDAAiD,KAAK,kEAAkE,cAAc,eAAe,+EAA+E,+DAA+D,sFAAsF,+QAA+Q,iEAAiE,4EAA4E,MAAM,kEAAkE,cAAc,eAAe,iDAAiD,+CAA+C,+BAA+B,yDAAyD,wBAAwB,MAAM,0CAA0C,aAAa,gBAAgB,EAAE,GAAG,C;;;;;;;ACAnxkS,sOAAsO,+DAA+D,mBAAmB,kDAAkD,aAAa,KAAK,MAAM,kCAAkC,SAAS,uCAAuC,SAAS,qCAAqC,OAAO,KAAK,OAAO,eAAe,aAAa,0BAA0B,0BAA0B,gBAAgB,UAAU,UAAU,4CAA4C,wBAAwB,oBAAoB,kDAAkD,oCAAoC,YAAY,YAAY,mCAAmC,iBAAiB,gBAAgB,sBAAsB,oBAAoB,4CAA4C,YAAY,WAAW,YAAY,SAAS,GAAG,oCAAoC,KAAK,GAAG,sCAAsC,mDAAmD,0BAA0B,kaAAka,kCAAkC,qBAAqB,iBAAiB,QAAQ,mCAAmC,EAAE,sCAAsC,EAAE,+SAA+S,sFAAsF,mBAAmB,2BAA2B,yBAAyB,gBAAgB,OAAO,wDAAwD,WAAW,QAAQ,4CAA4C,2BAA2B,yBAAyB,gBAAgB,OAAO,kEAAkE,WAAW,QAAQ,6CAA6C,yBAAyB,gBAAgB,OAAO,6CAA6C,WAAW,mCAAmC,QAAQ,4CAA4C,yBAAyB,gBAAgB,OAAO,kEAAkE,WAAW,mCAAmC,QAAQ,gDAAgD,4CAA4C,iCAAiC,WAAW,qCAAqC,qBAAqB,oBAAoB,WAAW,QAAQ,0BAA0B,gBAAgB,OAAO,yCAAyC,QAAQ,0BAA0B,gBAAgB,QAAQ,aAAa,6BAA6B,QAAQ,kBAAkB,kBAAkB,KAAK,kCAAkC,qBAAqB,iBAAiB,QAAQ,6IAA6I,qCAAqC,mBAAmB,2CAA2C,wNAAwN,8BAA8B,QAAQ,KAAK,iCAAiC,qBAAqB,iBAAiB,QAAQ,2IAA2I,qCAAqC,mBAAmB,yCAAyC,wNAAwN,8BAA8B,QAAQ,KAAK,iCAAiC,kCAAkC,uCAAuC,KAAK,iCAAiC,iCAAiC,sCAAsC,KAAK,mCAAmC,kCAAkC,kBAAkB,yBAAyB,QAAQ,yCAAyC,yBAAyB,QAAQ,wCAAwC,yBAAyB,QAAQ,KAAK,kDAAkD,iGAAiG,KAAK,yCAAyC,mDAAmD,yCAAyC,QAAQ,+EAA+E,KAAK,0CAA0C,iCAAiC,wDAAwD,QAAQ,+GAA+G,KAAK,6CAA6C,mDAAmD,6CAA6C,QAAQ,uIAAuI,oEAAoE,KAAK,8CAA8C,uIAAuI,oGAAoG,KAAK,yCAAyC,mDAAmD,yCAAyC,QAAQ,iFAAiF,KAAK,0CAA0C,iCAAiC,wDAAwD,QAAQ,iHAAiH,KAAK,uLAAuL,iCAAiC,sDAAsD,QAAQ,kKAAkK,KAAK,+BAA+B,2CAA2C,KAAK,qDAAqD,gDAAgD,KAAK,iCAAiC,+CAA+C,kDAAkD,KAAK,4EAA4E,kCAAkC,6CAA6C,KAAK,OAAO,EAAE,QAAQ,sCAAsC,gDAAgD,4BAA4B,oCAAoC,iCAAiC,mBAAmB,OAAO,qCAAqC,8BAA8B,OAAO,yBAAyB,+IAA+I,kDAAkD,oCAAoC,mCAAmC,mBAAmB,sCAAsC,SAAS,uCAAuC,sCAAsC,SAAS,sCAAsC,sCAAsC,SAAS,OAAO,+EAA+E,SAAS,OAAO,oCAAoC,mBAAmB,6DAA6D,sCAAsC,SAAS,iEAAiE,sCAAsC,SAAS,6DAA6D,sCAAsC,SAAS,iEAAiE,sCAAsC,SAAS,4DAA4D,uCAAuC,SAAS,OAAO,sFAAsF,SAAS,OAAO,MAAM,2BAA2B,wBAAwB,+CAA+C,OAAO,yBAAyB,+CAA+C,OAAO,yBAAyB,+CAA+C,OAAO,yBAAyB,+CAA+C,OAAO,0BAA0B,gDAAgD,OAAO,kCAAkC,+BAA+B,OAAO,8BAA8B,+BAA+B,OAAO,8BAA8B,+BAA+B,OAAO,8BAA8B,iCAAiC,iCAAiC,mDAAmD,SAAS,0BAA0B,OAAO,+BAA+B,gCAAgC,OAAO,+BAA+B,iCAAiC,iDAAiD,OAAO,+BAA+B,iCAAiC,iDAAiD,OAAO,8BAA8B,gCAAgC,mCAAmC,SAAS,qCAAqC,oBAAoB,OAAO,gCAAgC,8CAA8C,OAAO,8BAA8B,8CAA8C,OAAO,6BAA6B,8CAA8C,OAAO,4BAA4B,kBAAkB,qBAAqB,0CAA0C,SAAS,8CAA8C,OAAO,mCAAmC,8CAA8C,OAAO,kCAAkC,8CAA8C,OAAO,oCAAoC,8CAA8C,OAAO,kCAAkC,8CAA8C,OAAO,kCAAkC,8CAA8C,OAAO,8BAA8B,8CAA8C,OAAO,6BAA6B,+CAA+C,OAAO,gCAAgC,+CAA+C,OAAO,+BAA+B,+CAA+C,OAAO,8BAA8B,+CAA+C,OAAO,mCAAmC,iDAAiD,OAAO,+BAA+B,oEAAoE,OAAO,gCAAgC,qEAAqE,OAAO,mCAAmC,wEAAwE,OAAO,+BAA+B,oEAAoE,OAAO,gCAAgC,qEAAqE,OAAO,+BAA+B,oEAAoE,OAAO,6BAA6B,kEAAkE,OAAO,mCAAmC,kCAAkC,uDAAuD,OAAO,oCAAoC,8FAA8F,qBAAqB,uBAAuB,gBAAgB,OAAO,kCAAkC,8FAA8F,SAAS,mEAAmE,OAAO,wCAAwC,8FAA8F,uCAAuC,0BAA0B,+CAA+C,SAAS,6CAA6C,OAAO,qCAAqC,kDAAkD,mCAAmC,uBAAuB,SAAS,sDAAsD,OAAO,8BAA8B,gHAAgH,sEAAsE,yBAAyB,OAAO,+BAA+B,4BAA4B,OAAO,gCAAgC,qBAAqB,uBAAuB,OAAO,OAAO,4CAA4C,SAAS,mCAAmC,oBAAoB,OAAO,sCAAsC,kCAAkC,iCAAiC,mCAAmC,oBAAoB,OAAO,qCAAqC,kCAAkC,iCAAiC,mCAAmC,oBAAoB,OAAO,uCAAuC,kCAAkC,iCAAiC,mCAAmC,oBAAoB,OAAO,yCAAyC,kCAAkC,iCAAiC,mCAAmC,oBAAoB,OAAO,qCAAqC,kCAAkC,iCAAiC,mCAAmC,oBAAoB,OAAO,sCAAsC,kCAAkC,iCAAiC,mCAAmC,oBAAoB,OAAO,mCAAmC,kCAAkC,8IAA8I,+CAA+C,oBAAoB,OAAO,sCAAsC,sCAAsC,yDAAyD,oBAAoB,OAAO,sCAAsC,sCAAsC,yDAAyD,oBAAoB,OAAO,uCAAuC,kCAAkC,2CAA2C,2CAA2C,mCAAmC,oBAAoB,OAAO,uNAAuN,0BAA0B,gCAAgC,oDAAoD,8BAA8B,gDAAgD,8EAA8E,wBAAwB,4QAA4Q,OAAO,gCAAgC,0BAA0B,OAAO,+BAA+B,2VAA2V,iCAAiC,mCAAmC,wBAAwB,sCAAsC,4CAA4C,iCAAiC,sBAAsB,uBAAuB,4CAA4C,4CAA4C,aAAa,uCAAuC,mCAAmC,aAAa,OAAO,8DAA8D,aAAa,WAAW,SAAS,0BAA0B,OAAO,MAAM,kCAAkC,iOAAiO,iCAAiC,kJAAkJ,sDAAsD,+BAA+B,oBAAoB,yBAAyB,kBAAkB,OAAO,iDAAiD,OAAO,mCAAmC,8BAA8B,OAAO,cAAc,+BAA+B,kBAAkB,MAAM,4DAA4D,+BAA+B,+BAA+B,6BAA6B,oBAAoB,YAAY,kCAAkC,qBAAqB,OAAO,wBAAwB,2EAA2E,mCAAmC,OAAO,gDAAgD,YAAY,oBAAoB,mBAAmB,kBAAkB,OAAO,mDAAmD,SAAS,2BAA2B,OAAO,iDAAiD,YAAY,6BAA6B,kCAAkC,uBAAuB,kBAAkB,OAAO,4CAA4C,SAAS,+BAA+B,OAAO,gGAAgG,kCAAkC,qBAAqB,OAAO,qBAAqB,iFAAiF,kBAAkB,OAAO,0EAA0E,8CAA8C,OAAO,mFAAmF,8BAA8B,+DAA+D,SAAS,OAAO,sBAAsB,MAAM,2DAA2D,yBAAyB,mCAAmC,2DAA2D,OAAO,uEAAuE,gDAAgD,OAAO,sCAAsC,kBAAkB,MAAM,mEAAmE,uCAAuC,8BAA8B,oDAAoD,OAAO,mCAAmC,qDAAqD,OAAO,sDAAsD,qCAAqC,sBAAsB,MAAM,4CAA4C,2BAA2B,KAAK,+BAA+B,OAAO,EAAE,gBAAgB,sCAAsC,yCAAyC,kiCAAkiC,6BAA6B,+KAA+K,iCAAiC,gDAAgD,oDAAoD,mDAAmD,gCAAgC,+BAA+B,0BAA0B,iCAAiC,oDAAoD,0CAA0C,mCAAmC,GAAG,2BAA2B,mKAAmK,+BAA+B,wCAAwC,iCAAiC,gDAAgD,oDAAoD,oDAAoD,gCAAgC,+BAA+B,oCAAoC,uBAAuB,GAAG,2BAA2B,yLAAyL,mCAAmC,GAAG,4BAA4B,8FAA8F,wCAAwC,mCAAmC,mCAAmC,mCAAmC,gDAAgD,GAAG,+BAA+B,gDAAgD,GAAG,2BAA2B,2EAA2E,6FAA6F,yEAAyE,yEAAyE,yDAAyD,uDAAuD,uDAAuD,wCAAwC,GAAG,2BAA2B,4GAA4G,kBAAkB,aAAa,iBAAiB,qEAAqE,mEAAmE,mEAAmE,yBAAyB,sBAAsB,sBAAsB,uBAAuB,GAAG,4BAA4B,kCAAkC,GAAG,2BAA2B,wGAAwG,mBAAmB,oBAAoB,6BAA6B,KAAK,yCAAyC,iCAAiC,oBAAoB,sBAAsB,mBAAmB,OAAO,OAAO,iCAAiC,qBAAqB,qBAAqB,6DAA6D,2CAA2C,0EAA0E,2BAA2B,2BAA2B,KAAK,iBAAiB,GAAG,2BAA2B,mFAAmF,mBAAmB,uGAAuG,KAAK,aAAa,8BAA8B,oBAAoB,2BAA2B,kCAAkC,GAAG,4BAA4B,kCAAkC,GAAG,6BAA6B,mCAAmC,GAAG,gCAAgC,sCAAsC,GAAG,6BAA6B,yGAAyG,gKAAgK,kBAAkB,sCAAsC,sCAAsC,sCAAsC,sCAAsC,sCAAsC,sCAAsC,KAAK,GAAG,2BAA2B,mFAAmF,sBAAsB,eAAe,+BAA+B,iBAAiB,WAAW,kCAAkC,GAAG,4BAA4B,oCAAoC,6BAA6B,mCAAmC,GAAG,gCAAgC,sCAAsC,GAAG,6EAA6E,wHAAwH,gDAAgD,kBAAkB,kBAAkB,KAAK,4BAA4B,eAAe,kBAAkB,0BAA0B,gBAAgB,KAAK,0BAA0B,2CAA2C,+CAA+C,OAAO,QAAQ,OAAO,oBAAoB,OAAO,QAAQ,OAAO,qBAAqB,OAAO,OAAO,OAAO,qBAAqB,OAAO,OAAO,OAAO,oBAAoB,QAAQ,OAAO,OAAO,oBAAoB,QAAQ,OAAO,OAAO,KAAK,yCAAyC,GAAG,4BAA4B,kCAAkC,GAAG,4BAA4B,kCAAkC,GAAG,6BAA6B,mCAAmC,GAAG,gCAAgC,sCAAsC,GAAG,6BAA6B,wHAAwH,2CAA2C,yCAAyC,yCAAyC,uCAAuC,GAAG,6BAA6B,mCAAmC,GAAG,6BAA6B,mCAAmC,GAAG,6BAA6B,mCAAmC,GAAG,iCAAiC,uCAAuC,GAAG,6BAA6B,2FAA2F,uDAAuD,oDAAoD,oDAAoD,8GAA8G,4FAA4F,4FAA4F,sCAAsC,oCAAoC,oCAAoC,yCAAyC,GAAG,2BAA2B,yEAAyE,kBAAkB,aAAa,iBAAiB,qEAAqE,mEAAmE,mEAAmE,yBAAyB,sBAAsB,sBAAsB,uBAAuB,GAAG,4BAA4B,kCAAkC,GAAG,2BAA2B,6EAA6E,mBAAmB,4BAA4B,4CAA4C,KAAK,OAAO,4CAA4C,kCAAkC,KAAK,+HAA+H,kIAAkI,uBAAuB,GAAG,2BAA2B,0EAA0E,4BAA4B,+BAA+B,gBAAgB,eAAe,KAAK,iCAAiC,qBAAqB,GAAG,4BAA4B,kCAAkC,GAAG,2BAA2B,0EAA0E,iCAAiC,yBAAyB,yBAAyB,qBAAqB,GAAG,4BAA4B,kCAAkC,GAAG,4BAA4B,kCAAkC,GAAG,mCAAmC,gCAAgC,GAAG,gCAAgC,sCAAsC,GAAG,gCAAgC,sCAAsC,GAAG,gCAAgC,sCAAsC,GAAG,iCAAiC,uCAAuC,GAAG,gCAAgC,sCAAsC,GAAG,gCAAgC,sCAAsC,GAAG,uBAAuB,0nIAA0nI,6BAA6B,gCAAgC,4DAA4D,GAAG,KAAK,GAAG,sCAAsC,+BAA+B,8BAA8B,4BAA4B,GAAG,mCAAmC,0EAA0E,+DAA+D,2FAA2F,sCAAsC,OAAO,KAAK,QAAQ,wFAAwF,sFAAsF,2DAA2D,6BAA6B,2FAA2F,iDAAiD,+EAA+E,oCAAoC,gBAAgB,2CAA2C,mBAAmB,OAAO,KAAK,QAAQ,GAAG,oFAAoF,qBAAqB,IAAI,yJAAyJ,0BAA0B,gCAAgC,2DAA2D,MAAM,oEAAoE,kDAAkD,cAAc,4CAA4C,IAAI,qHAAqH,wBAAwB,qBAAqB,gCAAgC,iBAAiB,IAAI,4KAA4K,kCAAkC,iBAAiB,sEAAsE,4CAA4C,mCAAmC,MAAM,gBAAgB,IAAI,gFAAgF,kDAAkD,iDAAiD,MAAM,GAAG,EAAE,6BAA6B,GAAG,EAAE,QAAQ,sCAAsC,oBAAoB,2sKAA2sK,GAAG,GAAG,sCAAsC,2DAA2D,uBAAuB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,uBAAuB,qBAAqB,qBAAqB,qBAAqB,uBAAuB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,0HAA0H,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,sBAAsB,oBAAoB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,0CAA0C,KAAK,EAAE,4YAA4Y,sCAAsC,eAAe,sCAAsC,6CAA6C,0BAA0B,0CAA0C,MAAM,MAAM,KAAK,GAAG,sCAAsC,eAAe,sCAAsC,gDAAgD,6BAA6B,wCAAwC,MAAM,MAAM,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kDAAkD,+BAA+B,0CAA0C,MAAM,MAAM,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,8CAA8C,2BAA2B,0CAA0C,MAAM,MAAM,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,mDAAmD,gCAAgC,0CAA0C,MAAM,MAAM,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,+CAA+C,4BAA4B,0CAA0C,MAAM,MAAM,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,2BAA2B,cAAc,6BAA6B,kBAAkB,iBAAiB,mLAAmL,mBAAmB,qFAAqF,QAAQ,oBAAoB,oBAAoB,6BAA6B,6GAA6G,WAAW,yCAAyC,8EAA8E,WAAW,SAAS,OAAO,MAAM,6FAA6F,mGAAmG,iDAAiD,8BAA8B,wCAAwC,MAAM,MAAM,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,4BAA4B,cAAc,4BAA4B,kBAAkB,iBAAiB,0LAA0L,4CAA4C,SAAS,mBAAmB,iCAAiC,QAAQ,MAAM,8DAA8D,qGAAqG,qFAAqF,wBAAwB,gCAAgC,sCAAsC,qCAAqC,mFAAmF,OAAO,+IAA+I,sBAAsB,gCAAgC,oDAAoD,0BAA0B,8EAA8E,6DAA6D,0UAA0U,sCAAsC,WAAW,SAAS,MAAM,+BAA+B,OAAO,kCAAkC,sBAAsB,oEAAoE,oDAAoD,SAAS,MAAM,OAAO,2DAA2D,sBAAsB,gCAAgC,oDAAoD,oDAAoD,8CAA8C,0EAA0E,4CAA4C,sCAAsC,qCAAqC,mCAAmC,2CAA2C,iCAAiC,yCAAyC,iEAAiE,ggCAAggC,4BAA4B,OAAO,0DAA0D,sBAAsB,gCAAgC,oDAAoD,yCAAyC,4BAA4B,iIAAiI,+BAA+B,6CAA6C,iEAAiE,2BAA2B,kBAAkB,OAAO,wCAAwC,wDAAwD,2JAA2J,6DAA6D,kGAAkG,aAAa,WAAW,iDAAiD,SAAS,uCAAuC,OAAO,+BAA+B,sBAAsB,gCAAgC,oDAAoD,4CAA4C,6DAA6D,4EAA4E,gGAAgG,sDAAsD,qEAAqE,sFAAsF,kBAAkB,8PAA8P,OAAO,6CAA6C,sBAAsB,gCAAgC,oDAAoD,0CAA0C,6CAA6C,SAAS,8BAA8B,SAAS,sKAAsK,sBAAsB,yDAAyD,oDAAoD,sBAAsB,kCAAkC,qBAAqB,kBAAkB,OAAO,gDAAgD,iUAAiU,sCAAsC,WAAW,SAAS,mCAAmC,OAAO,8DAA8D,sBAAsB,gCAAgC,oDAAoD,wDAAwD,4FAA4F,iEAAiE,iNAAiN,OAAO,uDAAuD,sBAAsB,gCAAgC,oDAAoD,wDAAwD,sHAAsH,2CAA2C,sDAAsD,6BAA6B,kBAAkB,OAAO,+CAA+C,oDAAoD,yIAAyI,sDAAsD,mCAAmC,0CAA0C,eAAe,OAAO,0CAA0C,eAAe,aAAa,WAAW,4BAA4B,2DAA2D,WAAW,yDAAyD,SAAS,gDAAgD,OAAO,+BAA+B,sBAAsB,sCAAsC,yCAAyC,sCAAsC,mBAAmB,+EAA+E,0CAA0C,SAAS,OAAO,kCAAkC,2DAA2D,yDAAyD,WAAW,SAAS,2DAA2D,OAAO,6CAA6C,wEAAwE,qCAAqC,8CAA8C,qCAAqC,gNAAgN,4LAA4L,qKAAqK,OAAO,gDAAgD,wEAAwE,qCAAqC,4CAA4C,qCAAqC,4EAA4E,8LAA8L,wKAAwK,wKAAwK,OAAO,OAAO,EAAE,qKAAqK,cAAc,4BAA4B,kBAAkB,iBAAiB,8DAA8D,mBAAmB,gOAAgO,4CAA4C,SAAS,QAAQ,kBAAkB,oBAAoB,wCAAwC,OAAO,kBAAkB,oBAAoB,+CAA+C,mEAAmE,4CAA4C,2CAA2C,+CAA+C,eAAe,iFAAiF,2DAA2D,eAAe,aAAa,2BAA2B,WAAW,+CAA+C,mFAAmF,4DAA4D,WAAW,SAAS,OAAO,MAAM,sEAAsE,8IAA8I,sBAAsB,gCAAgC,oDAAoD,0BAA0B,8EAA8E,6DAA6D,0UAA0U,sCAAsC,WAAW,SAAS,MAAM,+BAA+B,OAAO,2DAA2D,sBAAsB,gCAAgC,oDAAoD,oDAAoD,8CAA8C,4CAA4C,sCAAsC,0EAA0E,qCAAqC,mCAAmC,2CAA2C,iCAAiC,yCAAyC,iEAAiE,igCAAigC,4BAA4B,OAAO,0DAA0D,sBAAsB,gCAAgC,oDAAoD,yCAAyC,gCAAgC,sHAAsH,+BAA+B,6CAA6C,iEAAiE,2BAA2B,kBAAkB,OAAO,wCAAwC,wDAAwD,2JAA2J,6DAA6D,0GAA0G,aAAa,WAAW,iDAAiD,SAAS,uCAAuC,OAAO,+BAA+B,sBAAsB,gCAAgC,oDAAoD,4CAA4C,+DAA+D,4EAA4E,kGAAkG,wDAAwD,uEAAuE,wFAAwF,kBAAkB,sQAAsQ,OAAO,8CAA8C,sBAAsB,gCAAgC,oDAAoD,0CAA0C,6CAA6C,SAAS,+BAA+B,OAAO,sKAAsK,sBAAsB,yDAAyD,oDAAoD,sBAAsB,kCAAkC,qBAAqB,kBAAkB,OAAO,gDAAgD,iUAAiU,sCAAsC,WAAW,SAAS,mCAAmC,SAAS,uDAAuD,sBAAsB,gCAAgC,oDAAoD,wDAAwD,sHAAsH,2CAA2C,sDAAsD,6BAA6B,kBAAkB,OAAO,+CAA+C,oDAAoD,yIAAyI,sDAAsD,mCAAmC,0CAA0C,eAAe,OAAO,0CAA0C,eAAe,aAAa,WAAW,4BAA4B,2DAA2D,WAAW,yDAAyD,SAAS,gDAAgD,OAAO,8DAA8D,sBAAsB,gCAAgC,oDAAoD,wDAAwD,2FAA2F,iEAAiE,kNAAkN,OAAO,KAAK,EAAE,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,+BAA+B,cAAc,6BAA6B,kBAAkB,iBAAiB,iMAAiM,mBAAmB,qFAAqF,QAAQ,oBAAoB,oBAAoB,6BAA6B,6GAA6G,WAAW,+CAA+C,mFAAmF,4FAA4F,oHAAoH,WAAW,SAAS,OAAO,MAAM,iEAAiE,+EAA+E,sBAAsB,gCAAgC,+BAA+B,+EAA+E,gDAAgD,SAAS,EAAE,OAAO,uDAAuD,sBAAsB,gCAAgC,oDAAoD,oDAAoD,0CAA0C,sCAAsC,uCAAuC,kEAAkE,+BAA+B,iCAAiC,0LAA0L,2hBAA2hB,SAAS,EAAE,mJAAmJ,mCAAmC,oFAAoF,wBAAwB,OAAO,qCAAqC,mEAAmE,OAAO,yCAAyC,sBAAsB,wEAAwE,qFAAqF,iCAAiC,wCAAwC,iCAAiC,iNAAiN,OAAO,4CAA4C,sBAAsB,4GAA4G,uFAAuF,wCAAwC,iCAAiC,+EAA+E,OAAO,KAAK,EAAE,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kEAAkE,2BAA2B,kBAAkB,8MAA8M,oCAAoC,6BAA6B,wCAAwC,sBAAsB,4DAA4D,gCAAgC,qCAAqC,iCAAiC,gCAAgC,yBAAyB,6BAA6B,OAAO,6GAA6G,4BAA4B,mCAAmC,aAAa,+BAA+B,WAAW,SAAS,6BAA6B,6BAA6B,OAAO,gBAAgB,iBAAiB,2CAA2C,kCAAkC,6DAA6D,yDAAyD,mDAAmD,0CAA0C,uCAAuC,qDAAqD,gFAAgF,yDAAyD,sJAAsJ,wIAAwI,oIAAoI,0BAA0B,yTAAyT,eAAe,EAAE,aAAa,sBAAsB,WAAW,SAAS,6CAA6C,uCAAuC,iCAAiC,4BAA4B,kEAAkE,UAAU,OAAO,2CAA2C,sFAAsF,iEAAiE,aAAa,WAAW,2BAA2B,SAAS,OAAO,kWAAkW,oBAAoB,6BAA6B,sBAAsB,WAAW,+CAA+C,2DAA2D,+FAA+F,+CAA+C,wKAAwK,oCAAoC,aAAa,OAAO,iCAAiC,aAAa,+BAA+B,WAAW,SAAS,OAAO,MAAM,sDAAsD,kCAAkC,8BAA8B,EAAE,6FAA6F,8PAA8P,0BAA0B,yBAAyB,kBAAkB,OAAO,+CAA+C,wBAAwB,WAAW,SAAS,2BAA2B,OAAO,kCAAkC,sBAAsB,+XAA+X,4CAA4C,+HAA+H,sKAAsK,2DAA2D,qGAAqG,oDAAoD,uBAAuB,kDAAkD,qBAAqB,8CAA8C,2HAA2H,oJAAoJ,+HAA+H,uJAAuJ,gDAAgD,qBAAqB,gNAAgN,qBAAqB,2MAA2M,sBAAsB,6DAA6D,yFAAyF,oBAAoB,sDAAsD,SAAS,8DAA8D,2EAA2E,+GAA+G,sGAAsG,qDAAqD,qDAAqD,2CAA2C,gGAAgG,0EAA0E,wDAAwD,8CAA8C,SAAS,EAAE,OAAO,qDAAqD,sBAAsB,g0BAAg0B,+BAA+B,uIAAuI,sWAAsW,SAAS,EAAE,iCAAiC,sEAAsE,qGAAqG,4BAA4B,6CAA6C,WAAW,OAAO,4EAA4E,WAAW,oEAAoE,SAAS,sBAAsB,OAAO,0CAA0C,4GAA4G,OAAO,qCAAqC,wCAAwC,kCAAkC,sBAAsB,kBAAkB,4DAA4D,sCAAsC,iDAAiD,qCAAqC,WAAW,SAAS,EAAE,+BAA+B,sBAAsB,SAAS,yBAAyB,OAAO,kDAAkD,yCAAyC,yCAAyC,mDAAmD,SAAS,iBAAiB,OAAO,wHAAwH,+HAA+H,yBAAyB,YAAY,OAAO,gFAAgF,gHAAgH,wDAAwD,oDAAoD,SAAS,mBAAmB,OAAO,KAAK,EAAE,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,6BAA6B,4DAA4D,4BAA4B,kBAAkB,iBAAiB,4DAA4D,mBAAmB,0DAA0D,QAAQ,MAAM,8CAA8C,4EAA4E,KAAK,+DAA+D,+HAA+H,sBAAsB,gCAAgC,gCAAgC,qCAAqC,uCAAuC,uDAAuD,mDAAmD,4BAA4B,sCAAsC,qDAAqD,+CAA+C,qCAAqC,2LAA2L,kDAAkD,WAAW,oDAAoD,wCAAwC,mDAAmD,2CAA2C,q9DAAq9D,yBAAyB,SAAS,+DAA+D,QAAQ,OAAO,gDAAgD,SAAS,sDAAsD,yCAAyC,SAAS,mFAAmF,QAAQ,OAAO,4BAA4B,SAAS,OAAO,0DAA0D,gFAAgF,wCAAwC,wCAAwC,uCAAuC,mDAAmD,SAAS,yCAAyC,mHAAmH,SAAS,oCAAoC,oDAAoD,SAAS,iCAAiC,OAAO,sDAAsD,wEAAwE,wCAAwC,wCAAwC,mCAAmC,2CAA2C,SAAS,qCAAqC,uGAAuG,SAAS,gCAAgC,4CAA4C,SAAS,6BAA6B,OAAO,sDAAsD,wEAAwE,wCAAwC,wCAAwC,2CAA2C,2CAA2C,SAAS,6CAA6C,uGAAuG,SAAS,wCAAwC,4CAA4C,SAAS,6BAA6B,OAAO,uDAAuD,sBAAsB,gCAAgC,wCAAwC,sCAAsC,oCAAoC,wCAAwC,oDAAoD,oDAAoD,2DAA2D,iBAAiB,gDAAgD,mGAAmG,sLAAsL,+CAA+C,SAAS,0FAA0F,qDAAqD,SAAS,mHAAmH,2FAA2F,mDAAmD,+BAA+B,2CAA2C,6BAA6B,4DAA4D,s1BAAs1B,OAAO,gEAAgE,sBAAsB,6BAA6B,gCAAgC,oDAAoD,uBAAuB,uBAAuB,0BAA0B,uCAAuC,qBAAqB,kBAAkB,OAAO,wCAAwC,6CAA6C,sGAAsG,mFAAmF,0CAA0C,iDAAiD,eAAe,OAAO,iDAAiD,eAAe,aAAa,WAAW,iEAAiE,+BAA+B,gEAAgE,WAAW,8DAA8D,SAAS,gDAAgD,OAAO,gDAAgD,sBAAsB,gCAAgC,sCAAsC,uCAAuC,iDAAiD,+HAA+H,+CAA+C,mCAAmC,WAAW,EAAE,SAAS,kDAAkD,kDAAkD,SAAS,0EAA0E,8CAA8C,SAAS,OAAO,2CAA2C,UAAU,OAAO,8BAA8B,iCAAiC,iOAAiO,mEAAmE,mEAAmE,2DAA2D,2DAA2D,WAAW,SAAS,+DAA+D,2CAA2C,UAAU,OAAO,qCAAqC,8GAA8G,8GAA8G,sGAAsG,sGAAsG,WAAW,SAAS,OAAO,+BAA+B,sBAAsB,gCAAgC,qCAAqC,sCAAsC,oBAAoB,4EAA4E,QAAQ,OAAO,8CAA8C,SAAS,+EAA+E,oGAAoG,wDAAwD,SAAS,2DAA2D,iEAAiE,QAAQ,OAAO,6CAA6C,SAAS,OAAO,yCAAyC,oFAAoF,iCAAiC,wCAAwC,iCAAiC,gKAAgK,wLAAwL,wKAAwK,iJAAiJ,OAAO,4CAA4C,sBAAsB,kEAAkE,iCAAiC,wCAAwC,iCAAiC,sLAAsL,+CAA+C,SAAS,+IAA+I,yEAAyE,iEAAiE,iEAAiE,OAAO,KAAK,EAAE,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,kCAAkC,gBAAgB,iGAAiG,oCAAoC,OAAO,oFAAoF,6DAA6D,gGAAgG,sBAAsB,4DAA4D,gCAAgC,qCAAqC,iCAAiC,gCAAgC,yBAAyB,6BAA6B,OAAO,6GAA6G,4BAA4B,mCAAmC,aAAa,+BAA+B,WAAW,SAAS,6BAA6B,6BAA6B,OAAO,gBAAgB,iBAAiB,2CAA2C,kCAAkC,6DAA6D,yDAAyD,mDAAmD,0CAA0C,uCAAuC,8CAA8C,gFAAgF,yDAAyD,sJAAsJ,wIAAwI,oIAAoI,0BAA0B,yTAAyT,eAAe,EAAE,aAAa,sBAAsB,WAAW,SAAS,6CAA6C,uCAAuC,iCAAiC,4BAA4B,kEAAkE,UAAU,OAAO,2CAA2C,+DAA+D,WAAW,2BAA2B,SAAS,OAAO,0EAA0E,oBAAoB,6BAA6B,sBAAsB,WAAW,+CAA+C,8EAA8E,WAAW,SAAS,OAAO,MAAM,oEAAoE,8GAA8G,sBAAsB,6BAA6B,wCAAwC,gCAAgC,iCAAiC,wCAAwC,mGAAmG,iFAAiF,yHAAyH,sGAAsG,+EAA+E,6DAA6D,iDAAiD,wDAAwD,8CAA8C,SAAS,EAAE,OAAO,qDAAqD,sBAAsB,6BAA6B,sCAAsC,iCAAiC,2CAA2C,gCAAgC,wEAAwE,uCAAuC,6EAA6E,oCAAoC,oCAAoC,8OAA8O,gCAAgC,uBAAuB,WAAW,OAAO,gEAAgE,2BAA2B,WAAW,SAAS,4CAA4C,gDAAgD,iGAAiG,4EAA4E,qEAAqE,sHAAsH,+BAA+B,+JAA+J,6YAA6Y,SAAS,EAAE,yEAAyE,sBAAsB,OAAO,0CAA0C,4GAA4G,OAAO,2CAA2C,wCAAwC,kCAAkC,sBAAsB,4DAA4D,+DAA+D,oBAAoB,WAAW,SAAS,EAAE,uBAAuB,OAAO,kDAAkD,yCAAyC,yCAAyC,uCAAuC,SAAS,iBAAiB,OAAO,KAAK,EAAE,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,8BAA8B,mCAAmC,mCAAmC,kBAAkB,eAAe,mDAAmD,OAAO,MAAM,gEAAgE,gKAAgK,sBAAsB,gCAAgC,gCAAgC,+BAA+B,uCAAuC,sCAAsC,gEAAgE,mCAAmC,uLAAuL,gDAAgD,SAAS,wCAAwC,8JAA8J,40CAA40C,SAAS,EAAE,+BAA+B,+EAA+E,gDAAgD,SAAS,MAAM,gFAAgF,OAAO,qDAAqD,sBAAsB,wCAAwC,sCAAsC,mCAAmC,kEAAkE,uFAAuF,iCAAiC,+JAA+J,+0CAA+0C,SAAS,EAAE,2GAA2G,OAAO,8CAA8C,6CAA6C,kCAAkC,0DAA0D,mCAAmC,qOAAqO,gMAAgM,sHAAsH,gHAAgH,8GAA8G,wEAAwE,SAAS,EAAE,OAAO,+BAA+B,kCAAkC,sCAAsC,wFAAwF,0CAA0C,SAAS,EAAE,+FAA+F,6EAA6E,uBAAuB,SAAS,EAAE,OAAO,yCAAyC,oFAAoF,wCAAwC,iCAAiC,iCAAiC,oLAAoL,qNAAqN,iMAAiM,0KAA0K,OAAO,4CAA4C,oEAAoE,wCAAwC,iCAAiC,iCAAiC,oEAAoE,6IAA6I,6LAA6L,yKAAyK,yKAAyK,OAAO,KAAK,EAAE,IAAI,KAAK,GAAG,uCAAuC,2CAA2C,sCAAsC,kCAAkC,yCAAyC,qHAAqH,8CAA8C,uaAAua,EAAE,gCAAgC,qLAAqL,gBAAgB,sDAAsD,WAAW,6DAA6D,OAAO,gDAAgD,QAAQ,4KAA4K,sBAAsB,sBAAsB,yCAAyC,SAAS,6BAA6B,8BAA8B,WAAW,qEAAqE,oHAAoH,mBAAmB,WAAW,SAAS,8BAA8B,0FAA0F,EAAE,+IAA+I,qCAAqC,SAAS,OAAO,yGAAyG,mFAAmF,kEAAkE,SAAS,EAAE,6BAA6B,2CAA2C,0CAA0C,SAAS,OAAO,0CAA0C,sBAAsB,kCAAkC,iSAAiS,8BAA8B,6BAA6B,WAAW,EAAE,SAAS,OAAO,gCAAgC,sBAAsB,qCAAqC,6BAA6B,kCAAkC,mDAAmD,4CAA4C,SAAS,oBAAoB,0CAA0C,sEAAsE,6DAA6D,WAAW,6EAA6E,2GAA2G,qGAAqG,WAAW,sHAAsH,kIAAkI,wHAAwH,WAAW,6GAA6G,oIAAoI,0HAA0H,aAAa,4HAA4H,yCAAyC,WAAW,OAAO,gBAAgB,WAAW,SAAS,mCAAmC,kEAAkE,sCAAsC,qFAAqF,qCAAqC,SAAS,OAAO,MAAM,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,gHAAgH,mEAAmE,2DAA2D,6CAA6C,qCAAqC,4FAA4F,yFAAyF,iBAAiB,SAAS,OAAO,2CAA2C,eAAe,OAAO,6BAA6B,sEAAsE,8CAA8C,wBAAwB,mBAAmB,cAAc,8CAA8C,+CAA+C,+CAA+C,uDAAuD,uDAAuD,0CAA0C,wBAAwB,mBAAmB,cAAc,yDAAyD,wBAAwB,6DAA6D,+DAA+D,cAAc,kEAAkE,+BAA+B,8BAA8B,2CAA2C,6FAA6F,mBAAmB,cAAc,4DAA4D,wBAAwB,gCAAgC,gCAAgC,gCAAgC,gCAAgC,wBAAwB,mBAAmB,cAAc,2CAA2C,kCAAkC,kCAAkC,kCAAkC,kCAAkC,wBAAwB,cAAc,8CAA8C,iDAAiD,iDAAiD,6CAA6C,6CAA6C,6CAA6C,6CAA6C,wBAAwB,cAAc,0CAA0C,kCAAkC,kCAAkC,kCAAkC,kCAAkC,iDAAiD,iDAAiD,6CAA6C,6CAA6C,6CAA6C,6CAA6C,wBAAwB,cAAc,0CAA0C,kCAAkC,kCAAkC,wBAAwB,cAAc,0CAA0C,yBAAyB,kCAAkC,wBAAwB,cAAc,OAAO,qBAAqB,MAAM,kDAAkD,iBAAiB,sBAAsB,4GAA4G,iBAAiB,MAAM,0CAA0C,oBAAoB,MAAM,MAAM,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,gCAAgC,kCAAkC,0GAA0G,oOAAoO,8GAA8G,0HAA0H,4BAA4B,kOAAkO,0CAA0C,sCAAsC,2IAA2I,EAAE,sBAAsB,KAAK,oEAAoE,iBAAiB,yEAAyE,qCAAqC,oEAAoE,+CAA+C,OAAO,8BAA8B,gGAAgG,+DAA+D,SAAS,EAAE,OAAO,qEAAqE,KAAK,6IAA6I,oBAAoB,oCAAoC,4DAA4D,6CAA6C,2CAA2C,yCAAyC,+BAA+B,+BAA+B,+BAA+B,6BAA6B,+BAA+B,2DAA2D,8BAA8B,0BAA0B,yBAAyB,kCAAkC,iCAAiC,2FAA2F,2CAA2C,yBAAyB,gCAAgC,SAAS,OAAO,EAAE,kCAAkC,uRAAuR,uJAAuJ,kBAAkB,OAAO,wBAAwB,kBAAkB,kBAAkB,MAAM,2FAA2F,8BAA8B,sBAAsB,qFAAqF,wCAAwC,0BAA0B,sCAAsC,yHAAyH,SAAS,sHAAsH,yBAAyB,yBAAyB,mFAAmF,oBAAoB,OAAO,4BAA4B,kCAAkC,oBAAoB,OAAO,2BAA2B,0GAA0G,oBAAoB,OAAO,mCAAmC,sBAAsB,6BAA6B,iCAAiC,kCAAkC,qFAAqF,yPAAyP,2GAA2G,uEAAuE,iBAAiB,SAAS,gDAAgD,iDAAiD,6CAA6C,+CAA+C,qCAAqC,wBAAwB,yEAAyE,oCAAoC,kDAAkD,mEAAmE,6CAA6C,WAAW,sBAAsB,4DAA4D,SAAS,OAAO,0CAA0C,mCAAmC,iDAAiD,yCAAyC,2EAA2E,mEAAmE,SAAS,EAAE,2EAA2E,mEAAmE,SAAS,EAAE,6BAA6B,uDAAuD,SAAS,OAAO,wHAAwH,sBAAsB,iCAAiC,oCAAoC,uBAAuB,+BAA+B,oGAAoG,sBAAsB,0CAA0C,aAAa,uEAAuE,sBAAsB,wCAAwC,aAAa,aAAa,SAAS,8BAA8B,sBAAsB,+DAA+D,EAAE,SAAS,8CAA8C,0CAA0C,mFAAmF,6EAA6E,4BAA4B,mBAAmB,WAAW,wCAAwC,gIAAgI,EAAE,qCAAqC,iSAAiS,6BAA6B,WAAW,SAAS,EAAE,qDAAqD,OAAO,+CAA+C,sBAAsB,uBAAuB,gCAAgC,0EAA0E,qDAAqD,2BAA2B,uDAAuD,WAAW,kCAAkC,kCAAkC,sDAAsD,WAAW,OAAO,iFAAiF,iDAAiD,WAAW,SAAS,MAAM,iCAAiC,yBAAyB,kBAAkB,OAAO,4CAA4C,gCAAgC,oBAAoB,aAAa,WAAW,SAAS,gCAAgC,OAAO,kHAAkH,sBAAsB,wEAAwE,6DAA6D,SAAS,MAAM,OAAO,qHAAqH,6BAA6B,kCAAkC,OAAO,oDAAoD,sBAAsB,2BAA2B,6DAA6D,iBAAiB,SAAS,sFAAsF,+IAA+I,oJAAoJ,6EAA6E,SAAS,MAAM,4BAA4B,6IAA6I,6BAA6B,SAAS,EAAE,8BAA8B,yIAAyI,mCAAmC,iCAAiC,0EAA0E,SAAS,OAAO,6CAA6C,SAAS,OAAO,uOAAuO,sBAAsB,6DAA6D,iBAAiB,SAAS,gFAAgF,0QAA0Q,0CAA0C,OAAO,qPAAqP,sBAAsB,qEAAqE,iBAAiB,SAAS,yDAAyD,UAAU,OAAO,mDAAmD,SAAS,oDAAoD,OAAO,2CAA2C,sBAAsB,6DAA6D,iBAAiB,SAAS,sDAAsD,qCAAqC,4CAA4C,yEAAyE,0CAA0C,8BAA8B,WAAW,UAAU,kKAAkK,gDAAgD,+EAA+E,+DAA+D,qGAAqG,+EAA+E,qFAAqF,0DAA0D,wFAAwF,YAAY,gGAAgG,qDAAqD,+EAA+E,SAAS,OAAO,oBAAoB,uBAAuB,SAAS,oBAAoB,OAAO,sCAAsC,sBAAsB,qBAAqB,kEAAkE,0BAA0B,SAAS,0EAA0E,iBAAiB,SAAS,8EAA8E,iCAAiC,SAAS,MAAM,yBAAyB,0BAA0B,SAAS,uCAAuC,uFAAuF,yDAAyD,OAAO,wPAAwP,sBAAsB,kFAAkF,iBAAiB,SAAS,+KAA+K,kDAAkD,yEAAyE,WAAW,SAAS,YAAY,iEAAiE,OAAO,0OAA0O,uDAAuD,OAAO,0CAA0C,uDAAuD,gBAAgB,EAAE,OAAO,0CAA0C,2DAA2D,gBAAgB,EAAE,OAAO,gEAAgE,mDAAmD,2CAA2C,0CAA0C,SAAS,oBAAoB,OAAO,yCAAyC,yDAAyD,gBAAgB,EAAE,OAAO,iDAAiD,sBAAsB,qDAAqD,6BAA6B,6BAA6B,SAAS,0CAA0C,oBAAoB,yCAAyC,kOAAkO,SAAS,sBAAsB,OAAO,6CAA6C,sBAAsB,yDAAyD,QAAQ,OAAO,yCAAyC,oBAAoB,WAAW,SAAS,qBAAqB,OAAO,mDAAmD,qDAAqD,iTAAiT,OAAO,qCAAqC,iDAAiD,OAAO,8BAA8B,sBAAsB,qCAAqC,0BAA0B,oBAAoB,mHAAmH,UAAU,OAAO,sCAAsC,gCAAgC,sCAAsC,mCAAmC,WAAW,SAAS,uBAAuB,4BAA4B,kCAAkC,gDAAgD,iCAAiC,8BAA8B,SAAS,wCAAwC,wCAAwC,OAAO,oCAAoC,+EAA+E,OAAO,kCAAkC,sBAAsB,wCAAwC,iIAAiI,MAAM,gCAAgC,OAAO,oEAAoE,sBAAsB,2CAA2C,mCAAmC,+CAA+C,UAAU,0DAA0D,wDAAwD,qCAAqC,SAAS,EAAE,oYAAoY,iCAAiC,wBAAwB,YAAY,8DAA8D,sCAAsC,SAAS,OAAO,sEAAsE,sBAAsB,sCAAsC,yBAAyB,iBAAiB,SAAS,+BAA+B,0DAA0D,2DAA2D,SAAS,EAAE,OAAO,8DAA8D,mEAAmE,6BAA6B,yCAAyC,QAAQ,OAAO,gCAAgC,wBAAwB,mFAAmF,WAAW,SAAS,OAAO,uEAAuE,sBAAsB,iCAAiC,iEAAiE,iBAAiB,SAAS,mGAAmG,mCAAmC,0CAA0C,qDAAqD,gDAAgD,oDAAoD,8BAA8B,uJAAuJ,SAAS,qCAAqC,yGAAyG,iOAAiO,SAAS,qCAAqC,mCAAmC,oBAAoB,OAAO,sEAAsE,OAAO,4CAA4C,QAAQ,8EAA8E,sBAAsB,uCAAuC,yCAAyC,4BAA4B,8CAA8C,4FAA4F,yBAAyB,SAAS,OAAO,uFAAuF,SAAS,6DAA6D,kJAAkJ,SAAS,2DAA2D,gCAAgC,sHAAsH,WAAW,SAAS,+GAA+G,uEAAuE,SAAS,uFAAuF,kEAAkE,SAAS,mEAAmE,oEAAoE,yBAAyB,OAAO,KAAK,EAAE,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,sEAAsE,yUAAyU,2BAA2B,gDAAgD,eAAe,OAAO,kDAAkD,qEAAqE,wCAAwC,OAAO,EAAE,2CAA2C,2EAA2E,8BAA8B,6CAA6C,sFAAsF,6DAA6D,6CAA6C,uEAAuE,yDAAyD,mDAAmD,eAAe,aAAa,EAAE,yBAAyB,WAAW,SAAS,EAAE,OAAO,EAAE,KAAK,yPAAyP,gCAAgC,kBAAkB,eAAe,OAAO,uCAAuC,8CAA8C,yBAAyB,mCAAmC,OAAO,mCAAmC,eAAe,OAAO,2CAA2C,0BAA0B,OAAO,EAAE,8BAA8B,KAAK,6HAA6H,2CAA2C,MAAM,yDAAyD,2GAA2G,mBAAmB,iJAAiJ,mBAAmB,wFAAwF,sBAAsB,yBAAyB,gCAAgC,wBAAwB,yBAAyB,OAAO,8CAA8C,kCAAkC,OAAO,iCAAiC,sBAAsB,gCAAgC,sCAAsC,sCAAsC,gFAAgF,SAAS,oCAAoC,gFAAgF,SAAS,OAAO,iCAAiC,oDAAoD,OAAO,8BAA8B,qDAAqD,OAAO,2CAA2C,0CAA0C,OAAO,4BAA4B,0BAA0B,OAAO,iEAAiE,yBAAyB,gDAAgD,SAAS,OAAO,wCAAwC,sBAAsB,yCAAyC,iCAAiC,2EAA2E,EAAE,OAAO,0CAA0C,sBAAsB,sCAAsC,iCAAiC,mGAAmG,EAAE,OAAO,kCAAkC,sBAAsB,gCAAgC,8CAA8C,iCAAiC,oBAAoB,qCAAqC,QAAQ,OAAO,4DAA4D,SAAS,gEAAgE,OAAO,8CAA8C,iDAAiD,sDAAsD,iDAAiD,OAAO,4CAA4C,sBAAsB,sCAAsC,uDAAuD,mQAAmQ,yBAAyB,8HAA8H,WAAW,wCAAwC,0BAA0B,SAAS,wMAAwM,OAAO,4DAA4D,sCAAsC,mBAAmB,2CAA2C,0CAA0C,SAAS,OAAO,uDAAuD,SAAS,OAAO,2DAA2D,8IAA8I,8FAA8F,gKAAgK,0IAA0I,0IAA0I,OAAO,2CAA2C,8IAA8I,8IAA8I,wLAAwL,kKAAkK,mJAAmJ,OAAO,wEAAwE,sBAAsB,gCAAgC,wCAAwC,uCAAuC,kCAAkC,kCAAkC,uDAAuD,SAAS,8BAA8B,wDAAwD,SAAS,OAAO,oFAAoF,qBAAqB,SAAS,OAAO,6CAA6C,SAAS,OAAO,oEAAoE,+EAA+E,OAAO,mEAAmE,kCAAkC,OAAO,qEAAqE,oCAAoC,OAAO,kFAAkF,iDAAiD,yDAAyD,OAAO,uEAAuE,iDAAiD,OAAO,KAAK,EAAE,wDAAwD,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,0BAA0B,+CAA+C,0CAA0C,6CAA6C,MAAM,+CAA+C,gCAAgC,4BAA4B,OAAO,4BAA4B,sBAAsB,wBAAwB,8CAA8C,SAAS,4CAA4C,kBAAkB,OAAO,qCAAqC,sBAAsB,0BAA0B,8CAA8C,SAAS,mEAAmE,+BAA+B,2BAA2B,oBAAoB,SAAS,2BAA2B,qBAAqB,SAAS,wDAAwD,iCAAiC,2FAA2F,0CAA0C,qEAAqE,2CAA2C,aAAa,OAAO,oCAAoC,aAAa,mDAAmD,oCAAoC,0FAA0F,sCAAsC,iBAAiB,iGAAiG,gDAAgD,aAAa,cAAc,oCAAoC,aAAa,0CAA0C,sCAAsC,gHAAgH,4EAA4E,uCAAuC,OAAO,kCAAkC,WAAW,SAAS,MAAM,oBAAoB,OAAO,sCAAsC,gBAAgB,+DAA+D,OAAO,+BAA+B,kFAAkF,OAAO,KAAK,EAAE,8CAA8C,MAAM,KAAK,GAAG,uCAAuC,yEAAyE,2BAA2B,sCAAsC,uGAAuG,oGAAoG,oEAAoE,sCAAsC,8BAA8B,sBAAsB,2BAA2B,QAAQ,OAAO,gDAAgD,WAAW,SAAS,OAAO,qBAAqB,SAAS,OAAO,gDAAgD,WAAW,SAAS,OAAO,yCAAyC,yCAAyC,0BAA0B,mBAAmB,SAAS,OAAO,0DAA0D,SAAS,OAAO,MAAM,mCAAmC,wBAAwB,8CAA8C,qCAAqC,yCAAyC,SAAS,wDAAwD,+CAA+C,SAAS,OAAO,gCAAgC,SAAS,OAAO,EAAE,sBAAsB,MAAM,qCAAqC,wCAAwC,0BAA0B,QAAQ,8CAA8C,UAAU,OAAO,0CAA0C,OAAO,kBAAkB,MAAM,2HAA2H,sCAAsC,kFAAkF,sDAAsD,yDAAyD,yDAAyD,mCAAmC,6IAA6I,WAAW,4BAA4B,2LAA2L,WAAW,qOAAqO,wJAAwJ,WAAW,OAAO,sFAAsF,WAAW,SAAS,EAAE,OAAO,EAAE,oBAAoB,MAAM,qDAAqD,sCAAsC,sDAAsD,iDAAiD,0FAA0F,2DAA2D,+GAA+G,+EAA+E,wEAAwE,4EAA4E,eAAe,qEAAqE,gPAAgP,eAAe,OAAO,sHAAsH,eAAe,aAAa,EAAE,WAAW,OAAO,2BAA2B,oDAAoD,+GAA+G,2GAA2G,aAAa,EAAE,WAAW,SAAS,yHAAyH,sJAAsJ,WAAW,OAAO,kFAAkF,SAAS,OAAO,EAAE,oBAAoB,MAAM,6EAA6E,kDAAkD,4BAA4B,OAAO,qCAAqC,kEAAkE,OAAO,qBAAqB,MAAM,+DAA+D,wDAAwD,MAAM,2EAA2E,mCAAmC,OAAO,8BAA8B,4CAA4C,UAAU,OAAO,kCAAkC,qBAAqB,WAAW,SAAS,kBAAkB,QAAQ,0DAA0D,kEAAkE,iDAAiD,OAAO,wBAAwB,iDAAiD,mCAAmC,8BAA8B,SAAS,OAAO,EAAE,wBAAwB,MAAM,0FAA0F,gDAAgD,OAAO,0CAA0C,mDAAmD,4CAA4C,UAAU,OAAO,yDAAyD,qBAAqB,WAAW,SAAS,kBAAkB,QAAQ,iFAAiF,kGAAkG,wBAAwB,OAAO,kCAAkC,0BAA0B,OAAO,2CAA2C,0CAA0C,6BAA6B,SAAS,OAAO,MAAM,qFAAqF,gGAAgG,0CAA0C,OAAO,kCAAkC,QAAQ,OAAO,2CAA2C,0CAA0C,6BAA6B,SAAS,OAAO,MAAM,6CAA6C,mGAAmG,yHAAyH,yCAAyC,QAAQ,oCAAoC,wCAAwC,QAAQ,yCAAyC,+CAA+C,+CAA+C,yBAAyB,2DAA2D,OAAO,8CAA8C,4BAA4B,MAAM,iCAAiC,+BAA+B,iBAAiB,yBAAyB,oBAAoB,QAAQ,KAAK,IAAI,0DAA0D,kDAAkD,MAAM,oDAAoD,uCAAuC,MAAM,gDAAgD,kCAAkC,sEAAsE,MAAM,mCAAmC,gDAAgD,4BAA4B,sCAAsC,SAAS,mBAAmB,OAAO,4BAA4B,MAAM,mCAAmC,gDAAgD,4BAA4B,sCAAsC,SAAS,mBAAmB,OAAO,4BAA4B,MAAM,gDAAgD,4BAA4B,OAAO,qBAAqB,eAAe,yDAAyD,mBAAmB,SAAS,8BAA8B,QAAQ,kDAAkD,6BAA6B,OAAO,qBAAqB,uCAAuC,QAAQ,2CAA2C,uCAAuC,MAAM,2CAA2C,uCAAuC,MAAM,2IAA2I,4PAA4P,yEAAyE,uCAAuC,+BAA+B,yEAAyE,gBAAgB,uEAAuE,MAAM,wDAAwD,gFAAgF,MAAM,+CAA+C,8CAA8C,MAAM,4EAA4E,yXAAyX,uGAAuG,6FAA6F,oCAAoC,kCAAkC,6FAA6F,iCAAiC,yBAAyB,yDAAyD,gBAAgB,mBAAmB,gHAAgH,gBAAgB,gHAAgH,QAAQ,MAAM,8CAA8C,oDAAoD,iZAAiZ,gBAAgB,2EAA2E,OAAO,EAAE,iHAAiH,mDAAmD,iBAAiB,eAAe,OAAO,6CAA6C,sCAAsC,mBAAmB,SAAS,iEAAiE,0EAA0E,mDAAmD,wEAAwE,4MAA4M,SAAS,uDAAuD,gDAAgD,SAAS,iDAAiD,+CAA+C,SAAS,6EAA6E,8BAA8B,SAAS,OAAO,2EAA2E,SAAS,OAAO,yGAAyG,iBAAiB,mBAAmB,OAAO,6CAA6C,+CAA+C,+DAA+D,mBAAmB,SAAS,2EAA2E,8CAA8C,mBAAmB,SAAS,yDAAyD,oDAAoD,oEAAoE,oCAAoC,mBAAmB,SAAS,iDAAiD,8DAA8D,2DAA2D,OAAO,kDAAkD,iBAAiB,eAAe,OAAO,6CAA6C,sCAAsC,mBAAmB,SAAS,iEAAiE,0EAA0E,qDAAqD,oEAAoE,mFAAmF,qGAAqG,SAAS,mDAAmD,mEAAmE,+EAA+E,iGAAiG,SAAS,OAAO,MAAM,0DAA0D,iBAAiB,sFAAsF,OAAO,wGAAwG,MAAM,8DAA8D,iBAAiB,sFAAsF,OAAO,gEAAgE,MAAM,8IAA8I,sDAAsD,oDAAoD,uBAAuB,oBAAoB,6BAA6B,2BAA2B,SAAS,yBAAyB,2BAA2B,SAAS,yBAAyB,2BAA2B,SAAS,OAAO,4BAA4B,SAAS,OAAO,4BAA4B,yBAAyB,OAAO,0BAA0B,yBAAyB,OAAO,0BAA0B,yBAAyB,OAAO,OAAO,0BAA0B,OAAO,qDAAqD,MAAM,gKAAgK,2BAA2B,iBAAiB,OAAO,gCAAgC,qBAAqB,OAAO,iCAAiC,gCAAgC,OAAO,mCAAmC,+BAA+B,+BAA+B,SAAS,8CAA8C,OAAO,iCAAiC,yBAAyB,OAAO,kCAAkC,iDAAiD,OAAO,oCAAoC,+BAA+B,mCAAmC,SAAS,8CAA8C,OAAO,iCAAiC,6BAA6B,OAAO,kCAAkC,sDAAsD,OAAO,oCAAoC,+BAA+B,uCAAuC,SAAS,mDAAmD,OAAO,iCAAiC,4CAA4C,OAAO,kCAAkC,yDAAyD,OAAO,oCAAoC,+BAA+B,2CAA2C,SAAS,sDAAsD,OAAO,gCAAgC,wDAAwD,OAAO,iCAAiC,mDAAmD,OAAO,mCAAmC,wDAAwD,OAAO,gCAAgC,iEAAiE,OAAO,iCAAiC,mEAAmE,OAAO,mCAAmC,sBAAsB,mBAAmB,SAAS,sBAAsB,mBAAmB,SAAS,+BAA+B,mDAAmD,SAAS,qDAAqD,OAAO,gCAAgC,qBAAqB,mBAAmB,SAAS,sDAAsD,OAAO,iCAAiC,sDAAsD,OAAO,mCAAmC,+BAA+B,qDAAqD,SAAS,yDAAyD,OAAO,mCAAmC,wBAAwB,kBAAkB,kBAAkB,sBAAsB,mBAAmB,SAAS,6BAA6B,mBAAmB,SAAS,iBAAiB,sBAAsB,SAAS,8BAA8B,gBAAgB,oBAAoB,SAAS,OAAO,mDAAmD,SAAS,6FAA6F,OAAO,oCAAoC,wBAAwB,kBAAkB,kBAAkB,sBAAsB,mBAAmB,SAAS,6BAA6B,mBAAmB,SAAS,iBAAiB,sBAAsB,SAAS,8BAA8B,gBAAgB,oBAAoB,SAAS,OAAO,mDAAmD,SAAS,wFAAwF,OAAO,sCAAsC,wBAAwB,kBAAkB,kBAAkB,sBAAsB,mBAAmB,SAAS,iCAAiC,mBAAmB,SAAS,iBAAiB,8BAA8B,SAAS,8BAA8B,gBAAgB,oBAAoB,SAAS,OAAO,mDAAmD,SAAS,oBAAoB,qGAAqG,SAAS,qGAAqG,OAAO,gCAAgC,wBAAwB,oDAAoD,OAAO,iCAAiC,wBAAwB,iEAAiE,OAAO,mCAAmC,wBAAwB,+BAA+B,kEAAkE,SAAS,2EAA2E,OAAO,kCAAkC,sDAAsD,OAAO,mCAAmC,oCAAoC,sCAAsC,SAAS,2BAA2B,+DAA+D,SAAS,6BAA6B,kEAAkE,SAAS,mEAAmE,OAAO,qCAAqC,wBAAwB,yDAAyD,SAAS,sEAAsE,OAAO,MAAM,wJAAwJ,gPAAgP,wDAAwD,UAAU,KAAK,IAAI,6EAA6E,yBAAyB,kJAAkJ,gCAAgC,0CAA0C,oCAAoC,oCAAoC,SAAS,OAAO,2BAA2B,2BAA2B,OAAO,qSAAqS,2EAA2E,+EAA+E,iFAAiF,sFAAsF,uFAAuF,6XAA6X,+HAA+H,gBAAgB,2CAA2C,QAAQ,0DAA0D,kCAAkC,iDAAiD,OAAO,6BAA6B,mDAAmD,OAAO,OAAO,wCAAwC,OAAO,MAAM,8DAA8D,qCAAqC,4DAA4D,OAAO,6BAA6B,oDAAoD,OAAO,OAAO,8CAA8C,OAAO,MAAM,2KAA2K,wBAAwB,4CAA4C,iDAAiD,+CAA+C,2HAA2H,SAAS,OAAO,OAAO,mCAAmC,OAAO,6BAA6B,KAAK,0IAA0I,uEAAuE,KAAK,meAAme,sCAAsC,0CAA0C,qEAAqE,6EAA6E,yDAAyD,mEAAmE,8CAA8C,wCAAwC,4NAA4N,OAAO,sBAAsB,KAAK,uGAAuG,yEAAyE,MAAM,wGAAwG,2EAA2E,MAAM,iDAAiD,yCAAyC,kFAAkF,oFAAoF,iEAAiE,mDAAmD,4CAA4C,MAAM,kDAAkD,yCAAyC,gFAAgF,sFAAsF,kEAAkE,oDAAoD,4CAA4C,MAAM,+CAA+C,oJAAoJ,MAAM,2CAA2C,oFAAoF,6BAA6B,eAAe,OAAO,kCAAkC,gCAAgC,8BAA8B,4CAA4C,wCAAwC,8CAA8C,0RAA0R,wCAAwC,MAAM,6DAA6D,2DAA2D,MAAM,qEAAqE,8DAA8D,MAAM,qEAAqE,0BAA0B,+CAA+C,iEAAiE,kCAAkC,+BAA+B,uCAAuC,0BAA0B,OAAO,wBAAwB,sBAAsB,mDAAmD,qJAAqJ,uEAAuE,SAAS,mCAAmC,sMAAsM,uKAAuK,iFAAiF,aAAa,WAAW,EAAE,SAAS,OAAO,EAAE,kCAAkC,yCAAyC,uBAAuB,WAAW,OAAO,6BAA6B,SAAS,4BAA4B,OAAO,qBAAqB,MAAM,oEAAoE,mCAAmC,uBAAuB,iEAAiE,wBAAwB,OAAO,gCAAgC,4BAA4B,OAAO,qBAAqB,MAAM,0DAA0D,4BAA4B,mDAAmD,qCAAqC,6CAA6C,yCAAyC,WAAW,SAAS,OAAO,EAAE,2BAA2B,MAAM,+EAA+E,sBAAsB,gCAAgC,wCAAwC,gEAAgE,iDAAiD,kFAAkF,yCAAyC,kEAAkE,gCAAgC,gDAAgD,sBAAsB,MAAM,iCAAiC,mBAAmB,6CAA6C,iBAAiB,OAAO,2EAA2E,yDAAyD,OAAO,wBAAwB,MAAM,yDAAyD,kCAAkC,OAAO,uBAAuB,wEAAwE,QAAQ,6FAA6F,0BAA0B,oDAAoD,qBAAqB,OAAO,mCAAmC,UAAU,OAAO,mBAAmB,mBAAmB,2DAA2D,6CAA6C,yBAAyB,WAAW,SAAS,sBAAsB,wEAAwE,KAAK,KAAK,KAAK,uBAAuB,SAAS,OAAO,oBAAoB,MAAM,sDAAsD,gDAAgD,8BAA8B,OAAO,MAAM,kDAAkD,gLAAgL,MAAM,IAAI,KAAK,EAAE,QAAQ,uCAAuC,eAAe,sCAAsC,gCAAgC,oFAAoF,aAAa,yDAAyD,MAAM,mCAAmC,MAAM,sEAAsE,qBAAqB,gBAAgB,2CAA2C,OAAO,qDAAqD,KAAK,yGAAyG,MAAM,iCAAiC,SAAS,qGAAqG,yCAAyC,iCAAiC,2CAA2C,UAAU,OAAO,yCAAyC,mBAAmB,SAAS,yCAAyC,4CAA4C,UAAU,OAAO,qCAAqC,oCAAoC,6BAA6B,WAAW,SAAS,OAAO,KAAK,uGAAuG,eAAe,2CAA2C,MAAM,2CAA2C,eAAe,0EAA0E,wBAAwB,oDAAoD,sDAAsD,iCAAiC,SAAS,OAAO,EAAE,wBAAwB,KAAK,8IAA8I,MAAM,2DAA2D,MAAM,oDAAoD,QAAQ,uFAAuF,SAAS,kEAAkE,eAAe,mGAAmG,iDAAiD,4BAA4B,8BAA8B,uDAAuD,OAAO,oDAAoD,oEAAoE,iBAAiB,SAAS,gDAAgD,wDAAwD,uCAAuC,mCAAmC,iCAAiC,SAAS,qCAAqC,4HAA4H,SAAS,OAAO,EAAE,4BAA4B,KAAK,6CAA6C,yDAAyD,+CAA+C,uCAAuC,QAAQ,mIAAmI,wBAAwB,4BAA4B,kBAAkB,OAAO,qEAAqE,mDAAmD,yGAAyG,4GAA4G,mCAAmC,WAAW,SAAS,OAAO,EAAE,wBAAwB,KAAK,kTAAkT,0DAA0D,oCAAoC,6DAA6D,4BAA4B,wDAAwD,0DAA0D,qCAAqC,8BAA8B,aAAa,WAAW,EAAE,wCAAwC,SAAS,mgBAAmgB,MAAM,2DAA2D,MAAM,2DAA2D,oBAAoB,sDAAsD,gBAAgB,2cAA2c,MAAM,2DAA2D,MAAM,2DAA2D,oBAAoB,sDAAsD,gBAAgB,mJAAmJ,6DAA6D,uHAAuH,mCAAmC,sEAAsE,WAAW,yBAAyB,SAAS,kMAAkM,2CAA2C,SAAS,wMAAwM,MAAM,2DAA2D,MAAM,oDAAoD,gBAAgB,wIAAwI,6DAA6D,oDAAoD,SAAS,6JAA6J,MAAM,2DAA2D,MAAM,2DAA2D,oBAAoB,mCAAmC,gBAAgB,mJAAmJ,6DAA6D,iFAAiF,uIAAuI,8CAA8C,sCAAsC,sCAAsC,sCAAsC,gCAAgC,yGAAyG,eAAe,2BAA2B,aAAa,EAAE,WAAW,2EAA2E,SAAS,qKAAqK,MAAM,2DAA2D,MAAM,2DAA2D,oBAAoB,mCAAmC,gBAAgB,6IAA6I,6DAA6D,yBAAyB,qCAAqC,wDAAwD,+CAA+C,kCAAkC,aAAa,4DAA4D,oCAAoC,aAAa,WAAW,EAAE,6LAA6L,uBAAuB,WAAW,uBAAuB,SAAS,qKAAqK,MAAM,2DAA2D,MAAM,2DAA2D,oBAAoB,mCAAmC,gBAAgB,6IAA6I,6DAA6D,yBAAyB,qCAAqC,wDAAwD,+CAA+C,kCAAkC,aAAa,4DAA4D,oCAAoC,aAAa,WAAW,EAAE,6LAA6L,uBAAuB,WAAW,uBAAuB,SAAS,OAAO,MAAM,IAAI,KAAK,GAAG,uCAAuC,eAAe,iCAAiC,oHAAoH,iEAAiE,6BAA6B,MAAM,+FAA+F,eAAe,gMAAgM,qHAAqH,wVAAwV,6EAA6E,wBAAwB,8DAA8D,yBAAyB,gCAAgC,OAAO,qHAAqH,+CAA+C,sDAAsD,aAAa,+BAA+B,WAAW,6BAA6B,iCAAiC,SAAS,OAAO,MAAM,0BAA0B,mBAAmB,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,iUAAiU,kBAAkB,sLAAsL,mCAAmC,mCAAmC,SAAS,sCAAsC,OAAO,kDAAkD,mCAAmC,iBAAiB,SAAS,wEAAwE,OAAO,6FAA6F,+BAA+B,iBAAiB,SAAS,2DAA2D,mEAAmE,8BAA8B,6BAA6B,2BAA2B,8BAA8B,gCAAgC,8FAA8F,iCAAiC,+BAA+B,kCAAkC,SAAS,OAAO,0CAA0C,4CAA4C,wCAAwC,8CAA8C,SAAS,4EAA4E,iDAAiD,SAAS,EAAE,2EAA2E,kDAAkD,SAAS,EAAE,yEAAyE,gDAAgD,SAAS,EAAE,4EAA4E,mDAAmD,SAAS,EAAE,2JAA2J,sDAAsD,SAAS,EAAE,4GAA4G,+EAA+E,SAAS,EAAE,yCAAyC,+EAA+E,SAAS,EAAE,u3EAAu3E,8DAA8D,4CAA4C,yDAAyD,+HAA+H,yHAAyH,8DAA8D,6CAA6C,6BAA6B,2CAA2C,sBAAsB,gDAAgD,+BAA+B,8GAA8G,iDAAiD,WAAW,OAAO,oEAAoE,+CAA+C,WAAW,8BAA8B,kGAAkG,EAAE,SAAS,+FAA+F,yJAAyJ,0CAA0C,sCAAsC,yCAAyC,8EAA8E,yCAAyC,wDAAwD,2FAA2F,8FAA8F,WAAW,SAAS,EAAE,4EAA4E,uCAAuC,sDAAsD,oFAAoF,6FAA6F,WAAW,SAAS,EAAE,qOAAqO,gDAAgD,6CAA6C,mDAAmD,gEAAgE,gFAAgF,sCAAsC,WAAW,EAAE,6BAA6B,qCAAqC,iCAAiC,+NAA+N,+TAA+T,aAAa,OAAO,uEAAuE,aAAa,WAAW,SAAS,iJAAiJ,iDAAiD,2CAA2C,SAAS,EAAE,kDAAkD,4CAA4C,SAAS,EAAE,+HAA+H,oIAAoI,4CAA4C,SAAS,EAAE,mDAAmD,+CAA+C,SAAS,EAAE,6CAA6C,iFAAiF,uCAAuC,WAAW,EAAE,+BAA+B,oIAAoI,6BAA6B,kFAAkF,WAAW,SAAS,8HAA8H,+KAA+K,4CAA4C,yCAAyC,+CAA+C,iDAAiD,2CAA2C,SAAS,EAAE,kDAAkD,4CAA4C,SAAS,EAAE,gDAAgD,4CAA4C,SAAS,EAAE,iDAAiD,+CAA+C,SAAS,EAAE,6KAA6K,mDAAmD,8FAA8F,4FAA4F,kDAAkD,iGAAiG,4VAA4V,sFAAsF,2GAA2G,iDAAiD,+CAA+C,WAAW,EAAE,oDAAoD,+CAA+C,WAAW,EAAE,kDAAkD,yCAAyC,+CAA+C,aAAa,WAAW,EAAE,qDAAqD,yCAAyC,+CAA+C,aAAa,WAAW,EAAE,uDAAuD,mDAAmD,SAAS,6FAA6F,kDAAkD,kCAAkC,mCAAmC,iFAAiF,+GAA+G,0BAA0B,0CAA0C,gEAAgE,aAAa,OAAO,8BAA8B,yCAAyC,0CAA0C,kEAAkE,gEAAgE,WAAW,SAAS,6DAA6D,iFAAiF,kCAAkC,6CAA6C,4CAA4C,sDAAsD,oMAAoM,uEAAuE,kDAAkD,gDAAgD,oDAAoD,sDAAsD,8DAA8D,SAAS,EAAE,OAAO,MAAM,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,4BAA4B,sCAAsC,gQAAgQ,4CAA4C,4BAA4B,4CAA4C,uIAAuI,wEAAwE,OAAO,wCAAwC,geAAge,gCAAgC,0FAA0F,oBAAoB,woBAAwoB,WAAW,aAAa,SAAS,OAAO,MAAM,+GAA+G,OAAO,wDAAwD,OAAO,oCAAoC,OAAO,kFAAkF,gGAAgG,KAAK,2CAA2C,sCAAsC,qCAAqC,oGAAoG,sGAAsG,OAAO,uRAAuR,sBAAsB,+FAA+F,2BAA2B,0EAA0E,iCAAiC,6BAA6B,wDAAwD,2BAA2B,gCAAgC,gDAAgD,yBAAyB,8BAA8B,uCAAuC,iBAAiB,sBAAsB,mCAAmC,4BAA4B,OAAO,sGAAsG,sBAAsB,gGAAgG,wFAAwF,sBAAsB,8BAA8B,SAAS,OAAO,mCAAmC,8EAA8E,gCAAgC,SAAS,qDAAqD,0BAA0B,4BAA4B,6BAA6B,gDAAgD,gDAAgD,OAAO,yGAAyG,sBAAsB,0CAA0C,sEAAsE,iCAAiC,2DAA2D,yDAAyD,WAAW,EAAE,SAAS,mCAAmC,gCAAgC,SAAS,uCAAuC,OAAO,uFAAuF,sBAAsB,8BAA8B,oCAAoC,mCAAmC,2BAA2B,6bAA6b,0EAA0E,mCAAmC,6CAA6C,6BAA6B,sCAAsC,kEAAkE,SAAS,OAAO,2CAA2C,wCAAwC,gCAAgC,sDAAsD,+BAA+B,+BAA+B,gMAAgM,yFAAyF,qCAAqC,qCAAqC,oEAAoE,8DAA8D,6FAA6F,gGAAgG,8DAA8D,wDAAwD,eAAe,gIAAgI,4HAA4H,+EAA+E,aAAa,EAAE,4CAA4C,aAAa,OAAO,6CAA6C,oDAAoD,+CAA+C,oCAAoC,qCAAqC,iDAAiD,oEAAoE,8DAA8D,iGAAiG,mHAAmH,kEAAkE,mDAAmD,+DAA+D,qCAAqC,eAAe,qGAAqG,6CAA6C,gIAAgI,gIAAgI,aAAa,EAAE,4CAA4C,+CAA+C,wCAAwC,WAAW,SAAS,mCAAmC,mCAAmC,OAAO,+EAA+E,qFAAqF,OAAO,0EAA0E,sBAAsB,8BAA8B,oCAAoC,4KAA4K,6BAA6B,4hBAA4hB,4DAA4D,mCAAmC,8BAA8B,sCAAsC,gEAAgE,2DAA2D,qGAAqG,yFAAyF,mDAAmD,qBAAqB,aAAa,+DAA+D,8FAA8F,wFAAwF,wGAAwG,2FAA2F,yFAAyF,gGAAgG,uGAAuG,oCAAoC,+IAA+I,aAAa,6DAA6D,oMAAoM,+CAA+C,uCAAuC,uCAAuC,qJAAqJ,aAAa,OAAO,+EAA+E,yDAAyD,eAAe,qDAAqD,aAAa,4BAA4B,YAAY,gEAAgE,4EAA4E,sCAAsC,+EAA+E,gCAAgC,4EAA4E,wFAAwF,2BAA2B,aAAa,YAAY,wEAAwE,6BAA6B,sBAAsB,8IAA8I,WAAW,OAAO,sBAAsB,4HAA4H,WAAW,0DAA0D,gEAAgE,qLAAqL,iCAAiC,6CAA6C,2CAA2C,8BAA8B,uFAAuF,eAAe,aAAa,uCAAuC,kFAAkF,wDAAwD,4BAA4B,aAAa,8CAA8C,mCAAmC,gCAAgC,wFAAwF,iCAAiC,sDAAsD,aAAa,OAAO,qCAAqC,aAAa,aAAa,EAAE,SAAS,OAAO,sEAAsE,OAAO,8CAA8C,QAAQ,kEAAkE,sBAAsB,8BAA8B,2DAA2D,4BAA4B,qCAAqC,8BAA8B,mBAAmB,WAAW,SAAS,6BAA6B,8BAA8B,mBAAmB,WAAW,SAAS,OAAO,iBAAiB,SAAS,kGAAkG,+EAA+E,iGAAiG,yBAAyB,eAAe,OAAO,+BAA+B,8HAA8H,yEAAyE,8HAA8H,+BAA+B,sBAAsB,eAAe,iCAAiC,8HAA8H,+BAA+B,sBAAsB,eAAe,aAAa,WAAW,SAAS,yBAAyB,OAAO,KAAK,EAAE,oEAAoE,qCAAqC,oGAAoG,EAAE,oCAAoC,wDAAwD,KAAK,+DAA+D,2CAA2C,sDAAsD,2BAA2B,8DAA8D,SAAS,OAAO,8CAA8C,sDAAsD,2BAA2B,qFAAqF,uCAAuC,sDAAsD,WAAW,OAAO,gEAAgE,WAAW,SAAS,OAAO,6EAA6E,sCAAsC,SAAS,OAAO,+CAA+C,0CAA0C,qBAAqB,gCAAgC,SAAS,OAAO,KAAK,EAAE,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,yCAAyC,0HAA0H,ofAAof,aAAa,wEAAwE,8BAA8B,uDAAuD,yCAAyC,2BAA2B,WAAW,SAAS,EAAE,0BAA0B,OAAO,yFAAyF,aAAa,0EAA0E,8BAA8B,uDAAuD,sCAAsC,2BAA2B,6BAA6B,WAAW,SAAS,EAAE,0BAA0B,OAAO,0GAA0G,2BAA2B,wBAAwB,OAAO,iFAAiF,OAAO,uDAAuD,oCAAoC,OAAO,gFAAgF,MAAM,iFAAiF,6BAA6B,OAAO,mSAAmS,OAAO,gFAAgF,OAAO,qFAAqF,MAAM,uEAAuE,QAAQ,iHAAiH,kDAAkD,sCAAsC,kDAAkD,mBAAmB,QAAQ,OAAO,sCAAsC,qCAAqC,gCAAgC,6CAA6C,gDAAgD,4CAA4C,yDAAyD,2BAA2B,aAAa,WAAW,SAAS,sBAAsB,OAAO,mGAAmG,MAAM,GAAG,kBAAkB,+DAA+D,0DAA0D,EAAE,yCAAyC,mCAAmC,SAAS,2BAA2B,6BAA6B,mDAAmD,qDAAqD,uEAAuE,+EAA+E,4CAA4C,2BAA2B,mBAAmB,WAAW,+BAA+B,iCAAiC,+BAA+B,mBAAmB,WAAW,gCAAgC,+CAA+C,WAAW,iCAAiC,4BAA4B,0DAA0D,WAAW,EAAE,SAAS,EAAE,0CAA0C,iCAAiC,2BAA2B,OAAO,MAAM,iMAAiM,iBAAiB,2CAA2C,OAAO,8KAA8K,iBAAiB,2CAA2C,OAAO,4QAA4Q,iBAAiB,2CAA2C,OAAO,+CAA+C,QAAQ,2QAA2Q,iBAAiB,2CAA2C,OAAO,2QAA2Q,iBAAiB,2CAA2C,OAAO,+CAA+C,QAAQ,2SAA2S,iBAAiB,2CAA2C,OAAO,gRAAgR,iBAAiB,2CAA2C,OAAO,+CAA+C,QAAQ,6PAA6P,iBAAiB,2CAA2C,OAAO,gPAAgP,iBAAiB,2CAA2C,OAAO,+CAA+C,QAAQ,2RAA2R,iBAAiB,2CAA2C,OAAO,mTAAmT,iBAAiB,2CAA2C,OAAO,+EAA+E,OAAO,+CAA+C,QAAQ,gRAAgR,iBAAiB,2CAA2C,OAAO,+EAA+E,OAAO,yQAAyQ,iBAAiB,2CAA2C,OAAO,+EAA+E,OAAO,+CAA+C,QAAQ,sRAAsR,iBAAiB,2CAA2C,OAAO,+EAA+E,OAAO,4NAA4N,iBAAiB,2CAA2C,OAAO,yCAAyC,OAAO,+OAA+O,iBAAiB,2CAA2C,OAAO,yCAAyC,OAAO,4IAA4I,iBAAiB,2CAA2C,OAAO,qFAAqF,OAAO,+IAA+I,iBAAiB,2CAA2C,OAAO,4RAA4R,wVAAwV,EAAE,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,8BAA8B,0FAA0F,sVAAsV,0CAA0C,yGAAyG,wCAAwC,uYAAuY,MAAM,qDAAqD,8HAA8H,KAAK,0CAA0C,wDAAwD,iDAAiD,qFAAqF,wFAAwF,2FAA2F,gBAAgB,4HAA4H,KAAK,0CAA0C,qHAAqH,QAAQ,6DAA6D,sBAAsB,gBAAgB,6JAA6J,OAAO,qOAAqO,gEAAgE,OAAO,uDAAuD,sBAAsB,+FAA+F,2BAA2B,0EAA0E,iCAAiC,qCAAqC,kFAAkF,WAAW,wDAAwD,wDAAwD,2BAA2B,gCAAgC,uDAAuD,iCAAiC,6BAA6B,gDAAgD,wBAAwB,6BAA6B,2CAA2C,kCAAkC,wCAAwC,mEAAmE,mCAAmC,wCAAwC,qCAAqC,iBAAiB,sBAAsB,mCAAmC,4BAA4B,SAAS,gCAAgC,+DAA+D,OAAO,oDAAoD,uEAAuE,OAAO,kCAAkC,sBAAsB,gGAAgG,wFAAwF,sBAAsB,8BAA8B,SAAS,OAAO,mCAAmC,8EAA8E,gCAAgC,SAAS,qDAAqD,0BAA0B,4BAA4B,6BAA6B,OAAO,uCAAuC,sEAAsE,OAAO,2DAA2D,oEAAoE,OAAO,4EAA4E,mEAAmE,OAAO,+CAA+C,oEAAoE,OAAO,mEAAmE,mEAAmE,OAAO,kDAAkD,+EAA+E,OAAO,yCAAyC,sBAAsB,2EAA2E,4EAA4E,OAAO,+CAA+C,8EAA8E,OAAO,4DAA4D,+EAA+E,OAAO,0CAA0C,sBAAsB,6BAA6B,wCAAwC,oKAAoK,qCAAqC,wDAAwD,wDAAwD,8GAA8G,8CAA8C,0BAA0B,0BAA0B,sJAAsJ,4KAA4K,gEAAgE,iDAAiD,iDAAiD,oEAAoE,+DAA+D,oBAAoB,aAAa,8BAA8B,0DAA0D,WAAW,SAAS,2CAA2C,OAAO,+CAA+C,8EAA8E,OAAO,0CAA0C,6DAA6D,OAAO,wBAAwB,sBAAsB,oDAAoD,gDAAgD,gCAAgC,kCAAkC,6CAA6C,0CAA0C,mCAAmC,6CAA6C,oDAAoD,6EAA6E,2DAA2D,6CAA6C,wMAAwM,SAAS,OAAO,iFAAiF,SAAS,8CAA8C,kFAAkF,SAAS,OAAO,wCAAwC,gCAAgC,kGAAkG,6BAA6B,iDAAiD,WAAW,OAAO,gDAAgD,WAAW,SAAS,gHAAgH,2GAA2G,+EAA+E,8CAA8C,+BAA+B,uHAAuH,qEAAqE,qDAAqD,qDAAqD,iOAAiO,oFAAoF,wCAAwC,0CAA0C,oFAAoF,2DAA2D,kFAAkF,oOAAoO,8HAA8H,yKAAyK,aAAa,OAAO,uDAAuD,kGAAkG,aAAa,WAAW,OAAO,oMAAoM,mCAAmC,aAAa,OAAO,2DAA2D,aAAa,8CAA8C,8CAA8C,iDAAiD,WAAW,SAAS,6BAA6B,mCAAmC,mCAAmC,OAAO,uHAAuH,sBAAsB,yBAAyB,yEAAyE,sEAAsE,4EAA4E,+EAA+E,SAAS,OAAO,+BAA+B,4DAA4D,OAAO,0DAA0D,qFAAqF,OAAO,gCAAgC,wCAAwC,OAAO,gLAAgL,8GAA8G,qBAAqB,SAAS,iFAAiF,2FAA2F,qBAAqB,SAAS,yGAAyG,iEAAiE,4BAA4B,WAAW,mFAAmF,SAAS,6DAA6D,OAAO,iiBAAiiB,sBAAsB,gCAAgC,yEAAyE,yHAAyH,2DAA2D,gCAAgC,mCAAmC,WAAW,uDAAuD,6DAA6D,0BAA0B,SAAS,yEAAyE,wEAAwE,OAAO,6IAA6I,sBAAsB,gCAAgC,yEAAyE,oEAAoE,6DAA6D,6DAA6D,0BAA0B,SAAS,8CAA8C,OAAO,mCAAmC,0DAA0D,OAAO,mCAAmC,sBAAsB,yBAAyB,yBAAyB,sHAAsH,OAAO,kEAAkE,UAAU,8FAA8F,sBAAsB,iCAAiC,+BAA+B,iBAAiB,SAAS,+BAA+B,mDAAmD,wCAAwC,0CAA0C,4CAA4C,iDAAiD,sBAAsB,kDAAkD,6CAA6C,oFAAoF,wCAAwC,+CAA+C,SAAS,gHAAgH,qDAAqD,sEAAsE,oGAAoG,sHAAsH,qHAAqH,0DAA0D,yEAAyE,yDAAyD,qEAAqE,2GAA2G,+BAA+B,6BAA6B,4BAA4B,mKAAmK,qCAAqC,WAAW,0IAA0I,kKAAkK,WAAW,0KAA0K,iFAAiF,+BAA+B,8BAA8B,eAAe,6BAA6B,aAAa,WAAW,kCAAkC,8BAA8B,WAAW,SAAS,oFAAoF,8EAA8E,iFAAiF,+EAA+E,yDAAyD,4IAA4I,mBAAmB,WAAW,2DAA2D,6OAA6O,qFAAqF,mBAAmB,WAAW,qCAAqC,2FAA2F,6FAA6F,gDAAgD,WAAW,OAAO,qFAAqF,iFAAiF,WAAW,iGAAiG,mCAAmC,sCAAsC,+BAA+B,kDAAkD,+EAA+E,wDAAwD,mCAAmC,aAAa,OAAO,+EAA+E,uDAAuD,sCAAsC,aAAa,yFAAyF,8HAA8H,iHAAiH,6BAA6B,2BAA2B,+BAA+B,kCAAkC,WAAW,OAAO,qDAAqD,kDAAkD,6BAA6B,uCAAuC,oDAAoD,yCAAyC,aAAa,OAAO,oDAAoD,8CAA8C,aAAa,iFAAiF,yDAAyD,kFAAkF,0EAA0E,+BAA+B,2BAA2B,gCAAgC,iCAAiC,6CAA6C,WAAW,8BAA8B,qgBAAqgB,EAAE,SAAS,EAAE,kJAAkJ,kCAAkC,2BAA2B,mDAAmD,qDAAqD,sCAAsC,2DAA2D,qEAAqE,aAAa,kCAAkC,wCAAwC,6DAA6D,6DAA6D,aAAa,8CAA8C,2DAA2D,2DAA2D,aAAa,+BAA+B,8BAA8B,WAAW,sCAAsC,2BAA2B,oEAAoE,gDAAgD,yCAAyC,2DAA2D,qDAAqD,2CAA2C,yCAAyC,oCAAoC,kBAAkB,OAAO,mIAAmI,0GAA0G,eAAe,aAAa,OAAO,4CAA4C,aAAa,8BAA8B,WAAW,SAAS,EAAE,mCAAmC,2DAA2D,0BAA0B,2BAA2B,+BAA+B,+DAA+D,8JAA8J,WAAW,OAAO,qDAAqD,8GAA8G,8DAA8D,+DAA+D,WAAW,2BAA2B,sDAAsD,mCAAmC,uCAAuC,0CAA0C,kDAAkD,yEAAyE,yDAAyD,4BAA4B,SAAS,qCAAqC,yIAAyI,qFAAqF,wGAAwG,mEAAmE,6BAA6B,sEAAsE,6BAA6B,6BAA6B,WAAW,OAAO,uEAAuE,6BAA6B,6BAA6B,WAAW,gCAAgC,iCAAiC,iCAAiC,2BAA2B,SAAS,OAAO,KAAK,EAAE,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,4BAA4B,iMAAiM,gLAAgL,sEAAsE,mDAAmD,sDAAsD,OAAO,4CAA4C,4FAA4F,OAAO,yCAAyC,iOAAiO,OAAO,uDAAuD,qCAAqC,4CAA4C,qEAAqE,SAAS,OAAO,mDAAmD,uIAAuI,2DAA2D,SAAS,EAAE,OAAO,MAAM,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,yHAAyH,iJAAiJ,0jCAA0jC,8BAA8B,oEAAoE,OAAO,2CAA2C,cAAc,wFAAwF,yBAAyB,wRAAwR,6EAA6E,iDAAiD,WAAW,OAAO,kFAAkF,0FAA0F,WAAW,sEAAsE,qEAAqE,wLAAwL,6LAA6L,8CAA8C,8CAA8C,aAAa,WAAW,0DAA0D,+IAA+I,8CAA8C,WAAW,OAAO,6CAA6C,WAAW,8IAA8I,yBAAyB,eAAe,OAAO,gDAAgD,WAAW,4FAA4F,yBAAyB,SAAS,sJAAsJ,8BAA8B,oEAAoE,OAAO,2CAA2C,cAAc,6FAA6F,yBAAyB,4DAA4D,0aAA0a,kEAAkE,+EAA+E,kBAAkB,0BAA0B,gCAAgC,kEAAkE,+EAA+E,kCAAkC,sDAAsD,WAAW,OAAO,qDAAqD,kEAAkE,WAAW,gBAAgB,gCAAgC,4BAA4B,qCAAqC,8BAA8B,oBAAoB,aAAa,wDAAwD,WAAW,0EAA0E,6EAA6E,+BAA+B,yBAAyB,SAAS,OAAO,oJAAoJ,gKAAgK,aAAa,iEAAiE,6DAA6D,SAAS,wIAAwI,OAAO,mDAAmD,OAAO,oFAAoF,cAAc,sDAAsD,OAAO,+GAA+G,4IAA4I,wIAAwI,sDAAsD,uFAAuF,aAAa,WAAW,0DAA0D,8BAA8B,kCAAkC,uDAAuD,+DAA+D,iGAAiG,WAAW,OAAO,6BAA6B,8CAA8C,8BAA8B,SAAS,2DAA2D,wFAAwF,kCAAkC,uBAAuB,WAAW,sGAAsG,6CAA6C,WAAW,oBAAoB,SAAS,OAAO,MAAM,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,qCAAqC,mPAAmP,8BAA8B,wCAAwC,sCAAsC,sBAAsB,mCAAmC,kGAAkG,OAAO,2JAA2J,sBAAsB,+FAA+F,2BAA2B,0EAA0E,iCAAiC,6BAA6B,wDAAwD,2BAA2B,gCAAgC,gDAAgD,yBAAyB,8BAA8B,uCAAuC,iBAAiB,sBAAsB,mCAAmC,4BAA4B,SAAS,sGAAsG,sBAAsB,gGAAgG,wFAAwF,sBAAsB,8BAA8B,SAAS,OAAO,mCAAmC,8EAA8E,gCAAgC,SAAS,qDAAqD,0BAA0B,4BAA4B,6BAA6B,gDAAgD,gDAAgD,OAAO,wLAAwL,2SAA2S,kCAAkC,sCAAsC,6FAA6F,SAAS,OAAO,sEAAsE,wCAAwC,gCAAgC,mCAAmC,mCAAmC,SAAS,+EAA+E,wCAAwC,iDAAiD,OAAO,+EAA+E,+KAA+K,6BAA6B,0hBAA0hB,4FAA4F,2DAA2D,2DAA2D,iDAAiD,yEAAyE,8DAA8D,WAAW,OAAO,+FAA+F,gDAAgD,oCAAoC,yEAAyE,WAAW,uBAAuB,wCAAwC,+BAA+B,mCAAmC,sCAAsC,kDAAkD,wBAAwB,SAAS,OAAO,KAAK,EAAE,uEAAuE,mCAAmC,mGAAmG,EAAE,uCAAuC,uDAAuD,KAAK,8DAA8D,2CAA2C,oDAAoD,0BAA0B,iEAAiE,SAAS,OAAO,8CAA8C,oDAAoD,0BAA0B,kFAAkF,2CAA2C,yDAAyD,WAAW,OAAO,mEAAmE,WAAW,SAAS,OAAO,iFAAiF,0CAA0C,SAAS,OAAO,KAAK,EAAE,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,yHAAyH,6CAA6C,+DAA+D,KAAK,wCAAwC,moBAAmoB,wHAAwH,+DAA+D,mCAAmC,sDAAsD,0CAA0C,uCAAuC,gCAAgC,kCAAkC,aAAa,sDAAsD,yCAAyC,aAAa,WAAW,yBAAyB,SAAS,sOAAsO,iFAAiF,0DAA0D,SAAS,2DAA2D,4EAA4E,2DAA2D,yCAAyC,kBAAkB,uGAAuG,SAAS,gQAAgQ,MAAM,2HAA2H,mBAAmB,sCAAsC,wCAAwC,mDAAmD,SAAS,OAAO,4BAA4B,SAAS,OAAO,oBAAoB,KAAK,0NAA0N,mCAAmC,qDAAqD,kHAAkH,gBAAgB,6QAA6Q,KAAK,wFAAwF,OAAO,mEAAmE,iDAAiD,wDAAwD,gBAAgB,08DAA08D,KAAK,+FAA+F,mCAAmC,wCAAwC,uCAAuC,qEAAqE,sEAAsE,8FAA8F,OAAO,KAAK,6EAA6E,gDAAgD,gDAAgD,sIAAsI,iDAAiD,8FAA8F,mFAAmF,2EAA2E,oGAAoG,iFAAiF,oEAAoE,kGAAkG,wEAAwE,yCAAyC,4EAA4E,QAAQ,oGAAoG,8CAA8C,oHAAoH,2EAA2E,yIAAyI,6CAA6C,oDAAoD,mDAAmD,mDAAmD,OAAO,EAAE,iDAAiD,4HAA4H,+CAA+C,wDAAwD,gBAAgB,mDAAmD,KAAK,8HAA8H,iCAAiC,iCAAiC,uDAAuD,4BAA4B,4BAA4B,oCAAoC,uBAAuB,OAAO,mDAAmD,0BAA0B,OAAO,mBAAmB,mEAAmE,kGAAkG,kJAAkJ,wDAAwD,kCAAkC,0BAA0B,2BAA2B,UAAU,0BAA0B,0BAA0B,UAAU,OAAO,OAAO,0BAA0B,uCAAuC,UAAU,0BAA0B,uDAAuD,UAAU,OAAO,2BAA2B,4CAA4C,QAAQ,yBAAyB,kCAAkC,QAAQ,wBAAwB,4CAA4C,QAAQ,0BAA0B,wBAAwB,uGAAuG,4BAA4B,+BAA+B,SAAS,OAAO,wBAAwB,yBAAyB,iGAAiG,4BAA4B,+BAA+B,SAAS,OAAO,oCAAoC,cAAc,6GAA6G,KAAK,2MAA2M,+CAA+C,mBAAmB,gSAAgS,iCAAiC,wBAAwB,OAAO,gCAAgC,8BAA8B,OAAO,+BAA+B,4BAA4B,OAAO,gCAAgC,0CAA0C,OAAO,OAAO,+BAA+B,OAAO,kCAAkC,gCAAgC,8BAA8B,SAAS,+BAA+B,8BAA8B,SAAS,OAAO,8BAA8B,8BAA8B,OAAO,+BAA+B,8BAA8B,OAAO,gBAAgB,iCAAiC,KAAK,4CAA4C,8BAA8B,kDAAkD,OAAO,2FAA2F,sBAAsB,+BAA+B,uCAAuC,+LAA+L,yBAAyB,iDAAiD,2CAA2C,gDAAgD,uBAAuB,OAAO,0EAA0E,8EAA8E,mFAAmF,OAAO,sFAAsF,sBAAsB,8CAA8C,2BAA2B,4DAA4D,0BAA0B,8EAA8E,2FAA2F,oFAAoF,yFAAyF,qCAAqC,SAAS,EAAE,2BAA2B,OAAO,yEAAyE,6EAA6E,mFAAmF,OAAO,oIAAoI,sBAAsB,8CAA8C,yEAAyE,2DAA2D,qEAAqE,yBAAyB,kDAAkD,4CAA4C,iDAAiD,uBAAuB,OAAO,oCAAoC,sBAAsB,+BAA+B,sXAAsX,mDAAmD,gCAAgC,8BAA8B,8CAA8C,wIAAwI,uFAAuF,+BAA+B,mEAAmE,2BAA2B,qFAAqF,+BAA+B,6EAA6E,qBAAqB,8BAA8B,4BAA4B,iCAAiC,gGAAgG,kCAAkC,0CAA0C,SAAS,OAAO,4DAA4D,WAAW,qHAAqH,4DAA4D,0CAA0C,aAAa,EAAE,WAAW,wHAAwH,6DAA6D,+CAA+C,aAAa,EAAE,WAAW,qGAAqG,6FAA6F,WAAW,EAAE,2FAA2F,kEAAkE,sDAAsD,gEAAgE,0DAA0D,+FAA+F,kDAAkD,qFAAqF,0CAA0C,oEAAoE,gHAAgH,4DAA4D,kHAAkH,SAAS,OAAO,4BAA4B,SAAS,0CAA0C,wCAAwC,oCAAoC,oCAAoC,wCAAwC,0CAA0C,oGAAoG,yCAAyC,4BAA4B,uCAAuC,sCAAsC,SAAS,oBAAoB,OAAO,yDAAyD,4BAA4B,kCAAkC,uBAAuB,uBAAuB,qCAAqC,2CAA2C,4DAA4D,gEAAgE,8DAA8D,oCAAoC,iEAAiE,qBAAqB,gCAAgC,oBAAoB,WAAW,OAAO,6BAA6B,gCAAgC,oBAAoB,WAAW,oCAAoC,8BAA8B,8BAA8B,SAAS,OAAO,kCAAkC,oCAAoC,gCAAgC,gCAAgC,WAAW,+BAA+B,4CAA4C,gCAAgC,gCAAgC,WAAW,OAAO,mCAAmC,gCAAgC,gCAAgC,WAAW,mCAAmC,qBAAqB,gCAAgC,oBAAoB,WAAW,OAAO,8BAA8B,gCAAgC,oBAAoB,WAAW,SAAS,oEAAoE,wBAAwB,2BAA2B,2BAA2B,2BAA2B,wBAAwB,mBAAmB,OAAO,kDAAkD,6BAA6B,6BAA6B,yCAAyC,mCAAmC,4FAA4F,qEAAqE,gGAAgG,uBAAuB,yCAAyC,SAAS,OAAO,+CAA+C,iDAAiD,sEAAsE,0DAA0D,oDAAoD,WAAW,SAAS,OAAO,iDAAiD,2CAA2C,yCAAyC,2BAA2B,wCAAwC,iCAAiC,kEAAkE,kCAAkC,2FAA2F,qDAAqD,6CAA6C,wDAAwD,6CAA6C,UAAU,kFAAkF,gDAAgD,+DAA+D,kFAAkF,wDAAwD,yDAAyD,gFAAgF,mKAAmK,mEAAmE,8GAA8G,qEAAqE,sHAAsH,mFAAmF,0CAA0C,aAAa,mCAAmC,WAAW,EAAE,yDAAyD,SAAS,EAAE,oEAAoE,gFAAgF,4BAA4B,mCAAmC,mDAAmD,+BAA+B,8BAA8B,qCAAqC,4CAA4C,mCAAmC,sEAAsE,sGAAsG,iDAAiD,2CAA2C,yDAAyD,WAAW,EAAE,SAAS,OAAO,oEAAoE,kEAAkE,8GAA8G,mBAAmB,OAAO,yBAAyB,kCAAkC,4BAA4B,iCAAiC,iBAAiB,SAAS,6BAA6B,+DAA+D,kBAAkB,6CAA6C,0IAA0I,sCAAsC,6FAA6F,4EAA4E,yEAAyE,8BAA8B,oEAAoE,iEAAiE,qEAAqE,SAAS,OAAO,sEAAsE,OAAO,+CAA+C,QAAQ,qEAAqE,sBAAsB,kCAAkC,4BAA4B,gDAAgD,kFAAkF,0BAA0B,SAAS,OAAO,6FAA6F,SAAS,qGAAqG,oCAAoC,kDAAkD,+BAA+B,iDAAiD,kCAAkC,0BAA0B,qBAAqB,8HAA8H,SAAS,yBAAyB,OAAO,KAAK,EAAE,4FAA4F,6KAA6K,eAAe,+DAA+D,MAAM,6DAA6D,+BAA+B,uBAAuB,SAAS,qBAAqB,kBAAkB,kBAAkB,sBAAsB,4CAA4C,SAAS,OAAO,+BAA+B,oCAAoC,2CAA2C,uBAAuB,uBAAuB,oBAAoB,WAAW,SAAS,kBAAkB,+EAA+E,OAAO,8KAA8K,gBAAgB,oDAAoD,MAAM,mEAAmE,MAAM,gFAAgF,gCAAgC,gCAAgC,6BAA6B,mDAAmD,mBAAmB,0CAA0C,SAAS,OAAO,+BAA+B,oCAAoC,6CAA6C,yEAAyE,oCAAoC,8BAA8B,kCAAkC,aAAa,WAAW,SAAS,+BAA+B,oDAAoD,mBAAmB,mBAAmB,SAAS,kBAAkB,uCAAuC,OAAO,MAAM,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,2EAA2E,iCAAiC,mGAAmG,iDAAiD,sCAAsC,4BAA4B,mBAAmB,wFAAwF,SAAS,qBAAqB,OAAO,0CAA0C,4BAA4B,mBAAmB,qEAAqE,4DAA4D,wGAAwG,4EAA4E,qCAAqC,yCAAyC,sCAAsC,WAAW,oCAAoC,mCAAmC,WAAW,sCAAsC,mCAAmC,WAAW,+NAA+N,mDAAmD,SAAS,qBAAqB,OAAO,mCAAmC,4BAA4B,0DAA0D,+DAA+D,gBAAgB,mHAAmH,OAAO,4BAA4B,4BAA4B,uIAAuI,OAAO,oCAAoC,4BAA4B,mKAAmK,gBAAgB,qIAAqI,OAAO,yBAAyB,sHAAsH,0BAA0B,sDAAsD,0DAA0D,0BAA0B,yCAAyC,uCAAuC,6CAA6C,qBAAqB,+BAA+B,+BAA+B,uBAAuB,SAAS,OAAO,KAAK,EAAE,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,+CAA+C,6CAA6C,uWAAuW,kDAAkD,wBAAwB,sBAAsB,0BAA0B,mCAAmC,qCAAqC,4BAA4B,gFAAgF,kCAAkC,oCAAoC,WAAW,iCAAiC,uCAAuC,WAAW,SAAS,kCAAkC,mBAAmB,0GAA0G,oCAAoC,iDAAiD,yDAAyD,6CAA6C,WAAW,sCAAsC,6CAA6C,WAAW,OAAO,2RAA2R,WAAW,SAAS,4CAA4C,+CAA+C,gGAAgG,iCAAiC,SAAS,kDAAkD,6DAA6D,0BAA0B,2BAA2B,uBAAuB,WAAW,oCAAoC,2DAA2D,sCAAsC,yGAAyG,yBAAyB,qDAAqD,eAAe,OAAO,mDAAmD,eAAe,sCAAsC,uCAAuC,qDAAqD,eAAe,aAAa,OAAO,mFAAmF,qCAAqC,4IAA4I,6BAA6B,yDAAyD,mBAAmB,OAAO,4DAA4D,mBAAmB,iBAAiB,eAAe,OAAO,qDAAqD,qRAAqR,sIAAsI,mBAAmB,iBAAiB,yDAAyD,mBAAmB,OAAO,uDAAuD,yDAAyD,mBAAmB,iBAAiB,OAAO,wFAAwF,iBAAiB,uCAAuC,eAAe,aAAa,WAAW,iDAAiD,kEAAkE,WAAW,8EAA8E,0BAA0B,qBAAqB,SAAS,oGAAoG,mFAAmF,+EAA+E,gFAAgF,SAAS,gGAAgG,sFAAsF,+EAA+E,wEAAwE,gDAAgD,4BAA4B,yBAAyB,uBAAuB,WAAW,kCAAkC,yDAAyD,oCAAoC,qGAAqG,kCAAkC,mDAAmD,qCAAqC,aAAa,WAAW,OAAO,iFAAiF,oCAAoC,2FAA2F,iIAAiI,eAAe,OAAO,oFAAoF,eAAe,qCAAqC,aAAa,WAAW,SAAS,uBAAuB,sBAAsB,OAAO,KAAK,EAAE,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,wHAAwH,mCAAmC,yNAAyN,+BAA+B,0BAA0B,+FAA+F,KAAK,+BAA+B,0BAA0B,+FAA+F,KAAK,mDAAmD,yCAAyC,4BAA4B,gIAAgI,OAAO,gHAAgH,4BAA4B,gBAAgB,6CAA6C,OAAO,4BAA4B,wDAAwD,OAAO,oCAAoC,4BAA4B,gBAAgB,2FAA2F,OAAO,kCAAkC,4BAA4B,gCAAgC,kCAAkC,uCAAuC,+BAA+B,qBAAqB,qBAAqB,wCAAwC,6BAA6B,sFAAsF,wBAAwB,iBAAiB,SAAS,2DAA2D,yGAAyG,2DAA2D,iQAAiQ,oEAAoE,+DAA+D,WAAW,gDAAgD,gEAAgE,WAAW,oCAAoC,8DAA8D,WAAW,iDAAiD,iEAAiE,WAAW,8CAA8C,4EAA4E,wEAAwE,SAAS,uEAAuE,OAAO,KAAK,EAAE,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,6CAA6C,uCAAuC,kJAAkJ,gCAAgC,2CAA2C,KAAK,4HAA4H,wBAAwB,wBAAwB,OAAO,yDAAyD,yBAAyB,yBAAyB,8BAA8B,wDAAwD,8BAA8B,8BAA8B,qCAAqC,qCAAqC,OAAO,OAAO,gEAAgE,qCAAqC,qCAAqC,+BAA+B,+BAA+B,OAAO,gBAAgB,6EAA6E,KAAK,uDAAuD,wBAAwB,kCAAkC,4BAA4B,kEAAkE,yCAAyC,+BAA+B,qDAAqD,sCAAsC,qBAAqB,2BAA2B,oBAAoB,sCAAsC,uDAAuD,SAAS,OAAO,oDAAoD,uBAAuB,qCAAqC,wCAAwC,sCAAsC,oBAAoB,qDAAqD,SAAS,2KAA2K,sJAAsJ,oEAAoE,2CAA2C,gKAAgK,wFAAwF,iFAAiF,2FAA2F,mFAAmF,4BAA4B,kCAAkC,WAAW,qFAAqF,8BAA8B,gCAAgC,WAAW,SAAS,0BAA0B,2CAA2C,yCAAyC,oCAAoC,0OAA0O,4HAA4H,4DAA4D,iCAAiC,0BAA0B,SAAS,oCAAoC,oDAAoD,SAAS,+EAA+E,yCAAyC,yBAAyB,OAAO,OAAO,+BAA+B,2CAA2C,SAAS,qBAAqB,0BAA0B,uBAAuB,SAAS,OAAO,2BAA2B,4BAA4B,8BAA8B,OAAO,0CAA0C,4BAA4B,2BAA2B,0CAA0C,uHAAuH,SAAS,yBAAyB,OAAO,+CAA+C,sBAAsB,wBAAwB,uBAAuB,SAAS,8BAA8B,sCAAsC,+BAA+B,oEAAoE,SAAS,OAAO,oEAAoE,SAAS,yBAAyB,OAAO,mCAAmC,wCAAwC,+DAA+D,OAAO,mCAAmC,wCAAwC,+DAA+D,OAAO,mCAAmC,4BAA4B,iBAAiB,+BAA+B,mBAAmB,mCAAmC,SAAS,OAAO,mCAAmC,mBAAmB,SAAS,kBAAkB,YAAY,OAAO,4BAA4B,4BAA4B,mDAAmD,OAAO,oCAAoC,4BAA4B,gBAAgB,6CAA6C,OAAO,KAAK,EAAE,MAAM,KAAK,GAAG,uCAAuC,eAAe,oGAAoG,gCAAgC,4LAA4L,8TAA8T,khBAAkhB,OAAO,6FAA6F,sDAAsD,qDAAqD,qDAAqD,KAAK,+UAA+U,+BAA+B,oOAAoO,qDAAqD,2GAA2G,kBAAkB,8EAA8E,6GAA6G,SAAS,QAAQ,oQAAoQ,yDAAyD,yDAAyD,yCAAyC,sCAAsC,SAAS,OAAO,2DAA2D,yCAAyC,oVAAoV,SAAS,OAAO,6DAA6D,2CAA2C,0CAA0C,WAAW,SAAS,OAAO,sBAAsB,KAAK,uDAAuD,cAAc,yJAAyJ,KAAK,8CAA8C,wDAAwD,0DAA0D,2DAA2D,KAAK,uCAAuC,oDAAoD,iDAAiD,mDAAmD,2BAA2B,oBAAoB,oBAAoB,iBAAiB,kBAAkB,oBAAoB,mBAAmB,uBAAuB,sBAAsB,6BAA6B,+BAA+B,sBAAsB,EAAE,sIAAsI,sSAAsS,4EAA4E,0KAA0K,OAAO,EAAE,sBAAsB,KAAK,yDAAyD,kCAAkC,8BAA8B,4GAA4G,4BAA4B,8BAA8B,4DAA4D,+BAA+B,mCAAmC,4DAA4D,aAAa,WAAW,EAAE,SAAS,QAAQ,sIAAsI,yDAAyD,KAAK,2CAA2C,oCAAoC,eAAe,OAAO,4CAA4C,oBAAoB,gDAAgD,qCAAqC,OAAO,6BAA6B,KAAK,cAAc,8CAA8C,uCAAuC,+CAA+C,SAAS,wBAAwB,sFAAsF,SAAS,oCAAoC,+GAA+G,SAAS,kDAAkD,2RAA2R,4DAA4D,qCAAqC,2BAA2B,WAAW,SAAS,sBAAsB,OAAO,4CAA4C,oCAAoC,+BAA+B,iBAAiB,SAAS,gDAAgD,oDAAoD,oCAAoC,sDAAsD,yCAAyC,WAAW,OAAO,6CAA6C,WAAW,SAAS,EAAE,0CAA0C,wBAAwB,oCAAoC,SAAS,EAAE,iZAAiZ,iCAAiC,OAAO,4DAA4D,wCAAwC,gCAAgC,2IAA2I,iBAAiB,SAAS,iEAAiE,EAAE,wDAAwD,EAAE,sEAAsE,wDAAwD,UAAU,gDAAgD,OAAO,+DAA+D,wCAAwC,gCAAgC,iIAAiI,iBAAiB,SAAS,6CAA6C,yCAAyC,mDAAmD,qBAAqB,iBAAiB,SAAS,mDAAmD,OAAO,MAAM,IAAI,KAAK,GAAG,uCAAuC,eAAe,0JAA0J,sCAAsC,8JAA8J,gJAAgJ,uCAAuC,kBAAkB,EAAE,0FAA0F,OAAO,+CAA+C,yBAAyB,+DAA+D,oLAAoL,yBAAyB,oDAAoD,QAAQ,qFAAqF,0FAA0F,MAAM,8DAA8D,OAAO,cAAc,aAAa,qCAAqC,SAAS,4EAA4E,aAAa,qGAAqG,iHAAiH,MAAM,gEAAgE,OAAO,cAAc,aAAa,iCAAiC,SAAS,mHAAmH,MAAM,uaAAua,OAAO,0NAA0N,EAAE,2FAA2F,OAAO,8FAA8F,OAAO,yJAAyJ,IAAI,KAAK,EAAE,UAAU,uCAAuC,eAAe,sCAAsC,kCAAkC,mEAAmE,8BAA8B,6CAA6C,8MAA8M,mCAAmC,kFAAkF,OAAO,uEAAuE,sBAAsB,oCAAoC,wBAAwB,wCAAwC,sBAAsB,mDAAmD,yGAAyG,mEAAmE,SAAS,mDAAmD,yGAAyG,mEAAmE,SAAS,uCAAuC,qCAAqC,OAAO,iCAAiC,sBAAsB,oCAAoC,8MAA8M,OAAO,0DAA0D,sBAAsB,iCAAiC,6CAA6C,8CAA8C,2EAA2E,SAAS,6CAA6C,OAAO,6KAA6K,sBAAsB,gMAAgM,oDAAoD,sCAAsC,0CAA0C,2CAA2C,SAAS,kCAAkC,gDAAgD,iEAAiE,wHAAwH,4CAA4C,WAAW,qDAAqD,SAAS,gDAAgD,iEAAiE,sEAAsE,4CAA4C,SAAS,mDAAmD,OAAO,wDAAwD,oGAAoG,OAAO,0CAA0C,sBAAsB,kBAAkB,0GAA0G,qCAAqC,uEAAuE,2CAA2C,qDAAqD,wCAAwC,SAAS,2BAA2B,oBAAoB,SAAS,OAAO,qDAAqD,SAAS,uBAAuB,OAAO,iCAAiC,2BAA2B,OAAO,KAAK,EAAE,oFAAoF,MAAM,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,2BAA2B,qCAAqC,sDAAsD,MAAM,sDAAsD,uCAAuC,sBAAsB,8BAA8B,6BAA6B,8BAA8B,qCAAqC,6CAA6C,oCAAoC,gFAAgF,SAAS,4DAA4D,sBAAsB,uCAAuC,sCAAsC,kEAAkE,4BAA4B,qBAAqB,aAAa,4DAA4D,mHAAmH,+BAA+B,aAAa,WAAW,EAAE,SAAS,0CAA0C,kCAAkC,oEAAoE,0DAA0D,qSAAqS,sDAAsD,qCAAqC,qFAAqF,aAAa,yGAAyG,oEAAoE,4EAA4E,oEAAoE,wDAAwD,8DAA8D,yBAAyB,iBAAiB,qEAAqE,mEAAmE,4CAA4C,8CAA8C,iBAAiB,sBAAsB,iDAAiD,iBAAiB,OAAO,iDAAiD,iBAAiB,eAAe,EAAE,aAAa,WAAW,EAAE,kEAAkE,2FAA2F,6CAA6C,6CAA6C,yEAAyE,yEAAyE,WAAW,EAAE,WAAW,OAAO,kEAAkE,0DAA0D,0EAA0E,oEAAoE,wDAAwD,8DAA8D,yBAAyB,iBAAiB,wCAAwC,iCAAiC,iBAAiB,2BAA2B,iCAAiC,iBAAiB,wCAAwC,iCAAiC,iBAAiB,2BAA2B,iCAAiC,iBAAiB,eAAe,EAAE,aAAa,WAAW,EAAE,SAAS,+HAA+H,OAAO,iCAAiC,qBAAqB,sBAAsB,wCAAwC,kCAAkC,8GAA8G,SAAS,OAAO,6MAA6M,+HAA+H,SAAS,0BAA0B,OAAO,+FAA+F,mCAAmC,gIAAgI,SAAS,OAAO,wDAAwD,uFAAuF,OAAO,wDAAwD,gKAAgK,6BAA6B,oDAAoD,kBAAkB,mCAAmC,kCAAkC,sEAAsE,mCAAmC,SAAS,yEAAyE,iCAAiC,OAAO,0CAA0C,sBAAsB,6CAA6C,iEAAiE,2FAA2F,yDAAyD,OAAO,yCAAyC,iEAAiE,OAAO,KAAK,EAAE,+EAA+E,MAAM,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,4DAA4D,kDAAkD,0CAA0C,sBAAsB,8BAA8B,kCAAkC,iRAAiR,6CAA6C,6CAA6C,6CAA6C,0DAA0D,WAAW,uCAAuC,+DAA+D,WAAW,SAAS,2CAA2C,gCAAgC,SAAS,gDAAgD,2DAA2D,SAAS,2CAA2C,gCAAgC,SAAS,gDAAgD,2DAA2D,SAAS,kCAAkC,mBAAmB,wCAAwC,qBAAqB,WAAW,SAAS,OAAO,+FAA+F,sBAAsB,8BAA8B,kCAAkC,6XAA6X,yCAAyC,yCAAyC,uLAAuL,0FAA0F,wCAAwC,+KAA+K,oCAAoC,iCAAiC,0BAA0B,8BAA8B,0BAA0B,SAAS,OAAO,4BAA4B,0BAA0B,SAAS,OAAO,yCAAyC,sBAAsB,6CAA6C,+CAA+C,8DAA8D,OAAO,KAAK,EAAE,IAAI,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,2BAA2B,8DAA8D,2DAA2D,MAAM,iDAAiD,uCAAuC,sBAAsB,8BAA8B,kCAAkC,6BAA6B,8BAA8B,qCAAqC,0DAA0D,6CAA6C,kCAAkC,gFAAgF,SAAS,kDAAkD,sBAAsB,6BAA6B,uCAAuC,sCAAsC,kEAAkE,4BAA4B,qBAAqB,aAAa,4DAA4D,mHAAmH,+BAA+B,aAAa,WAAW,EAAE,SAAS,0CAA0C,kCAAkC,oEAAoE,0DAA0D,qSAAqS,4EAA4E,sDAAsD,yCAAyC,eAAe,sEAAsE,iDAAiD,wDAAwD,8DAA8D,yBAAyB,iBAAiB,qDAAqD,4CAA4C,sCAAsC,iBAAiB,OAAO,qJAAqJ,iBAAiB,eAAe,EAAE,aAAa,WAAW,EAAE,kEAAkE,oDAAoD,oDAAoD,yEAAyE,yEAAyE,WAAW,EAAE,WAAW,OAAO,kEAAkE,0DAA0D,0EAA0E,oEAAoE,wDAAwD,8DAA8D,yBAAyB,iBAAiB,wCAAwC,iCAAiC,iBAAiB,2BAA2B,iCAAiC,iBAAiB,wCAAwC,iCAAiC,iBAAiB,2BAA2B,iCAAiC,iBAAiB,yFAAyF,wCAAwC,iBAAiB,eAAe,EAAE,aAAa,WAAW,EAAE,SAAS,2DAA2D,yDAAyD,kCAAkC,gDAAgD,yEAAyE,yEAAyE,WAAW,OAAO,uBAAuB,wBAAwB,WAAW,SAAS,OAAO,+BAA+B,sBAAsB,8BAA8B,kCAAkC,mCAAmC,iEAAiE,yFAAyF,mCAAmC,2HAA2H,SAAS,+KAA+K,oCAAoC,iCAAiC,0BAA0B,8BAA8B,0BAA0B,SAAS,OAAO,4BAA4B,0BAA0B,SAAS,OAAO,yCAAyC,6CAA6C,gEAAgE,OAAO,8FAA8F,uFAAuF,OAAO,yCAAyC,6DAA6D,OAAO,0CAA0C,sBAAsB,2BAA2B,kBAAkB,+BAA+B,8CAA8C,kBAAkB,8BAA8B,kCAAkC,kCAAkC,+DAA+D,qDAAqD,4BAA4B,WAAW,OAAO,sCAAsC,wGAAwG,WAAW,SAAS,OAAO,yGAAyG,iDAAiD,yEAAyE,mCAAmC,gCAAgC,aAAa,qCAAqC,wDAAwD,aAAa,OAAO,gJAAgJ,aAAa,WAAW,6CAA6C,2EAA2E,oCAAoC,6BAA6B,aAAa,qCAAqC,qDAAqD,aAAa,OAAO,6IAA6I,aAAa,WAAW,OAAO,iEAAiE,uCAAuC,0GAA0G,WAAW,SAAS,qBAAqB,OAAO,0CAA0C,sBAAsB,oEAAoE,kCAAkC,kCAAkC,oCAAoC,sFAAsF,SAAS,OAAO,8DAA8D,wFAAwF,SAAS,qBAAqB,OAAO,KAAK,EAAE,yFAAyF,MAAM,KAAK,GAAG,uCAAuC,eAAe,sCAAsC,kCAAkC,+CAA+C,2BAA2B,uLAAuL,qFAAqF,wCAAwC,scAAsc,uBAAuB,+JAA+J,uBAAuB,SAAS,OAAO,MAAM,qCAAqC,yEAAyE,KAAK,gDAAgD,wDAAwD,2GAA2G,8GAA8G,iHAAiH,qEAAqE,gBAAgB,qGAAqG,KAAK,uDAAuD,mCAAmC,gBAAgB,+IAA+I,OAAO,gBAAgB,mEAAmE,KAAK,4DAA4D,2CAA2C,gBAAgB,2EAA2E,OAAO,uCAAuC,gBAAgB,4DAA4D,OAAO,gBAAgB,sDAAsD,KAAK,6HAA6H,qzCAAqzC,0TAA0T,4BAA4B,gFAAgF,8BAA8B,YAAY,mBAAmB,wBAAwB,qCAAqC,kCAAkC,8CAA8C,iBAAiB,gBAAgB,OAAO,yEAAyE,wFAAwF,6CAA6C,qHAAqH,0DAA0D,kFAAkF,mFAAmF,iDAAiD,2CAA2C,0CAA0C,SAAS,+CAA+C,yCAAyC,0CAA0C,SAAS,iDAAiD,2CAA2C,0CAA0C,SAAS,+CAA+C,yCAAyC,0CAA0C,SAAS,OAAO,mFAAmF,KAAK,iHAAiH,8EAA8E,4DAA4D,uCAAuC,KAAK,4CAA4C,yCAAyC,wBAAwB,OAAO,wBAAwB,sBAAsB,OAAO,uBAAuB,KAAK,wDAAwD,kCAAkC,2BAA2B,qCAAqC,yBAAyB,iBAAiB,OAAO,+CAA+C,sBAAsB,SAAS,OAAO,OAAO,mDAAmD,OAAO,KAAK,6EAA6E,0CAA0C,uCAAuC,OAAO,sCAAsC,iCAAiC,OAAO,KAAK,uCAAuC,0BAA0B,wDAAwD,+BAA+B,0CAA0C,4CAA4C,gDAAgD,4CAA4C,sGAAsG,8EAA8E,iCAAiC,8CAA8C,QAAQ,OAAO,oCAAoC,uEAAuE,0BAA0B,mDAAmD,uDAAuD,uBAAuB,0BAA0B,SAAS,6HAA6H,wLAAwL,+BAA+B,4CAA4C,oDAAoD,oDAAoD,oDAAoD,gGAAgG,mFAAmF,OAAO,KAAK,mEAAmE,0BAA0B,wFAAwF,0FAA0F,oCAAoC,wEAAwE,sEAAsE,wBAAwB,qBAAqB,OAAO,OAAO,kGAAkG,iCAAiC,iBAAiB,SAAS,0BAA0B,8DAA8D,qDAAqD,yBAAyB,gBAAgB,OAAO,4DAA4D,uDAAuD,SAAS,0BAA0B,qBAAqB,OAAO,KAAK,oCAAoC,iDAAiD,KAAK,4DAA4D,iCAAiC,sBAAsB,8BAA8B,kCAAkC,+FAA+F,iCAAiC,8CAA8C,+CAA+C,2DAA2D,wGAAwG,uHAAuH,OAAO,wCAAwC,sBAAsB,6BAA6B,2CAA2C,2CAA2C,6EAA6E,qDAAqD,0DAA0D,oEAAoE,sDAAsD,4DAA4D,uBAAuB,eAAe,2CAA2C,yCAAyC,aAAa,EAAE,WAAW,SAAS,EAAE,gEAAgE,8DAA8D,6HAA6H,OAAO,iCAAiC,0CAA0C,wGAAwG,kIAAkI,OAAO,yCAAyC,sBAAsB,sEAAsE,gHAAgH,OAAO,wDAAwD,uFAAuF,OAAO,wBAAwB,mCAAmC,oBAAoB,SAAS,OAAO,mCAAmC,SAAS,OAAO,kMAAkM,sBAAsB,gFAAgF,yGAAyG,gFAAgF,4GAA4G,kEAAkE,kEAAkE,8DAA8D,oEAAoE,mOAAmO,gHAAgH,OAAO,2FAA2F,sBAAsB,qOAAqO,wEAAwE,qEAAqE,OAAO,yCAAyC,kEAAkE,mIAAmI,iEAAiE,8IAA8I,OAAO,uDAAuD,sBAAsB,+BAA+B,mBAAmB,kCAAkC,4IAA4I,iCAAiC,kDAAkD,SAAS,gDAAgD,OAAO,8DAA8D,sBAAsB,gEAAgE,gBAAgB,uKAAuK,OAAO,yDAAyD,uFAAuF,OAAO,sCAAsC,sBAAsB,yBAAyB,yBAAyB,8JAA8J,OAAO,2BAA2B,sBAAsB,8BAA8B,0CAA0C,kCAAkC,0DAA0D,6BAA6B,2BAA2B,0HAA0H,qGAAqG,wGAAwG,8FAA8F,2DAA2D,uGAAuG,6FAA6F,uDAAuD,+GAA+G,uEAAuE,eAAe,uCAAuC,2GAA2G,yCAAyC,mDAAmD,gEAAgE,yDAAyD,yUAAyU,iBAAiB,2CAA2C,4CAA4C,8CAA8C,yDAAyD,eAAe,aAAa,WAAW,EAAE,gCAAgC,gCAAgC,WAAW,SAAS,OAAO,KAAK,EAAE,2FAA2F,MAAM,KAAK,GAAG,uCAAuC,2CAA2C,4BAA4B,kEAAkE,sCAAsC,kCAAkC,gBAAgB,eAAe,sFAAsF,GAAG,8DAA8D,GAAG,8DAA8D,GAAG,2DAA2D,GAAG,mDAAmD,GAAG,8CAA8C,GAAG,+CAA+C,GAAG,iDAAiD,GAAG,kDAAkD,OAAO,2BAA2B,wCAAwC,8zBAA8zB,sZAAsZ,OAAO,eAAe,8BAA8B,MAAM,0CAA0C,8BAA8B,sBAAsB,kKAAkK,SAAS,sDAAsD,OAAO,sDAAsD,sDAAsD,sBAAsB,SAAS,uEAAuE,wDAAwD,SAAS,sBAAsB,OAAO,oDAAoD,sBAAsB,sDAAsD,sBAAsB,SAAS,4CAA4C,+BAA+B,SAAS,mEAAmE,oDAAoD,SAAS,sBAAsB,OAAO,yCAAyC,sBAAsB,sFAAsF,wFAAwF,SAAS,iDAAiD,OAAO,wCAAwC,sBAAsB,6BAA6B,kJAAkJ,sEAAsE,8DAA8D,kDAAkD,0CAA0C,0CAA0C,2DAA2D,eAAe,kDAAkD,aAAa,WAAW,MAAM,kEAAkE,+DAA+D,SAAS,OAAO,8BAA8B,6BAA6B,SAAS,gFAAgF,qCAAqC,uEAAuE,kFAAkF,wDAAwD,sEAAsE,4CAA4C,4CAA4C,6DAA6D,iBAAiB,oDAAoD,uCAAuC,4NAA4N,0GAA0G,iBAAiB,eAAe,aAAa,MAAM,WAAW,OAAO,+GAA+G,WAAW,oDAAoD,SAAS,MAAM,sFAAsF,2DAA2D,SAAS,oCAAoC,0DAA0D,SAAS,+GAA+G,wDAAwD,OAAO,oCAAoC,sBAAsB,2BAA2B,iCAAiC,yGAAyG,8DAA8D,kDAAkD,0CAA0C,0CAA0C,2DAA2D,eAAe,sFAAsF,aAAa,WAAW,MAAM,SAAS,kEAAkE,mCAAmC,kFAAkF,wDAAwD,sEAAsE,4CAA4C,4CAA4C,6DAA6D,iBAAiB,wFAAwF,eAAe,aAAa,MAAM,WAAW,OAAO,+FAA+F,WAAW,gDAAgD,SAAS,MAAM,OAAO,+BAA+B,sBAAsB,wBAAwB,uHAAuH,0HAA0H,6HAA6H,4FAA4F,oCAAoC,wBAAwB,yBAAyB,8FAA8F,kJAAkJ,sDAAsD,yEAAyE,kFAAkF,oFAAoF,SAAS,OAAO,+HAA+H,8IAA8I,wEAAwE,sFAAsF,sFAAsF,yFAAyF,4DAA4D,yFAAyF,kFAAkF,yEAAyE,wCAAwC,+DAA+D,4HAA4H,sGAAsG,gJAAgJ,+EAA+E,mCAAmC,SAAS,kGAAkG,oHAAoH,wBAAwB,iBAAiB,eAAe,sBAAsB,aAAa,4HAA4H,yLAAyL,oBAAoB,aAAa,OAAO,6EAA6E,+DAA+D,kDAAkD,8GAA8G,yIAAyI,+HAA+H,qFAAqF,aAAa,WAAW,SAAS,2BAA2B,oGAAoG,2DAA2D,sCAAsC,SAAS,OAAO,2DAA2D,SAAS,mGAAmG,4DAA4D,sEAAsE,0BAA0B,8JAA8J,WAAW,uBAAuB,qCAAqC,WAAW,oFAAoF,SAAS,oFAAoF,2DAA2D,SAAS,0IAA0I,gJAAgJ,0BAA0B,qBAAqB,iEAAiE,wIAAwI,kBAAkB,WAAW,mCAAmC,SAAS,uHAAuH,sDAAsD,wPAAwP,+CAA+C,mFAAmF,WAAW,OAAO,+CAA+C,oFAAoF,WAAW,SAAS,2BAA2B,2EAA2E,OAAO,kFAAkF,sBAAsB,mHAAmH,qEAAqE,4DAA4D,0CAA0C,SAAS,sEAAsE,4EAA4E,SAAS,uBAAuB,OAAO,4GAA4G,4DAA4D,0CAA0C,2FAA2F,yBAAyB,uDAAuD,SAAS,6BAA6B,OAAO,yCAAyC,sBAAsB,kCAAkC,2DAA2D,OAAO,+DAA+D,sBAAsB,0BAA0B,gEAAgE,wDAAwD,SAAS,gCAAgC,yCAAyC,oGAAoG,WAAW,0DAA0D,iEAAiE,WAAW,SAAS,gCAAgC,6EAA6E,oCAAoC,mDAAmD,qDAAqD,WAAW,qDAAqD,mDAAmD,SAAS,OAAO,yCAAyC,0EAA0E,OAAO,0CAA0C,sBAAsB,sEAAsE,uFAAuF,sCAAsC,qGAAqG,OAAO,mCAAmC,sBAAsB,yDAAyD,uDAAuD,SAAS,2DAA2D,+CAA+C,SAAS,uGAAuG,+BAA+B,SAAS,wEAAwE,uBAAuB,SAAS,gJAAgJ,iKAAiK,+CAA+C,SAAS,qFAAqF,OAAO,KAAK,EAAE,2EAA2E,MAAM,KAAK,EAAE,QAAQ,EAAE,GAAG,WAAW,EAAE,C;;;;;;;ACAn/zY,gIAAgI,2DAA2D,eAAe,kBAAkB,4BAA4B,kBAAkB,4CAA4C,kBAAkB,MAAM,iCAAiC,6BAA6B,WAAW,wBAAwB,wDAAwD,kBAAkB,sDAAsD,kBAAkB,oKAAoK,UAAU,4EAA4E,yDAAyD,kBAAkB,oBAAoB,qEAAqE,gBAAgB,kBAAkB,6BAA6B,gBAAgB,6CAA6C,gBAAgB,iBAAiB,kBAAkB,mBAAmB,2BAA2B,EAAE,kBAAkB,mBAAmB,8BAA8B,EAAE,gBAAgB,KAAK,EAAE,EAAE,iBAAiB,eAAe,SAAS,gBAAgB,uBAAuB,cAAc,+BAA+B,kBAAkB,qCAAqC,YAAY,WAAW,EAAE,wCAAwC,IAAI,SAAS,cAAc,uCAAuC,kBAAkB,sBAAsB,WAAW,EAAE,qBAAqB,kCAAkC,oCAAoC,iBAAiB,cAAc,gBAAgB,gDAAgD,YAAY,EAAE,qCAAqC,IAAI,SAAS,aAAa,YAAY,cAAc,yBAAyB,wCAAwC,gBAAgB,WAAW,oHAAoH,sCAAsC,aAAa,cAAc,6BAA6B,wCAAwC,kBAAkB,wFAAwF,4CAA4C,uFAAuF,gBAAgB,wCAAwC,yGAAyG,2EAA2E,oIAAoI,uCAAuC,0RAA0R,gBAAgB,yDAAyD,gBAAgB,kCAAkC,kBAAkB,mBAAmB,oDAAoD,4BAA4B,kBAAkB,YAAY,gDAAgD,gBAAgB,0DAA0D,4CAA4C,uDAAuD,gEAAgE,4DAA4D,uDAAuD,cAAc,iBAAiB,oBAAoB,OAAO,oEAAoE,KAAK,OAAO,uEAAuE,cAAc,eAAe,gBAAgB,uCAAuC,oBAAoB,IAAI,qCAAqC,OAAO,qBAAqB,kBAAkB,OAAO,mBAAmB,gBAAgB,iDAAiD,kBAAkB,UAAU,wCAAwC,0BAA0B,kBAAkB,UAAU,wCAAwC,mCAAmC,gBAAgB,uCAAuC,gBAAgB,uCAAuC,aAAa,mEAAmE,aAAa,oGAAoG,aAAa,uEAAuE,gBAAgB,yCAAyC,6DAA6D,aAAa,kCAAkC,yBAAyB,gBAAgB,oCAAoC,8DAA8D,iDAAiD,0BAA0B,qBAAqB,iBAAiB,WAAW,2BAA2B,QAAQ,WAAW,2EAA2E,4DAA4D,aAAa,wBAAwB,2BAA2B,6GAA6G,gBAAgB,kGAAkG,cAAc,2BAA2B,qCAAqC,OAAO,yBAAyB,yBAAyB,oCAAoC,mBAAmB,qBAAqB,kBAAkB,cAAc,sDAAsD,0BAA0B,KAAK,8DAA8D,yBAAyB,SAAS,gBAAgB,2BAA2B,cAAc,qBAAqB,wBAAwB,0CAA0C,aAAa,gBAAgB,QAAQ,yBAAyB,mGAAmG,6CAA6C,IAAI,cAAc,kBAAkB,oBAAoB,gHAAgH,qBAAqB,cAAc,sEAAsE,cAAc,uEAAuE,gBAAgB,gBAAgB,oBAAoB,cAAc,wBAAwB,cAAc,mDAAmD,cAAc,yBAAyB,cAAc,0DAA0D,cAAc,yBAAyB,cAAc,yBAAyB,cAAc,qGAAqG,iBAAiB,cAAc,+DAA+D,iBAAiB,kBAAkB,kBAAkB,uEAAuE,gBAAgB,wCAAwC,4IAA4I,+BAA+B,yDAAyD,OAAO,iBAAiB,gBAAgB,YAAY,MAAM,mCAAmC,8FAA8F,sBAAsB,GAAG,iBAAiB,+BAA+B,2DAA2D,0IAA0I,kDAAkD,uFAAuF,wBAAwB,mBAAmB,KAAK,mBAAmB,mEAAmE,SAAS,eAAe,yBAAyB,6BAA6B,WAAW,6CAA6C,SAAS,kDAAkD,kBAAkB,uVAAuV,aAAa,oBAAoB,iBAAiB,2KAA2K,oBAAoB,6KAA6K,QAAQ,qCAAqC,2CAA2C,OAAO,oBAAoB,iBAAiB,qIAAqI,2DAA2D,IAAI,EAAE,QAAQ,0EAA0E,KAAK,oBAAoB,+DAA+D,kHAAkH,oBAAoB,sJAAsJ,mHAAmH,wDAAwD,qBAAqB,EAAE,QAAQ,sDAAsD,oEAAoE,OAAO,oBAAoB,iBAAiB,2CAA2C,uBAAuB,wFAAwF,6DAA6D,IAAI,EAAE,QAAQ,sDAAsD,kDAAkD,OAAO,oBAAoB,oCAAoC,iCAAiC,6DAA6D,GAAG,EAAE,kBAAkB,OAAO,wBAAwB,4CAA4C,sEAAsE,sBAAsB,iCAAiC,sBAAsB,oBAAoB,2CAA2C,EAAE,yIAAyI,aAAa,gBAAgB,wIAAwI,mBAAmB,2CAA2C,oBAAoB,SAAS,8CAA8C,0DAA0D,mBAAmB,6BAA6B,qCAAqC,iEAAiE,4EAA4E,MAAM,6DAA6D,kBAAkB,iEAAiE,wBAAwB,uDAAuD,0CAA0C,aAAa,WAAW,iBAAiB,+EAA+E,2BAA2B,2CAA2C,wBAAwB,mEAAmE,+BAA+B,8FAA8F,4BAA4B,4CAA4C,uBAAuB,wEAAwE,gCAAgC,gDAAgD,YAAY,4BAA4B,+CAA+C,+BAA+B,iCAAiC,8BAA8B,gCAAgC,kBAAkB,cAAc,oBAAoB,wBAAwB,wHAAwH,qBAAqB,uDAAuD,oBAAoB,YAAY,0BAA0B,EAAE,iDAAiD,IAAI,SAAS,uBAAuB,WAAW,IAAI,8LAA8L,sBAAsB,4BAA4B,oBAAoB,SAAS,UAAU,WAAW,sBAAsB,4BAA4B,oCAAoC,qBAAqB,8DAA8D,0DAA0D,WAAW,UAAU,mDAAmD,2BAA2B,kCAAkC,2CAA2C,2BAA2B,yEAAyE,uMAAuM,sBAAsB,oGAAoG,kBAAkB,kCAAkC,qBAAqB,2EAA2E,WAAW,UAAU,uCAAuC,2BAA2B,WAAW,sBAAsB,sGAAsG,kBAAkB,gBAAgB,+BAA+B,uCAAuC,+BAA+B,UAAU,UAAU,gDAAgD,2BAA2B,WAAW,qBAAqB,kGAAkG,8DAA8D,6DAA6D,6BAA6B,cAAc,iCAAiC,UAAU,kBAAkB,0BAA0B,kBAAkB,oKAAoK,WAAW,UAAU,wCAAwC,2BAA2B,WAAW,sBAAsB,wGAAwG,WAAW,UAAU,oEAAoE,2BAA2B,8CAA8C,sBAAsB,+BAA+B,yQAAyQ,kBAAkB,2BAA2B,sFAAsF,UAAU,UAAU,kFAAkF,2BAA2B,WAAW,qBAAqB,kGAAkG,yEAAyE,YAAY,6CAA6C,+GAA+G,2FAA2F,wBAAwB,oEAAoE,6BAA6B,yBAAyB,UAAU,wBAAwB,gCAAgC,cAAc,gCAAgC,kBAAkB,0BAA0B,iBAAiB,qGAAqG,oCAAoC,oFAAoF,UAAU,OAAO,UAAU,oBAAoB,aAAa,OAAO,aAAa,wBAAwB,2BAA2B,4BAA4B,+IAA+I,cAAc,cAAc,gBAAgB,gKAAgK,kBAAkB,6BAA6B,uBAAuB,mBAAmB,eAAe,oCAAoC,2CAA2C,8CAA8C,YAAY,WAAW,oIAAoI,iBAAiB,2BAA2B,+BAA+B,WAAW,yCAAyC,YAAY,iBAAiB,iCAAiC,gCAAgC,6FAA6F,oBAAoB,oCAAoC,kBAAkB,gCAAgC,kDAAkD,YAAY,kBAAkB,iBAAiB,oBAAoB,0BAA0B,2BAA2B,QAAQ,mBAAmB,UAAU,oBAAoB,0BAA0B,6CAA6C,QAAQ,oBAAoB,gCAAgC,iDAAiD,gBAAgB,qCAAqC,6BAA6B,YAAY,WAAW,cAAc,oBAAoB,0CAA0C,gBAAgB,yCAAyC,QAAQ,6lBAA6lB,EAAE,oEAAoE,uEAAuE,UAAU,yEAAyE,6BAA6B,yC;;;;;;;ACA1+oB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACTA,yJ;;;;;;;ACAA,wJ;;;;;;;ACAA,wJ","file":"scripts.bundle.js","sourcesContent":["module.exports = \"(function webpackUniversalModuleDefinition(root, factory) {\\n\\tif(typeof exports === 'object' && typeof module === 'object')\\n\\t\\tmodule.exports = factory();\\n\\telse if(typeof define === 'function' && define.amd)\\n\\t\\tdefine(\\\"auth0-js\\\", [], factory);\\n\\telse if(typeof exports === 'object')\\n\\t\\texports[\\\"auth0-js\\\"] = factory();\\n\\telse\\n\\t\\troot[\\\"auth0\\\"] = factory();\\n})(this, function() {\\nreturn /******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId])\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\texports: {},\\n/******/ \\t\\t\\tid: moduleId,\\n/******/ \\t\\t\\tloaded: false\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.loaded = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(0);\\n/******/ })\\n/************************************************************************/\\n/******/ ([\\n/* 0 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tmodule.exports = __webpack_require__(54);\\n\\n\\n/***/ },\\n/* 1 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (name, context, definition) {\\n\\t  if (typeof module !== 'undefined' && module.exports) module.exports = definition();\\n\\t  else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n\\t  else context[name] = definition();\\n\\t})('urljoin', this, function () {\\n\\t\\n\\t  function normalize (str, options) {\\n\\t\\n\\t    // make sure protocol is followed by two slashes\\n\\t    str = str.replace(/:\\\\//g, '://');\\n\\t\\n\\t    // remove consecutive slashes\\n\\t    str = str.replace(/([^:\\\\s])\\\\/+/g, '$1/');\\n\\t\\n\\t    // remove trailing slash before parameters or hash\\n\\t    str = str.replace(/\\\\/(\\\\?|&|#[^!])/g, '$1');\\n\\t\\n\\t    // replace ? in parameters with &\\n\\t    str = str.replace(/(\\\\?.+)\\\\?/g, '$1&');\\n\\t\\n\\t    return str;\\n\\t  }\\n\\t\\n\\t  return function () {\\n\\t    var input = arguments;\\n\\t    var options = {};\\n\\t\\n\\t    if (typeof arguments[0] === 'object') {\\n\\t      // new syntax with array and options\\n\\t      input = arguments[0];\\n\\t      options = arguments[1] || {};\\n\\t    }\\n\\t\\n\\t    var joined = [].slice.call(input, 0).join('/');\\n\\t    return normalize(joined, options);\\n\\t  };\\n\\t\\n\\t});\\n\\n\\n/***/ },\\n/* 2 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\t/* eslint-disable no-param-reassign */\\n\\t/* eslint-disable no-restricted-syntax */\\n\\t/* eslint-disable guard-for-in */\\n\\t\\n\\tvar assert = __webpack_require__(4);\\n\\tvar objectAssign = __webpack_require__(44);\\n\\t\\n\\tfunction pick(object, keys) {\\n\\t  return keys.reduce(function(prev, key) {\\n\\t    if (object[key]) {\\n\\t      prev[key] = object[key];\\n\\t    }\\n\\t    return prev;\\n\\t  }, {});\\n\\t}\\n\\t\\n\\tfunction getKeysNotIn(obj, allowedKeys) {\\n\\t  var notAllowed = [];\\n\\t  for (var key in obj) {\\n\\t    if (allowedKeys.indexOf(key) === -1) {\\n\\t      notAllowed.push(key);\\n\\t    }\\n\\t  }\\n\\t  return notAllowed;\\n\\t}\\n\\t\\n\\tfunction objectValues(obj) {\\n\\t  var values = [];\\n\\t  for (var key in obj) {\\n\\t    values.push(obj[key]);\\n\\t  }\\n\\t  return values;\\n\\t}\\n\\t\\n\\tfunction extend() {\\n\\t  var params = objectValues(arguments);\\n\\t  params.unshift({});\\n\\t  return objectAssign.get().apply(undefined, params);\\n\\t}\\n\\t\\n\\tfunction merge(object, keys) {\\n\\t  return {\\n\\t    base: keys ? pick(object, keys) : object,\\n\\t    with: function(object2, keys2) {\\n\\t      object2 = keys2 ? pick(object2, keys2) : object2;\\n\\t      return extend(this.base, object2);\\n\\t    }\\n\\t  };\\n\\t}\\n\\t\\n\\tfunction blacklist(object, blacklistedKeys) {\\n\\t  return Object.keys(object).reduce(function(p, key) {\\n\\t    if (blacklistedKeys.indexOf(key) === -1) {\\n\\t      p[key] = object[key];\\n\\t    }\\n\\t    return p;\\n\\t  }, {});\\n\\t}\\n\\t\\n\\tfunction camelToSnake(str) {\\n\\t  var newKey = '';\\n\\t  var index = 0;\\n\\t  var code;\\n\\t  var wasPrevNumber = true;\\n\\t  var wasPrevUppercase = true;\\n\\t\\n\\t  while (index < str.length) {\\n\\t    code = str.charCodeAt(index);\\n\\t    if (\\n\\t      (!wasPrevUppercase && code >= 65 && code <= 90) ||\\n\\t      (!wasPrevNumber && code >= 48 && code <= 57)\\n\\t    ) {\\n\\t      newKey += '_';\\n\\t      newKey += str[index].toLowerCase();\\n\\t    } else {\\n\\t      newKey += str[index].toLowerCase();\\n\\t    }\\n\\t    wasPrevNumber = code >= 48 && code <= 57;\\n\\t    wasPrevUppercase = code >= 65 && code <= 90;\\n\\t    index++;\\n\\t  }\\n\\t\\n\\t  return newKey;\\n\\t}\\n\\t\\n\\tfunction snakeToCamel(str) {\\n\\t  var parts = str.split('_');\\n\\t  return parts.reduce(function(p, c) {\\n\\t    return p + c.charAt(0).toUpperCase() + c.slice(1);\\n\\t  }, parts.shift());\\n\\t}\\n\\t\\n\\tfunction toSnakeCase(object, exceptions) {\\n\\t  if (typeof object !== 'object' || assert.isArray(object) || object === null) {\\n\\t    return object;\\n\\t  }\\n\\t  exceptions = exceptions || [];\\n\\t\\n\\t  return Object.keys(object).reduce(function(p, key) {\\n\\t    var newKey = exceptions.indexOf(key) === -1 ? camelToSnake(key) : key;\\n\\t    p[newKey] = toSnakeCase(object[key]);\\n\\t    return p;\\n\\t  }, {});\\n\\t}\\n\\t\\n\\tfunction toCamelCase(object, exceptions) {\\n\\t  if (typeof object !== 'object' || assert.isArray(object) || object === null) {\\n\\t    return object;\\n\\t  }\\n\\t\\n\\t  exceptions = exceptions || [];\\n\\t\\n\\t  return Object.keys(object).reduce(function(p, key) {\\n\\t    var newKey = exceptions.indexOf(key) === -1 ? snakeToCamel(key) : key;\\n\\t    p[newKey] = toCamelCase(object[key]);\\n\\t    return p;\\n\\t  }, {});\\n\\t}\\n\\t\\n\\tmodule.exports = {\\n\\t  toSnakeCase: toSnakeCase,\\n\\t  toCamelCase: toCamelCase,\\n\\t  blacklist: blacklist,\\n\\t  merge: merge,\\n\\t  pick: pick,\\n\\t  getKeysNotIn: getKeysNotIn,\\n\\t  extend: extend\\n\\t};\\n\\n\\n/***/ },\\n/* 3 */\\n/***/ function(module, exports) {\\n\\n\\t/* WEBPACK VAR INJECTION */(function(global) {function redirect(url) {\\n\\t  global.window.location = url;\\n\\t}\\n\\t\\n\\tfunction getDocument() {\\n\\t  return global.window.document;\\n\\t}\\n\\t\\n\\tfunction getWindow() {\\n\\t  return global.window;\\n\\t}\\n\\t\\n\\tmodule.exports = {\\n\\t  redirect: redirect,\\n\\t  getDocument: getDocument,\\n\\t  getWindow: getWindow\\n\\t};\\n\\t\\n\\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\\n\\n/***/ },\\n/* 4 */\\n/***/ function(module, exports) {\\n\\n\\tvar toString = Object.prototype.toString;\\n\\t\\n\\tfunction attribute(o, attr, type, text) {\\n\\t  type = type === 'array' ? 'object' : type;\\n\\t  if (o && typeof o[attr] !== type) {\\n\\t    throw new Error(text);\\n\\t  }\\n\\t}\\n\\t\\n\\tfunction variable(o, type, text) {\\n\\t  if (typeof o !== type) {\\n\\t    throw new Error(text);\\n\\t  }\\n\\t}\\n\\t\\n\\tfunction value(o, values, text) {\\n\\t  if (values.indexOf(o) === -1) {\\n\\t    throw new Error(text);\\n\\t  }\\n\\t}\\n\\t\\n\\tfunction check(o, config, attributes) {\\n\\t  if (!config.optional || o) {\\n\\t    variable(o, config.type, config.message);\\n\\t  }\\n\\t  if (config.type === 'object' && attributes) {\\n\\t    var keys = Object.keys(attributes);\\n\\t\\n\\t    for (var index = 0; index < keys.length; index++) {\\n\\t      var a = keys[index];\\n\\t      if (!attributes[a].optional || o[a]) {\\n\\t        if (!attributes[a].condition || attributes[a].condition(o)) {\\n\\t          attribute(o, a, attributes[a].type, attributes[a].message);\\n\\t          if (attributes[a].values) {\\n\\t            value(o[a], attributes[a].values, attributes[a].value_message);\\n\\t          }\\n\\t        }\\n\\t      }\\n\\t    }\\n\\t  }\\n\\t}\\n\\t\\n\\t/**\\n\\t * Wrap `Array.isArray` Polyfill for IE9\\n\\t * source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray\\n\\t *\\n\\t * @param {Array} array\\n\\t * @private\\n\\t */\\n\\tfunction isArray(array) {\\n\\t  if (this.supportsIsArray()) {\\n\\t    return Array.isArray(array);\\n\\t  }\\n\\t\\n\\t  return toString.call(array) === '[object Array]';\\n\\t}\\n\\t\\n\\tfunction supportsIsArray() {\\n\\t  return Array.isArray != null;\\n\\t}\\n\\t\\n\\tmodule.exports = {\\n\\t  check: check,\\n\\t  attribute: attribute,\\n\\t  variable: variable,\\n\\t  value: value,\\n\\t  isArray: isArray,\\n\\t  supportsIsArray: supportsIsArray\\n\\t};\\n\\n\\n/***/ },\\n/* 5 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\t'use strict';\\n\\t\\n\\tvar stringify = __webpack_require__(13);\\n\\tvar parse = __webpack_require__(12);\\n\\tvar formats = __webpack_require__(7);\\n\\t\\n\\tmodule.exports = {\\n\\t    formats: formats,\\n\\t    parse: parse,\\n\\t    stringify: stringify\\n\\t};\\n\\n\\n/***/ },\\n/* 6 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar error = __webpack_require__(21);\\n\\tvar objectHelper = __webpack_require__(2);\\n\\t\\n\\tfunction wrapCallback(cb, options) {\\n\\t  options = options || {};\\n\\t  options.ignoreCasing = options.ignoreCasing ? options.ignoreCasing : false;\\n\\t\\n\\t  return function(err, data) {\\n\\t    var errObj;\\n\\t\\n\\t    if (!err && !data) {\\n\\t      return cb(error.buildResponse('generic_error', 'Something went wrong'));\\n\\t    }\\n\\t\\n\\t    if (!err && data.err) {\\n\\t      err = data.err;\\n\\t      data = null;\\n\\t    }\\n\\t\\n\\t    if (!err && data.error) {\\n\\t      err = data;\\n\\t      data = null;\\n\\t    }\\n\\t\\n\\t    if (err) {\\n\\t      errObj = {\\n\\t        original: err\\n\\t      };\\n\\t\\n\\t      if (err.response && err.response.statusCode) {\\n\\t        errObj.statusCode = err.response.statusCode;\\n\\t      }\\n\\t\\n\\t      if (err.response && err.response.statusText) {\\n\\t        errObj.statusText = err.response.statusText;\\n\\t      }\\n\\t\\n\\t      if (err.response && err.response.body) {\\n\\t        err = err.response.body;\\n\\t      }\\n\\t\\n\\t      if (err.err) {\\n\\t        err = err.err;\\n\\t      }\\n\\t\\n\\t      errObj.code = err.error || err.code || err.error_code || err.status || null;\\n\\t      errObj.description =\\n\\t        err.errorDescription ||\\n\\t        err.error_description ||\\n\\t        err.description ||\\n\\t        err.error ||\\n\\t        err.details ||\\n\\t        err.err ||\\n\\t        null;\\n\\t\\n\\t      if (err.name) {\\n\\t        errObj.name = err.name;\\n\\t      }\\n\\t\\n\\t      if (err.policy) {\\n\\t        errObj.policy = err.policy;\\n\\t      }\\n\\t\\n\\t      return cb(errObj);\\n\\t    }\\n\\t\\n\\t    if (data.type && (data.type === 'text/html' || data.type === 'text/plain')) {\\n\\t      return cb(null, data.text);\\n\\t    }\\n\\t\\n\\t    if (options.ignoreCasing) {\\n\\t      return cb(null, data.body || data);\\n\\t    }\\n\\t\\n\\t    return cb(null, objectHelper.toCamelCase(data.body || data));\\n\\t  };\\n\\t}\\n\\t\\n\\tmodule.exports = wrapCallback;\\n\\n\\n/***/ },\\n/* 7 */\\n/***/ function(module, exports) {\\n\\n\\t'use strict';\\n\\t\\n\\tvar replace = String.prototype.replace;\\n\\tvar percentTwenties = /%20/g;\\n\\t\\n\\tmodule.exports = {\\n\\t    'default': 'RFC3986',\\n\\t    formatters: {\\n\\t        RFC1738: function (value) {\\n\\t            return replace.call(value, percentTwenties, '+');\\n\\t        },\\n\\t        RFC3986: function (value) {\\n\\t            return value;\\n\\t        }\\n\\t    },\\n\\t    RFC1738: 'RFC1738',\\n\\t    RFC3986: 'RFC3986'\\n\\t};\\n\\n\\n/***/ },\\n/* 8 */\\n/***/ function(module, exports) {\\n\\n\\t'use strict';\\n\\t\\n\\tvar has = Object.prototype.hasOwnProperty;\\n\\t\\n\\tvar hexTable = (function () {\\n\\t    var array = [];\\n\\t    for (var i = 0; i < 256; ++i) {\\n\\t        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\\n\\t    }\\n\\t\\n\\t    return array;\\n\\t}());\\n\\t\\n\\texports.arrayToObject = function (source, options) {\\n\\t    var obj = options && options.plainObjects ? Object.create(null) : {};\\n\\t    for (var i = 0; i < source.length; ++i) {\\n\\t        if (typeof source[i] !== 'undefined') {\\n\\t            obj[i] = source[i];\\n\\t        }\\n\\t    }\\n\\t\\n\\t    return obj;\\n\\t};\\n\\t\\n\\texports.merge = function (target, source, options) {\\n\\t    if (!source) {\\n\\t        return target;\\n\\t    }\\n\\t\\n\\t    if (typeof source !== 'object') {\\n\\t        if (Array.isArray(target)) {\\n\\t            target.push(source);\\n\\t        } else if (typeof target === 'object') {\\n\\t            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {\\n\\t                target[source] = true;\\n\\t            }\\n\\t        } else {\\n\\t            return [target, source];\\n\\t        }\\n\\t\\n\\t        return target;\\n\\t    }\\n\\t\\n\\t    if (typeof target !== 'object') {\\n\\t        return [target].concat(source);\\n\\t    }\\n\\t\\n\\t    var mergeTarget = target;\\n\\t    if (Array.isArray(target) && !Array.isArray(source)) {\\n\\t        mergeTarget = exports.arrayToObject(target, options);\\n\\t    }\\n\\t\\n\\t    if (Array.isArray(target) && Array.isArray(source)) {\\n\\t        source.forEach(function (item, i) {\\n\\t            if (has.call(target, i)) {\\n\\t                if (target[i] && typeof target[i] === 'object') {\\n\\t                    target[i] = exports.merge(target[i], item, options);\\n\\t                } else {\\n\\t                    target.push(item);\\n\\t                }\\n\\t            } else {\\n\\t                target[i] = item;\\n\\t            }\\n\\t        });\\n\\t        return target;\\n\\t    }\\n\\t\\n\\t    return Object.keys(source).reduce(function (acc, key) {\\n\\t        var value = source[key];\\n\\t\\n\\t        if (Object.prototype.hasOwnProperty.call(acc, key)) {\\n\\t            acc[key] = exports.merge(acc[key], value, options);\\n\\t        } else {\\n\\t            acc[key] = value;\\n\\t        }\\n\\t        return acc;\\n\\t    }, mergeTarget);\\n\\t};\\n\\t\\n\\texports.decode = function (str) {\\n\\t    try {\\n\\t        return decodeURIComponent(str.replace(/\\\\+/g, ' '));\\n\\t    } catch (e) {\\n\\t        return str;\\n\\t    }\\n\\t};\\n\\t\\n\\texports.encode = function (str) {\\n\\t    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\\n\\t    // It has been adapted here for stricter adherence to RFC 3986\\n\\t    if (str.length === 0) {\\n\\t        return str;\\n\\t    }\\n\\t\\n\\t    var string = typeof str === 'string' ? str : String(str);\\n\\t\\n\\t    var out = '';\\n\\t    for (var i = 0; i < string.length; ++i) {\\n\\t        var c = string.charCodeAt(i);\\n\\t\\n\\t        if (\\n\\t            c === 0x2D || // -\\n\\t            c === 0x2E || // .\\n\\t            c === 0x5F || // _\\n\\t            c === 0x7E || // ~\\n\\t            (c >= 0x30 && c <= 0x39) || // 0-9\\n\\t            (c >= 0x41 && c <= 0x5A) || // a-z\\n\\t            (c >= 0x61 && c <= 0x7A) // A-Z\\n\\t        ) {\\n\\t            out += string.charAt(i);\\n\\t            continue;\\n\\t        }\\n\\t\\n\\t        if (c < 0x80) {\\n\\t            out = out + hexTable[c];\\n\\t            continue;\\n\\t        }\\n\\t\\n\\t        if (c < 0x800) {\\n\\t            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\\n\\t            continue;\\n\\t        }\\n\\t\\n\\t        if (c < 0xD800 || c >= 0xE000) {\\n\\t            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\\n\\t            continue;\\n\\t        }\\n\\t\\n\\t        i += 1;\\n\\t        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\\n\\t        out += hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]; // eslint-disable-line max-len\\n\\t    }\\n\\t\\n\\t    return out;\\n\\t};\\n\\t\\n\\texports.compact = function (obj, references) {\\n\\t    if (typeof obj !== 'object' || obj === null) {\\n\\t        return obj;\\n\\t    }\\n\\t\\n\\t    var refs = references || [];\\n\\t    var lookup = refs.indexOf(obj);\\n\\t    if (lookup !== -1) {\\n\\t        return refs[lookup];\\n\\t    }\\n\\t\\n\\t    refs.push(obj);\\n\\t\\n\\t    if (Array.isArray(obj)) {\\n\\t        var compacted = [];\\n\\t\\n\\t        for (var i = 0; i < obj.length; ++i) {\\n\\t            if (obj[i] && typeof obj[i] === 'object') {\\n\\t                compacted.push(exports.compact(obj[i], refs));\\n\\t            } else if (typeof obj[i] !== 'undefined') {\\n\\t                compacted.push(obj[i]);\\n\\t            }\\n\\t        }\\n\\t\\n\\t        return compacted;\\n\\t    }\\n\\t\\n\\t    var keys = Object.keys(obj);\\n\\t    keys.forEach(function (key) {\\n\\t        obj[key] = exports.compact(obj[key], refs);\\n\\t    });\\n\\t\\n\\t    return obj;\\n\\t};\\n\\t\\n\\texports.isRegExp = function (obj) {\\n\\t    return Object.prototype.toString.call(obj) === '[object RegExp]';\\n\\t};\\n\\t\\n\\texports.isBuffer = function (obj) {\\n\\t    if (obj === null || typeof obj === 'undefined') {\\n\\t        return false;\\n\\t    }\\n\\t\\n\\t    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\\n\\t};\\n\\n\\n/***/ },\\n/* 9 */\\n/***/ function(module, exports) {\\n\\n\\tmodule.exports = { raw: '8.9.3' };\\n\\n\\n/***/ },\\n/* 10 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\t/* eslint-disable no-param-reassign */\\n\\tvar request = __webpack_require__(17);\\n\\tvar base64Url = __webpack_require__(20);\\n\\tvar version = __webpack_require__(9);\\n\\t\\n\\t// ------------------------------------------------ RequestWrapper\\n\\t\\n\\tfunction RequestWrapper(req) {\\n\\t  this.request = req;\\n\\t  this.method = req.method;\\n\\t  this.url = req.url;\\n\\t  this.body = req._data;\\n\\t  this.headers = req._header;\\n\\t}\\n\\t\\n\\tRequestWrapper.prototype.abort = function() {\\n\\t  this.request.abort();\\n\\t};\\n\\t\\n\\tRequestWrapper.prototype.getMethod = function() {\\n\\t  return this.method;\\n\\t};\\n\\t\\n\\tRequestWrapper.prototype.getBody = function() {\\n\\t  return this.body;\\n\\t};\\n\\t\\n\\tRequestWrapper.prototype.getUrl = function() {\\n\\t  return this.url;\\n\\t};\\n\\t\\n\\tRequestWrapper.prototype.getHeaders = function() {\\n\\t  return this.headers;\\n\\t};\\n\\t\\n\\t// ------------------------------------------------ RequestObj\\n\\t\\n\\tfunction RequestObj(req) {\\n\\t  this.request = req;\\n\\t}\\n\\t\\n\\tRequestObj.prototype.set = function(key, value) {\\n\\t  this.request = this.request.set(key, value);\\n\\t  return this;\\n\\t};\\n\\t\\n\\tRequestObj.prototype.send = function(body) {\\n\\t  this.request = this.request.send(body);\\n\\t  return this;\\n\\t};\\n\\t\\n\\tRequestObj.prototype.withCredentials = function() {\\n\\t  this.request = this.request.withCredentials();\\n\\t  return this;\\n\\t};\\n\\t\\n\\tRequestObj.prototype.end = function(cb) {\\n\\t  this.request = this.request.end(cb);\\n\\t  return new RequestWrapper(this.request);\\n\\t};\\n\\t\\n\\t// ------------------------------------------------ RequestBuilder\\n\\t\\n\\tfunction RequestBuilder(options) {\\n\\t  this._sendTelemetry = options._sendTelemetry === false ? options._sendTelemetry : true;\\n\\t  this._telemetryInfo = options._telemetryInfo || null;\\n\\t  this._timesToRetryFailedRequests = options._timesToRetryFailedRequests;\\n\\t  this.headers = options.headers || {};\\n\\t}\\n\\t\\n\\tRequestBuilder.prototype.setCommonConfiguration = function(ongoingRequest, options) {\\n\\t  options = options || {};\\n\\t\\n\\t  if (options.noHeaders) {\\n\\t    return ongoingRequest;\\n\\t  }\\n\\t\\n\\t  var headers = this.headers;\\n\\t  ongoingRequest = ongoingRequest.set('Content-Type', 'application/json');\\n\\t\\n\\t  var keys = Object.keys(this.headers);\\n\\t\\n\\t  for (var a = 0; a < keys.length; a++) {\\n\\t    ongoingRequest = ongoingRequest.set(keys[a], headers[keys[a]]);\\n\\t  }\\n\\t\\n\\t  if (this._sendTelemetry) {\\n\\t    ongoingRequest = ongoingRequest.set('Auth0-Client', this.getTelemetryData());\\n\\t  }\\n\\t  if (this._timesToRetryFailedRequests > 0) {\\n\\t    ongoingRequest = ongoingRequest.retry(this._timesToRetryFailedRequests);\\n\\t  }\\n\\t  return ongoingRequest;\\n\\t};\\n\\t\\n\\tRequestBuilder.prototype.getTelemetryData = function() {\\n\\t  var clientInfo = this._telemetryInfo || { name: 'auth0.js', version: version.raw };\\n\\t  var jsonClientInfo = JSON.stringify(clientInfo);\\n\\t  return base64Url.encode(jsonClientInfo);\\n\\t};\\n\\t\\n\\tRequestBuilder.prototype.get = function(url, options) {\\n\\t  return new RequestObj(this.setCommonConfiguration(request.get(url), options));\\n\\t};\\n\\t\\n\\tRequestBuilder.prototype.post = function(url, options) {\\n\\t  return new RequestObj(this.setCommonConfiguration(request.post(url), options));\\n\\t};\\n\\t\\n\\tRequestBuilder.prototype.patch = function(url, options) {\\n\\t  return new RequestObj(this.setCommonConfiguration(request.patch(url), options));\\n\\t};\\n\\t\\n\\tmodule.exports = RequestBuilder;\\n\\n\\n/***/ },\\n/* 11 */\\n/***/ function(module, exports) {\\n\\n\\t/* eslint-disable no-console */\\n\\t\\n\\tfunction Warn(options) {\\n\\t  this.disableWarnings = options.disableWarnings;\\n\\t}\\n\\t\\n\\tWarn.prototype.warning = function(message) {\\n\\t  if (this.disableWarnings) {\\n\\t    return;\\n\\t  }\\n\\t\\n\\t  console.warn(message);\\n\\t};\\n\\t\\n\\tmodule.exports = Warn;\\n\\n\\n/***/ },\\n/* 12 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\t'use strict';\\n\\t\\n\\tvar utils = __webpack_require__(8);\\n\\t\\n\\tvar has = Object.prototype.hasOwnProperty;\\n\\t\\n\\tvar defaults = {\\n\\t    allowDots: false,\\n\\t    allowPrototypes: false,\\n\\t    arrayLimit: 20,\\n\\t    decoder: utils.decode,\\n\\t    delimiter: '&',\\n\\t    depth: 5,\\n\\t    parameterLimit: 1000,\\n\\t    plainObjects: false,\\n\\t    strictNullHandling: false\\n\\t};\\n\\t\\n\\tvar parseValues = function parseQueryStringValues(str, options) {\\n\\t    var obj = {};\\n\\t    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\\n\\t\\n\\t    for (var i = 0; i < parts.length; ++i) {\\n\\t        var part = parts[i];\\n\\t        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\\n\\t\\n\\t        var key, val;\\n\\t        if (pos === -1) {\\n\\t            key = options.decoder(part);\\n\\t            val = options.strictNullHandling ? null : '';\\n\\t        } else {\\n\\t            key = options.decoder(part.slice(0, pos));\\n\\t            val = options.decoder(part.slice(pos + 1));\\n\\t        }\\n\\t        if (has.call(obj, key)) {\\n\\t            obj[key] = [].concat(obj[key]).concat(val);\\n\\t        } else {\\n\\t            obj[key] = val;\\n\\t        }\\n\\t    }\\n\\t\\n\\t    return obj;\\n\\t};\\n\\t\\n\\tvar parseObject = function parseObjectRecursive(chain, val, options) {\\n\\t    if (!chain.length) {\\n\\t        return val;\\n\\t    }\\n\\t\\n\\t    var root = chain.shift();\\n\\t\\n\\t    var obj;\\n\\t    if (root === '[]') {\\n\\t        obj = [];\\n\\t        obj = obj.concat(parseObject(chain, val, options));\\n\\t    } else {\\n\\t        obj = options.plainObjects ? Object.create(null) : {};\\n\\t        var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\\n\\t        var index = parseInt(cleanRoot, 10);\\n\\t        if (\\n\\t            !isNaN(index) &&\\n\\t            root !== cleanRoot &&\\n\\t            String(index) === cleanRoot &&\\n\\t            index >= 0 &&\\n\\t            (options.parseArrays && index <= options.arrayLimit)\\n\\t        ) {\\n\\t            obj = [];\\n\\t            obj[index] = parseObject(chain, val, options);\\n\\t        } else {\\n\\t            obj[cleanRoot] = parseObject(chain, val, options);\\n\\t        }\\n\\t    }\\n\\t\\n\\t    return obj;\\n\\t};\\n\\t\\n\\tvar parseKeys = function parseQueryStringKeys(givenKey, val, options) {\\n\\t    if (!givenKey) {\\n\\t        return;\\n\\t    }\\n\\t\\n\\t    // Transform dot notation to bracket notation\\n\\t    var key = options.allowDots ? givenKey.replace(/\\\\.([^.[]+)/g, '[$1]') : givenKey;\\n\\t\\n\\t    // The regex chunks\\n\\t\\n\\t    var brackets = /(\\\\[[^[\\\\]]*])/;\\n\\t    var child = /(\\\\[[^[\\\\]]*])/g;\\n\\t\\n\\t    // Get the parent\\n\\t\\n\\t    var segment = brackets.exec(key);\\n\\t    var parent = segment ? key.slice(0, segment.index) : key;\\n\\t\\n\\t    // Stash the parent if it exists\\n\\t\\n\\t    var keys = [];\\n\\t    if (parent) {\\n\\t        // If we aren't using plain objects, optionally prefix keys\\n\\t        // that would overwrite object prototype properties\\n\\t        if (!options.plainObjects && has.call(Object.prototype, parent)) {\\n\\t            if (!options.allowPrototypes) {\\n\\t                return;\\n\\t            }\\n\\t        }\\n\\t\\n\\t        keys.push(parent);\\n\\t    }\\n\\t\\n\\t    // Loop through children appending to the array until we hit depth\\n\\t\\n\\t    var i = 0;\\n\\t    while ((segment = child.exec(key)) !== null && i < options.depth) {\\n\\t        i += 1;\\n\\t        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\\n\\t            if (!options.allowPrototypes) {\\n\\t                return;\\n\\t            }\\n\\t        }\\n\\t        keys.push(segment[1]);\\n\\t    }\\n\\t\\n\\t    // If there's a remainder, just add whatever is left\\n\\t\\n\\t    if (segment) {\\n\\t        keys.push('[' + key.slice(segment.index) + ']');\\n\\t    }\\n\\t\\n\\t    return parseObject(keys, val, options);\\n\\t};\\n\\t\\n\\tmodule.exports = function (str, opts) {\\n\\t    var options = opts || {};\\n\\t\\n\\t    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {\\n\\t        throw new TypeError('Decoder has to be a function.');\\n\\t    }\\n\\t\\n\\t    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\\n\\t    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;\\n\\t    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;\\n\\t    options.parseArrays = options.parseArrays !== false;\\n\\t    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;\\n\\t    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;\\n\\t    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;\\n\\t    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;\\n\\t    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;\\n\\t    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\\n\\t\\n\\t    if (str === '' || str === null || typeof str === 'undefined') {\\n\\t        return options.plainObjects ? Object.create(null) : {};\\n\\t    }\\n\\t\\n\\t    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\\n\\t    var obj = options.plainObjects ? Object.create(null) : {};\\n\\t\\n\\t    // Iterate over the keys and setup the new object\\n\\t\\n\\t    var keys = Object.keys(tempObj);\\n\\t    for (var i = 0; i < keys.length; ++i) {\\n\\t        var key = keys[i];\\n\\t        var newObj = parseKeys(key, tempObj[key], options);\\n\\t        obj = utils.merge(obj, newObj, options);\\n\\t    }\\n\\t\\n\\t    return utils.compact(obj);\\n\\t};\\n\\n\\n/***/ },\\n/* 13 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\t'use strict';\\n\\t\\n\\tvar utils = __webpack_require__(8);\\n\\tvar formats = __webpack_require__(7);\\n\\t\\n\\tvar arrayPrefixGenerators = {\\n\\t    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching\\n\\t        return prefix + '[]';\\n\\t    },\\n\\t    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching\\n\\t        return prefix + '[' + key + ']';\\n\\t    },\\n\\t    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching\\n\\t        return prefix;\\n\\t    }\\n\\t};\\n\\t\\n\\tvar toISO = Date.prototype.toISOString;\\n\\t\\n\\tvar defaults = {\\n\\t    delimiter: '&',\\n\\t    encode: true,\\n\\t    encoder: utils.encode,\\n\\t    encodeValuesOnly: false,\\n\\t    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching\\n\\t        return toISO.call(date);\\n\\t    },\\n\\t    skipNulls: false,\\n\\t    strictNullHandling: false\\n\\t};\\n\\t\\n\\tvar stringify = function stringify( // eslint-disable-line func-name-matching\\n\\t    object,\\n\\t    prefix,\\n\\t    generateArrayPrefix,\\n\\t    strictNullHandling,\\n\\t    skipNulls,\\n\\t    encoder,\\n\\t    filter,\\n\\t    sort,\\n\\t    allowDots,\\n\\t    serializeDate,\\n\\t    formatter,\\n\\t    encodeValuesOnly\\n\\t) {\\n\\t    var obj = object;\\n\\t    if (typeof filter === 'function') {\\n\\t        obj = filter(prefix, obj);\\n\\t    } else if (obj instanceof Date) {\\n\\t        obj = serializeDate(obj);\\n\\t    } else if (obj === null) {\\n\\t        if (strictNullHandling) {\\n\\t            return encoder && !encodeValuesOnly ? encoder(prefix) : prefix;\\n\\t        }\\n\\t\\n\\t        obj = '';\\n\\t    }\\n\\t\\n\\t    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {\\n\\t        if (encoder) {\\n\\t            var keyValue = encodeValuesOnly ? prefix : encoder(prefix);\\n\\t            return [formatter(keyValue) + '=' + formatter(encoder(obj))];\\n\\t        }\\n\\t        return [formatter(prefix) + '=' + formatter(String(obj))];\\n\\t    }\\n\\t\\n\\t    var values = [];\\n\\t\\n\\t    if (typeof obj === 'undefined') {\\n\\t        return values;\\n\\t    }\\n\\t\\n\\t    var objKeys;\\n\\t    if (Array.isArray(filter)) {\\n\\t        objKeys = filter;\\n\\t    } else {\\n\\t        var keys = Object.keys(obj);\\n\\t        objKeys = sort ? keys.sort(sort) : keys;\\n\\t    }\\n\\t\\n\\t    for (var i = 0; i < objKeys.length; ++i) {\\n\\t        var key = objKeys[i];\\n\\t\\n\\t        if (skipNulls && obj[key] === null) {\\n\\t            continue;\\n\\t        }\\n\\t\\n\\t        if (Array.isArray(obj)) {\\n\\t            values = values.concat(stringify(\\n\\t                obj[key],\\n\\t                generateArrayPrefix(prefix, key),\\n\\t                generateArrayPrefix,\\n\\t                strictNullHandling,\\n\\t                skipNulls,\\n\\t                encoder,\\n\\t                filter,\\n\\t                sort,\\n\\t                allowDots,\\n\\t                serializeDate,\\n\\t                formatter,\\n\\t                encodeValuesOnly\\n\\t            ));\\n\\t        } else {\\n\\t            values = values.concat(stringify(\\n\\t                obj[key],\\n\\t                prefix + (allowDots ? '.' + key : '[' + key + ']'),\\n\\t                generateArrayPrefix,\\n\\t                strictNullHandling,\\n\\t                skipNulls,\\n\\t                encoder,\\n\\t                filter,\\n\\t                sort,\\n\\t                allowDots,\\n\\t                serializeDate,\\n\\t                formatter,\\n\\t                encodeValuesOnly\\n\\t            ));\\n\\t        }\\n\\t    }\\n\\t\\n\\t    return values;\\n\\t};\\n\\t\\n\\tmodule.exports = function (object, opts) {\\n\\t    var obj = object;\\n\\t    var options = opts || {};\\n\\t\\n\\t    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {\\n\\t        throw new TypeError('Encoder has to be a function.');\\n\\t    }\\n\\t\\n\\t    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;\\n\\t    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\\n\\t    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;\\n\\t    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;\\n\\t    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;\\n\\t    var sort = typeof options.sort === 'function' ? options.sort : null;\\n\\t    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;\\n\\t    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;\\n\\t    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;\\n\\t    if (typeof options.format === 'undefined') {\\n\\t        options.format = formats.default;\\n\\t    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {\\n\\t        throw new TypeError('Unknown format option provided.');\\n\\t    }\\n\\t    var formatter = formats.formatters[options.format];\\n\\t    var objKeys;\\n\\t    var filter;\\n\\t\\n\\t    if (typeof options.filter === 'function') {\\n\\t        filter = options.filter;\\n\\t        obj = filter('', obj);\\n\\t    } else if (Array.isArray(options.filter)) {\\n\\t        filter = options.filter;\\n\\t        objKeys = filter;\\n\\t    }\\n\\t\\n\\t    var keys = [];\\n\\t\\n\\t    if (typeof obj !== 'object' || obj === null) {\\n\\t        return '';\\n\\t    }\\n\\t\\n\\t    var arrayFormat;\\n\\t    if (options.arrayFormat in arrayPrefixGenerators) {\\n\\t        arrayFormat = options.arrayFormat;\\n\\t    } else if ('indices' in options) {\\n\\t        arrayFormat = options.indices ? 'indices' : 'repeat';\\n\\t    } else {\\n\\t        arrayFormat = 'indices';\\n\\t    }\\n\\t\\n\\t    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\\n\\t\\n\\t    if (!objKeys) {\\n\\t        objKeys = Object.keys(obj);\\n\\t    }\\n\\t\\n\\t    if (sort) {\\n\\t        objKeys.sort(sort);\\n\\t    }\\n\\t\\n\\t    for (var i = 0; i < objKeys.length; ++i) {\\n\\t        var key = objKeys[i];\\n\\t\\n\\t        if (skipNulls && obj[key] === null) {\\n\\t            continue;\\n\\t        }\\n\\t\\n\\t        keys = keys.concat(stringify(\\n\\t            obj[key],\\n\\t            key,\\n\\t            generateArrayPrefix,\\n\\t            strictNullHandling,\\n\\t            skipNulls,\\n\\t            encode ? encoder : null,\\n\\t            filter,\\n\\t            sort,\\n\\t            allowDots,\\n\\t            serializeDate,\\n\\t            formatter,\\n\\t            encodeValuesOnly\\n\\t        ));\\n\\t    }\\n\\t\\n\\t    return keys.join(delimiter);\\n\\t};\\n\\n\\n/***/ },\\n/* 14 */\\n/***/ function(module, exports) {\\n\\n\\t/**\\n\\t * Check if `obj` is an object.\\n\\t *\\n\\t * @param {Object} obj\\n\\t * @return {Boolean}\\n\\t * @api private\\n\\t */\\n\\t\\n\\tfunction isObject(obj) {\\n\\t  return null !== obj && 'object' === typeof obj;\\n\\t}\\n\\t\\n\\tmodule.exports = isObject;\\n\\n\\n/***/ },\\n/* 15 */\\n/***/ function(module, exports) {\\n\\n\\t'use strict'\\n\\t\\n\\texports.byteLength = byteLength\\n\\texports.toByteArray = toByteArray\\n\\texports.fromByteArray = fromByteArray\\n\\t\\n\\tvar lookup = []\\n\\tvar revLookup = []\\n\\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\\n\\t\\n\\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\\n\\tfor (var i = 0, len = code.length; i < len; ++i) {\\n\\t  lookup[i] = code[i]\\n\\t  revLookup[code.charCodeAt(i)] = i\\n\\t}\\n\\t\\n\\trevLookup['-'.charCodeAt(0)] = 62\\n\\trevLookup['_'.charCodeAt(0)] = 63\\n\\t\\n\\tfunction placeHoldersCount (b64) {\\n\\t  var len = b64.length\\n\\t  if (len % 4 > 0) {\\n\\t    throw new Error('Invalid string. Length must be a multiple of 4')\\n\\t  }\\n\\t\\n\\t  // the number of equal signs (place holders)\\n\\t  // if there are two placeholders, than the two characters before it\\n\\t  // represent one byte\\n\\t  // if there is only one, then the three characters before it represent 2 bytes\\n\\t  // this is just a cheap hack to not do indexOf twice\\n\\t  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\\n\\t}\\n\\t\\n\\tfunction byteLength (b64) {\\n\\t  // base64 is 4/3 + up to two characters of the original data\\n\\t  return b64.length * 3 / 4 - placeHoldersCount(b64)\\n\\t}\\n\\t\\n\\tfunction toByteArray (b64) {\\n\\t  var i, j, l, tmp, placeHolders, arr\\n\\t  var len = b64.length\\n\\t  placeHolders = placeHoldersCount(b64)\\n\\t\\n\\t  arr = new Arr(len * 3 / 4 - placeHolders)\\n\\t\\n\\t  // if there are placeholders, only get up to the last complete 4 chars\\n\\t  l = placeHolders > 0 ? len - 4 : len\\n\\t\\n\\t  var L = 0\\n\\t\\n\\t  for (i = 0, j = 0; i < l; i += 4, j += 3) {\\n\\t    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\\n\\t    arr[L++] = (tmp >> 16) & 0xFF\\n\\t    arr[L++] = (tmp >> 8) & 0xFF\\n\\t    arr[L++] = tmp & 0xFF\\n\\t  }\\n\\t\\n\\t  if (placeHolders === 2) {\\n\\t    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\\n\\t    arr[L++] = tmp & 0xFF\\n\\t  } else if (placeHolders === 1) {\\n\\t    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\\n\\t    arr[L++] = (tmp >> 8) & 0xFF\\n\\t    arr[L++] = tmp & 0xFF\\n\\t  }\\n\\t\\n\\t  return arr\\n\\t}\\n\\t\\n\\tfunction tripletToBase64 (num) {\\n\\t  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\\n\\t}\\n\\t\\n\\tfunction encodeChunk (uint8, start, end) {\\n\\t  var tmp\\n\\t  var output = []\\n\\t  for (var i = start; i < end; i += 3) {\\n\\t    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\\n\\t    output.push(tripletToBase64(tmp))\\n\\t  }\\n\\t  return output.join('')\\n\\t}\\n\\t\\n\\tfunction fromByteArray (uint8) {\\n\\t  var tmp\\n\\t  var len = uint8.length\\n\\t  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\\n\\t  var output = ''\\n\\t  var parts = []\\n\\t  var maxChunkLength = 16383 // must be multiple of 3\\n\\t\\n\\t  // go through the array every three bytes, we'll deal with trailing stuff later\\n\\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\\n\\t    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\\n\\t  }\\n\\t\\n\\t  // pad the end with zeros, but make sure to not forget the extra bytes\\n\\t  if (extraBytes === 1) {\\n\\t    tmp = uint8[len - 1]\\n\\t    output += lookup[tmp >> 2]\\n\\t    output += lookup[(tmp << 4) & 0x3F]\\n\\t    output += '=='\\n\\t  } else if (extraBytes === 2) {\\n\\t    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\\n\\t    output += lookup[tmp >> 10]\\n\\t    output += lookup[(tmp >> 4) & 0x3F]\\n\\t    output += lookup[(tmp << 2) & 0x3F]\\n\\t    output += '='\\n\\t  }\\n\\t\\n\\t  parts.push(output)\\n\\t\\n\\t  return parts.join('')\\n\\t}\\n\\n\\n/***/ },\\n/* 16 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar base64 = __webpack_require__(15);\\n\\t\\n\\tfunction padding(str) {\\n\\t  var mod = (str.length % 4);\\n\\t  var pad = 4 - mod;\\n\\t\\n\\t  if (mod === 0) {\\n\\t    return str;\\n\\t  }\\n\\t\\n\\t  return str + (new Array(1 + pad)).join('=');\\n\\t}\\n\\t\\n\\tfunction byteArrayToString(array) {\\n\\t  var result = \\\"\\\";\\n\\t  for (var i = 0; i < array.length; i++) {\\n\\t    result += String.fromCharCode(array[i]);\\n\\t  }\\n\\t  return result;\\n\\t}\\n\\t\\n\\tfunction stringToByteArray(str) {\\n\\t  var arr = new Array(str.length);\\n\\t  for (var a = 0; a < str.length; a++) {\\n\\t    arr[a] = str.charCodeAt(a);\\n\\t  }\\n\\t  return arr;\\n\\t}\\n\\t\\n\\tfunction byteArrayToHex(raw) {\\n\\t  var HEX = '';\\n\\t\\n\\t  for (var i = 0; i < raw.length; i++) {\\n\\t    var _hex = raw[i].toString(16);\\n\\t    HEX += (_hex.length === 2 ? _hex : '0' + _hex);\\n\\t  }\\n\\t\\n\\t  return HEX;\\n\\t}\\n\\t\\n\\tfunction encodeString(str) {\\n\\t  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p1) {\\n\\t    return String.fromCharCode('0x' + p1);\\n\\t  }))\\n\\t  .replace(/\\\\+/g, '-') // Convert '+' to '-'\\n\\t  .replace(/\\\\//g, '_'); // Convert '/' to '_';\\n\\t}\\n\\t\\n\\tfunction decodeToString(str) {\\n\\t  str = padding(str)\\n\\t    .replace(/\\\\-/g, '+') // Convert '-' to '+'\\n\\t    .replace(/_/g, '/'); // Convert '_' to '/'\\n\\t\\n\\t  return decodeURIComponent(atob(str).split('').map(function (c) {\\n\\t    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\\n\\t  }).join(''));\\n\\t}\\n\\t\\n\\tfunction decodeToHEX(str) {\\n\\t  return byteArrayToHex(base64.toByteArray(padding(str)));\\n\\t}\\n\\t\\n\\tmodule.exports = {\\n\\t  encodeString: encodeString,\\n\\t  decodeToString: decodeToString,\\n\\t  byteArrayToString: byteArrayToString,\\n\\t  stringToByteArray: stringToByteArray,\\n\\t  padding: padding,\\n\\t  byteArrayToHex: byteArrayToHex,\\n\\t  decodeToHEX: decodeToHEX\\n\\t};\\n\\n\\n/***/ },\\n/* 17 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\t/**\\n\\t * Root reference for iframes.\\n\\t */\\n\\t\\n\\tvar root;\\n\\tif (typeof window !== 'undefined') { // Browser window\\n\\t  root = window;\\n\\t} else if (typeof self !== 'undefined') { // Web Worker\\n\\t  root = self;\\n\\t} else { // Other environments\\n\\t  console.warn(\\\"Using browser-only version of superagent in non-browser environment\\\");\\n\\t  root = this;\\n\\t}\\n\\t\\n\\tvar Emitter = __webpack_require__(23);\\n\\tvar RequestBase = __webpack_require__(33);\\n\\tvar isObject = __webpack_require__(14);\\n\\tvar isFunction = __webpack_require__(32);\\n\\tvar ResponseBase = __webpack_require__(34);\\n\\tvar shouldRetry = __webpack_require__(35);\\n\\t\\n\\t/**\\n\\t * Noop.\\n\\t */\\n\\t\\n\\tfunction noop(){};\\n\\t\\n\\t/**\\n\\t * Expose `request`.\\n\\t */\\n\\t\\n\\tvar request = exports = module.exports = function(method, url) {\\n\\t  // callback\\n\\t  if ('function' == typeof url) {\\n\\t    return new exports.Request('GET', method).end(url);\\n\\t  }\\n\\t\\n\\t  // url first\\n\\t  if (1 == arguments.length) {\\n\\t    return new exports.Request('GET', method);\\n\\t  }\\n\\t\\n\\t  return new exports.Request(method, url);\\n\\t}\\n\\t\\n\\texports.Request = Request;\\n\\t\\n\\t/**\\n\\t * Determine XHR.\\n\\t */\\n\\t\\n\\trequest.getXHR = function () {\\n\\t  if (root.XMLHttpRequest\\n\\t      && (!root.location || 'file:' != root.location.protocol\\n\\t          || !root.ActiveXObject)) {\\n\\t    return new XMLHttpRequest;\\n\\t  } else {\\n\\t    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\\n\\t    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\\n\\t    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\\n\\t    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\\n\\t  }\\n\\t  throw Error(\\\"Browser-only verison of superagent could not find XHR\\\");\\n\\t};\\n\\t\\n\\t/**\\n\\t * Removes leading and trailing whitespace, added to support IE.\\n\\t *\\n\\t * @param {String} s\\n\\t * @return {String}\\n\\t * @api private\\n\\t */\\n\\t\\n\\tvar trim = ''.trim\\n\\t  ? function(s) { return s.trim(); }\\n\\t  : function(s) { return s.replace(/(^\\\\s*|\\\\s*$)/g, ''); };\\n\\t\\n\\t/**\\n\\t * Serialize the given `obj`.\\n\\t *\\n\\t * @param {Object} obj\\n\\t * @return {String}\\n\\t * @api private\\n\\t */\\n\\t\\n\\tfunction serialize(obj) {\\n\\t  if (!isObject(obj)) return obj;\\n\\t  var pairs = [];\\n\\t  for (var key in obj) {\\n\\t    pushEncodedKeyValuePair(pairs, key, obj[key]);\\n\\t  }\\n\\t  return pairs.join('&');\\n\\t}\\n\\t\\n\\t/**\\n\\t * Helps 'serialize' with serializing arrays.\\n\\t * Mutates the pairs array.\\n\\t *\\n\\t * @param {Array} pairs\\n\\t * @param {String} key\\n\\t * @param {Mixed} val\\n\\t */\\n\\t\\n\\tfunction pushEncodedKeyValuePair(pairs, key, val) {\\n\\t  if (val != null) {\\n\\t    if (Array.isArray(val)) {\\n\\t      val.forEach(function(v) {\\n\\t        pushEncodedKeyValuePair(pairs, key, v);\\n\\t      });\\n\\t    } else if (isObject(val)) {\\n\\t      for(var subkey in val) {\\n\\t        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);\\n\\t      }\\n\\t    } else {\\n\\t      pairs.push(encodeURIComponent(key)\\n\\t        + '=' + encodeURIComponent(val));\\n\\t    }\\n\\t  } else if (val === null) {\\n\\t    pairs.push(encodeURIComponent(key));\\n\\t  }\\n\\t}\\n\\t\\n\\t/**\\n\\t * Expose serialization method.\\n\\t */\\n\\t\\n\\t request.serializeObject = serialize;\\n\\t\\n\\t /**\\n\\t  * Parse the given x-www-form-urlencoded `str`.\\n\\t  *\\n\\t  * @param {String} str\\n\\t  * @return {Object}\\n\\t  * @api private\\n\\t  */\\n\\t\\n\\tfunction parseString(str) {\\n\\t  var obj = {};\\n\\t  var pairs = str.split('&');\\n\\t  var pair;\\n\\t  var pos;\\n\\t\\n\\t  for (var i = 0, len = pairs.length; i < len; ++i) {\\n\\t    pair = pairs[i];\\n\\t    pos = pair.indexOf('=');\\n\\t    if (pos == -1) {\\n\\t      obj[decodeURIComponent(pair)] = '';\\n\\t    } else {\\n\\t      obj[decodeURIComponent(pair.slice(0, pos))] =\\n\\t        decodeURIComponent(pair.slice(pos + 1));\\n\\t    }\\n\\t  }\\n\\t\\n\\t  return obj;\\n\\t}\\n\\t\\n\\t/**\\n\\t * Expose parser.\\n\\t */\\n\\t\\n\\trequest.parseString = parseString;\\n\\t\\n\\t/**\\n\\t * Default MIME type map.\\n\\t *\\n\\t *     superagent.types.xml = 'application/xml';\\n\\t *\\n\\t */\\n\\t\\n\\trequest.types = {\\n\\t  html: 'text/html',\\n\\t  json: 'application/json',\\n\\t  xml: 'application/xml',\\n\\t  urlencoded: 'application/x-www-form-urlencoded',\\n\\t  'form': 'application/x-www-form-urlencoded',\\n\\t  'form-data': 'application/x-www-form-urlencoded'\\n\\t};\\n\\t\\n\\t/**\\n\\t * Default serialization map.\\n\\t *\\n\\t *     superagent.serialize['application/xml'] = function(obj){\\n\\t *       return 'generated xml here';\\n\\t *     };\\n\\t *\\n\\t */\\n\\t\\n\\t request.serialize = {\\n\\t   'application/x-www-form-urlencoded': serialize,\\n\\t   'application/json': JSON.stringify\\n\\t };\\n\\t\\n\\t /**\\n\\t  * Default parsers.\\n\\t  *\\n\\t  *     superagent.parse['application/xml'] = function(str){\\n\\t  *       return { object parsed from str };\\n\\t  *     };\\n\\t  *\\n\\t  */\\n\\t\\n\\trequest.parse = {\\n\\t  'application/x-www-form-urlencoded': parseString,\\n\\t  'application/json': JSON.parse\\n\\t};\\n\\t\\n\\t/**\\n\\t * Parse the given header `str` into\\n\\t * an object containing the mapped fields.\\n\\t *\\n\\t * @param {String} str\\n\\t * @return {Object}\\n\\t * @api private\\n\\t */\\n\\t\\n\\tfunction parseHeader(str) {\\n\\t  var lines = str.split(/\\\\r?\\\\n/);\\n\\t  var fields = {};\\n\\t  var index;\\n\\t  var line;\\n\\t  var field;\\n\\t  var val;\\n\\t\\n\\t  lines.pop(); // trailing CRLF\\n\\t\\n\\t  for (var i = 0, len = lines.length; i < len; ++i) {\\n\\t    line = lines[i];\\n\\t    index = line.indexOf(':');\\n\\t    field = line.slice(0, index).toLowerCase();\\n\\t    val = trim(line.slice(index + 1));\\n\\t    fields[field] = val;\\n\\t  }\\n\\t\\n\\t  return fields;\\n\\t}\\n\\t\\n\\t/**\\n\\t * Check if `mime` is json or has +json structured syntax suffix.\\n\\t *\\n\\t * @param {String} mime\\n\\t * @return {Boolean}\\n\\t * @api private\\n\\t */\\n\\t\\n\\tfunction isJSON(mime) {\\n\\t  return /[\\\\/+]json\\\\b/.test(mime);\\n\\t}\\n\\t\\n\\t/**\\n\\t * Initialize a new `Response` with the given `xhr`.\\n\\t *\\n\\t *  - set flags (.ok, .error, etc)\\n\\t *  - parse header\\n\\t *\\n\\t * Examples:\\n\\t *\\n\\t *  Aliasing `superagent` as `request` is nice:\\n\\t *\\n\\t *      request = superagent;\\n\\t *\\n\\t *  We can use the promise-like API, or pass callbacks:\\n\\t *\\n\\t *      request.get('/').end(function(res){});\\n\\t *      request.get('/', function(res){});\\n\\t *\\n\\t *  Sending data can be chained:\\n\\t *\\n\\t *      request\\n\\t *        .post('/user')\\n\\t *        .send({ name: 'tj' })\\n\\t *        .end(function(res){});\\n\\t *\\n\\t *  Or passed to `.send()`:\\n\\t *\\n\\t *      request\\n\\t *        .post('/user')\\n\\t *        .send({ name: 'tj' }, function(res){});\\n\\t *\\n\\t *  Or passed to `.post()`:\\n\\t *\\n\\t *      request\\n\\t *        .post('/user', { name: 'tj' })\\n\\t *        .end(function(res){});\\n\\t *\\n\\t * Or further reduced to a single call for simple cases:\\n\\t *\\n\\t *      request\\n\\t *        .post('/user', { name: 'tj' }, function(res){});\\n\\t *\\n\\t * @param {XMLHTTPRequest} xhr\\n\\t * @param {Object} options\\n\\t * @api private\\n\\t */\\n\\t\\n\\tfunction Response(req) {\\n\\t  this.req = req;\\n\\t  this.xhr = this.req.xhr;\\n\\t  // responseText is accessible only if responseType is '' or 'text' and on older browsers\\n\\t  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\\n\\t     ? this.xhr.responseText\\n\\t     : null;\\n\\t  this.statusText = this.req.xhr.statusText;\\n\\t  var status = this.xhr.status;\\n\\t  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\\n\\t  if (status === 1223) {\\n\\t      status = 204;\\n\\t  }\\n\\t  this._setStatusProperties(status);\\n\\t  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\\n\\t  // getAllResponseHeaders sometimes falsely returns \\\"\\\" for CORS requests, but\\n\\t  // getResponseHeader still works. so we get content-type even if getting\\n\\t  // other headers fails.\\n\\t  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\\n\\t  this._setHeaderProperties(this.header);\\n\\t\\n\\t  if (null === this.text && req._responseType) {\\n\\t    this.body = this.xhr.response;\\n\\t  } else {\\n\\t    this.body = this.req.method != 'HEAD'\\n\\t      ? this._parseBody(this.text ? this.text : this.xhr.response)\\n\\t      : null;\\n\\t  }\\n\\t}\\n\\t\\n\\tResponseBase(Response.prototype);\\n\\t\\n\\t/**\\n\\t * Parse the given body `str`.\\n\\t *\\n\\t * Used for auto-parsing of bodies. Parsers\\n\\t * are defined on the `superagent.parse` object.\\n\\t *\\n\\t * @param {String} str\\n\\t * @return {Mixed}\\n\\t * @api private\\n\\t */\\n\\t\\n\\tResponse.prototype._parseBody = function(str){\\n\\t  var parse = request.parse[this.type];\\n\\t  if(this.req._parser) {\\n\\t    return this.req._parser(this, str);\\n\\t  }\\n\\t  if (!parse && isJSON(this.type)) {\\n\\t    parse = request.parse['application/json'];\\n\\t  }\\n\\t  return parse && str && (str.length || str instanceof Object)\\n\\t    ? parse(str)\\n\\t    : null;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Return an `Error` representative of this response.\\n\\t *\\n\\t * @return {Error}\\n\\t * @api public\\n\\t */\\n\\t\\n\\tResponse.prototype.toError = function(){\\n\\t  var req = this.req;\\n\\t  var method = req.method;\\n\\t  var url = req.url;\\n\\t\\n\\t  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\\n\\t  var err = new Error(msg);\\n\\t  err.status = this.status;\\n\\t  err.method = method;\\n\\t  err.url = url;\\n\\t\\n\\t  return err;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Expose `Response`.\\n\\t */\\n\\t\\n\\trequest.Response = Response;\\n\\t\\n\\t/**\\n\\t * Initialize a new `Request` with the given `method` and `url`.\\n\\t *\\n\\t * @param {String} method\\n\\t * @param {String} url\\n\\t * @api public\\n\\t */\\n\\t\\n\\tfunction Request(method, url) {\\n\\t  var self = this;\\n\\t  this._query = this._query || [];\\n\\t  this.method = method;\\n\\t  this.url = url;\\n\\t  this.header = {}; // preserves header name case\\n\\t  this._header = {}; // coerces header names to lowercase\\n\\t  this.on('end', function(){\\n\\t    var err = null;\\n\\t    var res = null;\\n\\t\\n\\t    try {\\n\\t      res = new Response(self);\\n\\t    } catch(e) {\\n\\t      err = new Error('Parser is unable to parse the response');\\n\\t      err.parse = true;\\n\\t      err.original = e;\\n\\t      // issue #675: return the raw response if the response parsing fails\\n\\t      if (self.xhr) {\\n\\t        // ie9 doesn't have 'response' property\\n\\t        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;\\n\\t        // issue #876: return the http status code if the response parsing fails\\n\\t        err.status = self.xhr.status ? self.xhr.status : null;\\n\\t        err.statusCode = err.status; // backwards-compat only\\n\\t      } else {\\n\\t        err.rawResponse = null;\\n\\t        err.status = null;\\n\\t      }\\n\\t\\n\\t      return self.callback(err);\\n\\t    }\\n\\t\\n\\t    self.emit('response', res);\\n\\t\\n\\t    var new_err;\\n\\t    try {\\n\\t      if (!self._isResponseOK(res)) {\\n\\t        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\\n\\t        new_err.original = err;\\n\\t        new_err.response = res;\\n\\t        new_err.status = res.status;\\n\\t      }\\n\\t    } catch(e) {\\n\\t      new_err = e; // #985 touching res may cause INVALID_STATE_ERR on old Android\\n\\t    }\\n\\t\\n\\t    // #1000 don't catch errors from the callback to avoid double calling it\\n\\t    if (new_err) {\\n\\t      self.callback(new_err, res);\\n\\t    } else {\\n\\t      self.callback(null, res);\\n\\t    }\\n\\t  });\\n\\t}\\n\\t\\n\\t/**\\n\\t * Mixin `Emitter` and `RequestBase`.\\n\\t */\\n\\t\\n\\tEmitter(Request.prototype);\\n\\tRequestBase(Request.prototype);\\n\\t\\n\\t/**\\n\\t * Set Content-Type to `type`, mapping values from `request.types`.\\n\\t *\\n\\t * Examples:\\n\\t *\\n\\t *      superagent.types.xml = 'application/xml';\\n\\t *\\n\\t *      request.post('/')\\n\\t *        .type('xml')\\n\\t *        .send(xmlstring)\\n\\t *        .end(callback);\\n\\t *\\n\\t *      request.post('/')\\n\\t *        .type('application/xml')\\n\\t *        .send(xmlstring)\\n\\t *        .end(callback);\\n\\t *\\n\\t * @param {String} type\\n\\t * @return {Request} for chaining\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequest.prototype.type = function(type){\\n\\t  this.set('Content-Type', request.types[type] || type);\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Set Accept to `type`, mapping values from `request.types`.\\n\\t *\\n\\t * Examples:\\n\\t *\\n\\t *      superagent.types.json = 'application/json';\\n\\t *\\n\\t *      request.get('/agent')\\n\\t *        .accept('json')\\n\\t *        .end(callback);\\n\\t *\\n\\t *      request.get('/agent')\\n\\t *        .accept('application/json')\\n\\t *        .end(callback);\\n\\t *\\n\\t * @param {String} accept\\n\\t * @return {Request} for chaining\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequest.prototype.accept = function(type){\\n\\t  this.set('Accept', request.types[type] || type);\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Set Authorization field value with `user` and `pass`.\\n\\t *\\n\\t * @param {String} user\\n\\t * @param {String} [pass] optional in case of using 'bearer' as type\\n\\t * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')\\n\\t * @return {Request} for chaining\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequest.prototype.auth = function(user, pass, options){\\n\\t  if (typeof pass === 'object' && pass !== null) { // pass is optional and can substitute for options\\n\\t    options = pass;\\n\\t  }\\n\\t  if (!options) {\\n\\t    options = {\\n\\t      type: 'function' === typeof btoa ? 'basic' : 'auto',\\n\\t    }\\n\\t  }\\n\\t\\n\\t  switch (options.type) {\\n\\t    case 'basic':\\n\\t      this.set('Authorization', 'Basic ' + btoa(user + ':' + pass));\\n\\t    break;\\n\\t\\n\\t    case 'auto':\\n\\t      this.username = user;\\n\\t      this.password = pass;\\n\\t    break;\\n\\t      \\n\\t    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })\\n\\t      this.set('Authorization', 'Bearer ' + user);\\n\\t    break;  \\n\\t  }\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Add query-string `val`.\\n\\t *\\n\\t * Examples:\\n\\t *\\n\\t *   request.get('/shoes')\\n\\t *     .query('size=10')\\n\\t *     .query({ color: 'blue' })\\n\\t *\\n\\t * @param {Object|String} val\\n\\t * @return {Request} for chaining\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequest.prototype.query = function(val){\\n\\t  if ('string' != typeof val) val = serialize(val);\\n\\t  if (val) this._query.push(val);\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Queue the given `file` as an attachment to the specified `field`,\\n\\t * with optional `options` (or filename).\\n\\t *\\n\\t * ``` js\\n\\t * request.post('/upload')\\n\\t *   .attach('content', new Blob(['<a id=\\\"a\\\"><b id=\\\"b\\\">hey!</b></a>'], { type: \\\"text/html\\\"}))\\n\\t *   .end(callback);\\n\\t * ```\\n\\t *\\n\\t * @param {String} field\\n\\t * @param {Blob|File} file\\n\\t * @param {String|Object} options\\n\\t * @return {Request} for chaining\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequest.prototype.attach = function(field, file, options){\\n\\t  if (file) {\\n\\t    if (this._data) {\\n\\t      throw Error(\\\"superagent can't mix .send() and .attach()\\\");\\n\\t    }\\n\\t\\n\\t    this._getFormData().append(field, file, options || file.name);\\n\\t  }\\n\\t  return this;\\n\\t};\\n\\t\\n\\tRequest.prototype._getFormData = function(){\\n\\t  if (!this._formData) {\\n\\t    this._formData = new root.FormData();\\n\\t  }\\n\\t  return this._formData;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Invoke the callback with `err` and `res`\\n\\t * and handle arity check.\\n\\t *\\n\\t * @param {Error} err\\n\\t * @param {Response} res\\n\\t * @api private\\n\\t */\\n\\t\\n\\tRequest.prototype.callback = function(err, res){\\n\\t  // console.log(this._retries, this._maxRetries)\\n\\t  if (this._maxRetries && this._retries++ < this._maxRetries && shouldRetry(err, res)) {\\n\\t    return this._retry();\\n\\t  }\\n\\t\\n\\t  var fn = this._callback;\\n\\t  this.clearTimeout();\\n\\t\\n\\t  if (err) {\\n\\t    if (this._maxRetries) err.retries = this._retries - 1;\\n\\t    this.emit('error', err);\\n\\t  }\\n\\t\\n\\t  fn(err, res);\\n\\t};\\n\\t\\n\\t/**\\n\\t * Invoke callback with x-domain error.\\n\\t *\\n\\t * @api private\\n\\t */\\n\\t\\n\\tRequest.prototype.crossDomainError = function(){\\n\\t  var err = new Error('Request has been terminated\\\\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');\\n\\t  err.crossDomain = true;\\n\\t\\n\\t  err.status = this.status;\\n\\t  err.method = this.method;\\n\\t  err.url = this.url;\\n\\t\\n\\t  this.callback(err);\\n\\t};\\n\\t\\n\\t// This only warns, because the request is still likely to work\\n\\tRequest.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){\\n\\t  console.warn(\\\"This is not supported in browser version of superagent\\\");\\n\\t  return this;\\n\\t};\\n\\t\\n\\t// This throws, because it can't send/receive data as expected\\n\\tRequest.prototype.pipe = Request.prototype.write = function(){\\n\\t  throw Error(\\\"Streaming is not supported in browser version of superagent\\\");\\n\\t};\\n\\t\\n\\t/**\\n\\t * Compose querystring to append to req.url\\n\\t *\\n\\t * @api private\\n\\t */\\n\\t\\n\\tRequest.prototype._appendQueryString = function(){\\n\\t  var query = this._query.join('&');\\n\\t  if (query) {\\n\\t    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;\\n\\t  }\\n\\t\\n\\t  if (this._sort) {\\n\\t    var index = this.url.indexOf('?');\\n\\t    if (index >= 0) {\\n\\t      var queryArr = this.url.substring(index + 1).split('&');\\n\\t      if (isFunction(this._sort)) {\\n\\t        queryArr.sort(this._sort);\\n\\t      } else {\\n\\t        queryArr.sort();\\n\\t      }\\n\\t      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');\\n\\t    }\\n\\t  }\\n\\t};\\n\\t\\n\\t/**\\n\\t * Check if `obj` is a host object,\\n\\t * we don't want to serialize these :)\\n\\t *\\n\\t * @param {Object} obj\\n\\t * @return {Boolean}\\n\\t * @api private\\n\\t */\\n\\tRequest.prototype._isHost = function _isHost(obj) {\\n\\t  // Native objects stringify to [object File], [object Blob], [object FormData], etc.\\n\\t  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';\\n\\t}\\n\\t\\n\\t/**\\n\\t * Initiate request, invoking callback `fn(res)`\\n\\t * with an instanceof `Response`.\\n\\t *\\n\\t * @param {Function} fn\\n\\t * @return {Request} for chaining\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequest.prototype.end = function(fn){\\n\\t  if (this._endCalled) {\\n\\t    console.warn(\\\"Warning: .end() was called twice. This is not supported in superagent\\\");\\n\\t  }\\n\\t  this._endCalled = true;\\n\\t\\n\\t  // store callback\\n\\t  this._callback = fn || noop;\\n\\t\\n\\t  // querystring\\n\\t  this._appendQueryString();\\n\\t\\n\\t  return this._end();\\n\\t};\\n\\t\\n\\tRequest.prototype._end = function() {\\n\\t  var self = this;\\n\\t  var xhr = this.xhr = request.getXHR();\\n\\t  var data = this._formData || this._data;\\n\\t\\n\\t  this._setTimeouts();\\n\\t\\n\\t  // state change\\n\\t  xhr.onreadystatechange = function(){\\n\\t    var readyState = xhr.readyState;\\n\\t    if (readyState >= 2 && self._responseTimeoutTimer) {\\n\\t      clearTimeout(self._responseTimeoutTimer);\\n\\t    }\\n\\t    if (4 != readyState) {\\n\\t      return;\\n\\t    }\\n\\t\\n\\t    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\\n\\t    // result in the error \\\"Could not complete the operation due to error c00c023f\\\"\\n\\t    var status;\\n\\t    try { status = xhr.status } catch(e) { status = 0; }\\n\\t\\n\\t    if (!status) {\\n\\t      if (self.timedout || self._aborted) return;\\n\\t      return self.crossDomainError();\\n\\t    }\\n\\t    self.emit('end');\\n\\t  };\\n\\t\\n\\t  // progress\\n\\t  var handleProgress = function(direction, e) {\\n\\t    if (e.total > 0) {\\n\\t      e.percent = e.loaded / e.total * 100;\\n\\t    }\\n\\t    e.direction = direction;\\n\\t    self.emit('progress', e);\\n\\t  }\\n\\t  if (this.hasListeners('progress')) {\\n\\t    try {\\n\\t      xhr.onprogress = handleProgress.bind(null, 'download');\\n\\t      if (xhr.upload) {\\n\\t        xhr.upload.onprogress = handleProgress.bind(null, 'upload');\\n\\t      }\\n\\t    } catch(e) {\\n\\t      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\\n\\t      // Reported here:\\n\\t      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\\n\\t    }\\n\\t  }\\n\\t\\n\\t  // initiate request\\n\\t  try {\\n\\t    if (this.username && this.password) {\\n\\t      xhr.open(this.method, this.url, true, this.username, this.password);\\n\\t    } else {\\n\\t      xhr.open(this.method, this.url, true);\\n\\t    }\\n\\t  } catch (err) {\\n\\t    // see #1149\\n\\t    return this.callback(err);\\n\\t  }\\n\\t\\n\\t  // CORS\\n\\t  if (this._withCredentials) xhr.withCredentials = true;\\n\\t\\n\\t  // body\\n\\t  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {\\n\\t    // serialize stuff\\n\\t    var contentType = this._header['content-type'];\\n\\t    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];\\n\\t    if (!serialize && isJSON(contentType)) {\\n\\t      serialize = request.serialize['application/json'];\\n\\t    }\\n\\t    if (serialize) data = serialize(data);\\n\\t  }\\n\\t\\n\\t  // set header fields\\n\\t  for (var field in this.header) {\\n\\t    if (null == this.header[field]) continue;\\n\\t    xhr.setRequestHeader(field, this.header[field]);\\n\\t  }\\n\\t\\n\\t  if (this._responseType) {\\n\\t    xhr.responseType = this._responseType;\\n\\t  }\\n\\t\\n\\t  // send stuff\\n\\t  this.emit('request', this);\\n\\t\\n\\t  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)\\n\\t  // We need null here if data is undefined\\n\\t  xhr.send(typeof data !== 'undefined' ? data : null);\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * GET `url` with optional callback `fn(res)`.\\n\\t *\\n\\t * @param {String} url\\n\\t * @param {Mixed|Function} [data] or fn\\n\\t * @param {Function} [fn]\\n\\t * @return {Request}\\n\\t * @api public\\n\\t */\\n\\t\\n\\trequest.get = function(url, data, fn){\\n\\t  var req = request('GET', url);\\n\\t  if ('function' == typeof data) fn = data, data = null;\\n\\t  if (data) req.query(data);\\n\\t  if (fn) req.end(fn);\\n\\t  return req;\\n\\t};\\n\\t\\n\\t/**\\n\\t * HEAD `url` with optional callback `fn(res)`.\\n\\t *\\n\\t * @param {String} url\\n\\t * @param {Mixed|Function} [data] or fn\\n\\t * @param {Function} [fn]\\n\\t * @return {Request}\\n\\t * @api public\\n\\t */\\n\\t\\n\\trequest.head = function(url, data, fn){\\n\\t  var req = request('HEAD', url);\\n\\t  if ('function' == typeof data) fn = data, data = null;\\n\\t  if (data) req.send(data);\\n\\t  if (fn) req.end(fn);\\n\\t  return req;\\n\\t};\\n\\t\\n\\t/**\\n\\t * OPTIONS query to `url` with optional callback `fn(res)`.\\n\\t *\\n\\t * @param {String} url\\n\\t * @param {Mixed|Function} [data] or fn\\n\\t * @param {Function} [fn]\\n\\t * @return {Request}\\n\\t * @api public\\n\\t */\\n\\t\\n\\trequest.options = function(url, data, fn){\\n\\t  var req = request('OPTIONS', url);\\n\\t  if ('function' == typeof data) fn = data, data = null;\\n\\t  if (data) req.send(data);\\n\\t  if (fn) req.end(fn);\\n\\t  return req;\\n\\t};\\n\\t\\n\\t/**\\n\\t * DELETE `url` with optional `data` and callback `fn(res)`.\\n\\t *\\n\\t * @param {String} url\\n\\t * @param {Mixed} [data]\\n\\t * @param {Function} [fn]\\n\\t * @return {Request}\\n\\t * @api public\\n\\t */\\n\\t\\n\\tfunction del(url, data, fn){\\n\\t  var req = request('DELETE', url);\\n\\t  if ('function' == typeof data) fn = data, data = null;\\n\\t  if (data) req.send(data);\\n\\t  if (fn) req.end(fn);\\n\\t  return req;\\n\\t};\\n\\t\\n\\trequest['del'] = del;\\n\\trequest['delete'] = del;\\n\\t\\n\\t/**\\n\\t * PATCH `url` with optional `data` and callback `fn(res)`.\\n\\t *\\n\\t * @param {String} url\\n\\t * @param {Mixed} [data]\\n\\t * @param {Function} [fn]\\n\\t * @return {Request}\\n\\t * @api public\\n\\t */\\n\\t\\n\\trequest.patch = function(url, data, fn){\\n\\t  var req = request('PATCH', url);\\n\\t  if ('function' == typeof data) fn = data, data = null;\\n\\t  if (data) req.send(data);\\n\\t  if (fn) req.end(fn);\\n\\t  return req;\\n\\t};\\n\\t\\n\\t/**\\n\\t * POST `url` with optional `data` and callback `fn(res)`.\\n\\t *\\n\\t * @param {String} url\\n\\t * @param {Mixed} [data]\\n\\t * @param {Function} [fn]\\n\\t * @return {Request}\\n\\t * @api public\\n\\t */\\n\\t\\n\\trequest.post = function(url, data, fn){\\n\\t  var req = request('POST', url);\\n\\t  if ('function' == typeof data) fn = data, data = null;\\n\\t  if (data) req.send(data);\\n\\t  if (fn) req.end(fn);\\n\\t  return req;\\n\\t};\\n\\t\\n\\t/**\\n\\t * PUT `url` with optional `data` and callback `fn(res)`.\\n\\t *\\n\\t * @param {String} url\\n\\t * @param {Mixed|Function} [data] or fn\\n\\t * @param {Function} [fn]\\n\\t * @return {Request}\\n\\t * @api public\\n\\t */\\n\\t\\n\\trequest.put = function(url, data, fn){\\n\\t  var req = request('PUT', url);\\n\\t  if ('function' == typeof data) fn = data, data = null;\\n\\t  if (data) req.send(data);\\n\\t  if (fn) req.end(fn);\\n\\t  return req;\\n\\t};\\n\\n\\n/***/ },\\n/* 18 */\\n/***/ function(module, exports) {\\n\\n\\tvar WinChan = (function() {\\n\\t  var RELAY_FRAME_NAME = \\\"__winchan_relay_frame\\\";\\n\\t  var CLOSE_CMD = \\\"die\\\";\\n\\t\\n\\t  // a portable addListener implementation\\n\\t  function addListener(w, event, cb) {\\n\\t    if(w.attachEvent) w.attachEvent('on' + event, cb);\\n\\t    else if (w.addEventListener) w.addEventListener(event, cb, false);\\n\\t  }\\n\\t\\n\\t  // a portable removeListener implementation\\n\\t  function removeListener(w, event, cb) {\\n\\t    if(w.detachEvent) w.detachEvent('on' + event, cb);\\n\\t    else if (w.removeEventListener) w.removeEventListener(event, cb, false);\\n\\t  }\\n\\t\\n\\t\\n\\t  // checking for IE8 or above\\n\\t  function isInternetExplorer() {\\n\\t    if (typeof navigator === 'undefined') {\\n\\t      return false;\\n\\t    }\\n\\t\\n\\t    var rv = -1; // Return value assumes failure.\\n\\t    var ua = navigator.userAgent;\\n\\t    if (navigator.appName === 'Microsoft Internet Explorer') {\\n\\t      var re = new RegExp(\\\"MSIE ([0-9]{1,}[\\\\.0-9]{0,})\\\");\\n\\t      if (re.exec(ua) != null)\\n\\t        rv = parseFloat(RegExp.$1);\\n\\t    }\\n\\t    // IE > 11\\n\\t    else if (ua.indexOf(\\\"Trident\\\") > -1) {\\n\\t      var re = new RegExp(\\\"rv:([0-9]{2,2}[\\\\.0-9]{0,})\\\");\\n\\t      if (re.exec(ua) !== null) {\\n\\t        rv = parseFloat(RegExp.$1);\\n\\t      }\\n\\t    }\\n\\t\\n\\t    return rv >= 8;\\n\\t  }\\n\\t\\n\\t  // checking Mobile Firefox (Fennec)\\n\\t  function isFennec() {\\n\\t    try {\\n\\t      // We must check for both XUL and Java versions of Fennec.  Both have\\n\\t      // distinct UA strings.\\n\\t      var userAgent = navigator.userAgent;\\n\\t      return (userAgent.indexOf('Fennec/') != -1) ||  // XUL\\n\\t             (userAgent.indexOf('Firefox/') != -1 && userAgent.indexOf('Android') != -1);   // Java\\n\\t    } catch(e) {}\\n\\t    return false;\\n\\t  }\\n\\t\\n\\t  // feature checking to see if this platform is supported at all\\n\\t  function isSupported() {\\n\\t    return (typeof window !== 'undefined' && window.JSON && window.JSON.stringify &&\\n\\t            window.JSON.parse && window.postMessage);\\n\\t  }\\n\\t\\n\\t  // given a URL, extract the origin. Taken from: https://github.com/firebase/firebase-simple-login/blob/d2cb95b9f812d8488bdbfba51c3a7c153ba1a074/js/src/simple-login/transports/WinChan.js#L25-L30\\n\\t  function extractOrigin(url) {\\n\\t    if (!/^https?:\\\\/\\\\//.test(url)) url = window.location.href;\\n\\t    var m = /^(https?:\\\\/\\\\/[\\\\-_a-zA-Z\\\\.0-9:]+)/.exec(url);\\n\\t    if (m) return m[1];\\n\\t    return url;\\n\\t  }\\n\\t\\n\\t  // find the relay iframe in the opener\\n\\t  function findRelay() {\\n\\t    var loc = window.location;\\n\\t    var frames = window.opener.frames;\\n\\t    for (var i = frames.length - 1; i >= 0; i--) {\\n\\t      try {\\n\\t        if (frames[i].location.protocol === window.location.protocol &&\\n\\t            frames[i].location.host === window.location.host &&\\n\\t            frames[i].name === RELAY_FRAME_NAME)\\n\\t        {\\n\\t          return frames[i];\\n\\t        }\\n\\t      } catch(e) { }\\n\\t    }\\n\\t    return;\\n\\t  }\\n\\t\\n\\t  var isIE = isInternetExplorer();\\n\\t\\n\\t  if (isSupported()) {\\n\\t    /*  General flow:\\n\\t     *                  0. user clicks\\n\\t     *  (IE SPECIFIC)   1. caller adds relay iframe (served from trusted domain) to DOM\\n\\t     *                  2. caller opens window (with content from trusted domain)\\n\\t     *                  3. window on opening adds a listener to 'message'\\n\\t     *  (IE SPECIFIC)   4. window on opening finds iframe\\n\\t     *                  5. window checks if iframe is \\\"loaded\\\" - has a 'doPost' function yet\\n\\t     *  (IE SPECIFIC5)  5a. if iframe.doPost exists, window uses it to send ready event to caller\\n\\t     *  (IE SPECIFIC5)  5b. if iframe.doPost doesn't exist, window waits for frame ready\\n\\t     *  (IE SPECIFIC5)  5bi. once ready, window calls iframe.doPost to send ready event\\n\\t     *                  6. caller upon reciept of 'ready', sends args\\n\\t     */\\n\\t    return {\\n\\t      open: function(opts, cb) {\\n\\t        if (!cb) throw \\\"missing required callback argument\\\";\\n\\t\\n\\t        // test required options\\n\\t        var err;\\n\\t        if (!opts.url) err = \\\"missing required 'url' parameter\\\";\\n\\t        if (!opts.relay_url) err = \\\"missing required 'relay_url' parameter\\\";\\n\\t        if (err) setTimeout(function() { cb(err); }, 0);\\n\\t\\n\\t        // supply default options\\n\\t        if (!opts.window_name) opts.window_name = null;\\n\\t        if (!opts.window_features || isFennec()) opts.window_features = undefined;\\n\\t\\n\\t        // opts.params may be undefined\\n\\t\\n\\t        var iframe;\\n\\t\\n\\t        // sanity check, are url and relay_url the same origin?\\n\\t        var origin = opts.origin || extractOrigin(opts.url);\\n\\t        if (origin !== extractOrigin(opts.relay_url)) {\\n\\t          return setTimeout(function() {\\n\\t            cb('invalid arguments: origin of url and relay_url must match');\\n\\t          }, 0);\\n\\t        }\\n\\t\\n\\t        var messageTarget;\\n\\t\\n\\t        if (isIE) {\\n\\t          // first we need to add a \\\"relay\\\" iframe to the document that's served\\n\\t          // from the target domain.  We can postmessage into a iframe, but not a\\n\\t          // window\\n\\t          iframe = document.createElement(\\\"iframe\\\");\\n\\t          // iframe.setAttribute('name', framename);\\n\\t          iframe.setAttribute('src', opts.relay_url);\\n\\t          iframe.style.display = \\\"none\\\";\\n\\t          iframe.setAttribute('name', RELAY_FRAME_NAME);\\n\\t          document.body.appendChild(iframe);\\n\\t          messageTarget = iframe.contentWindow;\\n\\t        }\\n\\t\\n\\t        var w = opts.popup || window.open(opts.url, opts.window_name, opts.window_features);\\n\\t        if (opts.popup) {\\n\\t          w.location.href = opts.url;\\n\\t        }\\n\\t\\n\\t        if (!messageTarget) messageTarget = w;\\n\\t\\n\\t        // lets listen in case the window blows up before telling us\\n\\t        var closeInterval = setInterval(function() {\\n\\t          if (w && w.closed) {\\n\\t            cleanup();\\n\\t            if (cb) {\\n\\t              cb('User closed the popup window');\\n\\t              cb = null;\\n\\t            }\\n\\t          }\\n\\t        }, 500);\\n\\t\\n\\t        var req = JSON.stringify({a: 'request', d: opts.params});\\n\\t\\n\\t        // cleanup on unload\\n\\t        function cleanup() {\\n\\t          if (iframe) document.body.removeChild(iframe);\\n\\t          iframe = undefined;\\n\\t          if (closeInterval) closeInterval = clearInterval(closeInterval);\\n\\t          removeListener(window, 'message', onMessage);\\n\\t          removeListener(window, 'unload', cleanup);\\n\\t          if (w) {\\n\\t            try {\\n\\t              w.close();\\n\\t            } catch (securityViolation) {\\n\\t              // This happens in Opera 12 sometimes\\n\\t              // see https://github.com/mozilla/browserid/issues/1844\\n\\t              messageTarget.postMessage(CLOSE_CMD, origin);\\n\\t            }\\n\\t          }\\n\\t          w = messageTarget = undefined;\\n\\t        }\\n\\t\\n\\t        addListener(window, 'unload', cleanup);\\n\\t\\n\\t        function onMessage(e) {\\n\\t          if (e.origin !== origin) { return; }\\n\\t          try {\\n\\t            var d = JSON.parse(e.data);\\n\\t          } catch(err) {\\n\\t            if (cb) {\\n\\t              cb(err);\\n\\t            } else {\\n\\t              throw err;\\n\\t            }\\n\\t          }\\n\\t\\n\\t          if (d.a === 'ready') {\\n\\t            messageTarget.postMessage(req, origin);\\n\\t          } else if (d.a === 'error') {\\n\\t            cleanup();\\n\\t            if (cb) {\\n\\t              cb(d.d);\\n\\t              cb = null;\\n\\t            }\\n\\t          } else if (d.a === 'response') {\\n\\t            cleanup();\\n\\t            if (cb) {\\n\\t              cb(null, d.d);\\n\\t              cb = null;\\n\\t            }\\n\\t          }\\n\\t        }\\n\\t\\n\\t        addListener(window, 'message', onMessage);\\n\\t\\n\\t        return {\\n\\t          close: cleanup,\\n\\t          focus: function() {\\n\\t            if (w) {\\n\\t              try {\\n\\t                w.focus();\\n\\t              } catch (e) {\\n\\t                // IE7 blows up here, do nothing\\n\\t              }\\n\\t            }\\n\\t          }\\n\\t        };\\n\\t      },\\n\\t      onOpen: function(cb) {\\n\\t        var o = \\\"*\\\";\\n\\t        var msgTarget = isIE ? findRelay() : window.opener;\\n\\t        if (!msgTarget) throw \\\"can't find relay frame\\\";\\n\\t        function doPost(msg) {\\n\\t          msg = JSON.stringify(msg);\\n\\t          if (isIE) msgTarget.doPost(msg, o);\\n\\t          else msgTarget.postMessage(msg, o);\\n\\t        }\\n\\t\\n\\t        function onMessage(e) {\\n\\t          // only one message gets through, but let's make sure it's actually\\n\\t          // the message we're looking for (other code may be using\\n\\t          // postmessage) - we do this by ensuring the payload can\\n\\t          // be parsed, and it's got an 'a' (action) value of 'request'.\\n\\t          var d;\\n\\t          try {\\n\\t            d = JSON.parse(e.data);\\n\\t          } catch(err) { }\\n\\t          if (!d || d.a !== 'request') return;\\n\\t          removeListener(window, 'message', onMessage);\\n\\t          o = e.origin;\\n\\t          if (cb) {\\n\\t            // this setTimeout is critically important for IE8 -\\n\\t            // in ie8 sometimes addListener for 'message' can synchronously\\n\\t            // cause your callback to be invoked.  awesome.\\n\\t            setTimeout(function() {\\n\\t              cb(o, d.d, function(r) {\\n\\t                cb = undefined;\\n\\t                doPost({a: 'response', d: r});\\n\\t              });\\n\\t            }, 0);\\n\\t          }\\n\\t        }\\n\\t\\n\\t        function onDie(e) {\\n\\t          if (e.data === CLOSE_CMD) {\\n\\t            try { window.close(); } catch (o_O) {}\\n\\t          }\\n\\t        }\\n\\t        addListener(isIE ? msgTarget : window, 'message', onMessage);\\n\\t        addListener(isIE ? msgTarget : window, 'message', onDie);\\n\\t\\n\\t        // we cannot post to our parent that we're ready before the iframe\\n\\t        // is loaded. (IE specific possible failure)\\n\\t        try {\\n\\t          doPost({a: \\\"ready\\\"});\\n\\t        } catch(e) {\\n\\t          // this code should never be exectued outside IE\\n\\t          addListener(msgTarget, 'load', function(e) {\\n\\t            doPost({a: \\\"ready\\\"});\\n\\t          });\\n\\t        }\\n\\t\\n\\t        // if window is unloaded and the client hasn't called cb, it's an error\\n\\t        var onUnload = function() {\\n\\t          try {\\n\\t            // IE8 doesn't like this...\\n\\t            removeListener(isIE ? msgTarget : window, 'message', onDie);\\n\\t          } catch (ohWell) { }\\n\\t          if (cb) doPost({ a: 'error', d: 'client closed window' });\\n\\t          cb = undefined;\\n\\t          // explicitly close the window, in case the client is trying to reload or nav\\n\\t          try { window.close(); } catch (e) { }\\n\\t        };\\n\\t        addListener(window, 'unload', onUnload);\\n\\t        return {\\n\\t          detach: function() {\\n\\t            removeListener(window, 'unload', onUnload);\\n\\t          }\\n\\t        };\\n\\t      }\\n\\t    };\\n\\t  } else {\\n\\t    return {\\n\\t      open: function(url, winopts, arg, cb) {\\n\\t        setTimeout(function() { cb(\\\"unsupported browser\\\"); }, 0);\\n\\t      },\\n\\t      onOpen: function(cb) {\\n\\t        setTimeout(function() { cb(\\\"unsupported browser\\\"); }, 0);\\n\\t      }\\n\\t    };\\n\\t  }\\n\\t})();\\n\\t\\n\\tif (typeof module !== 'undefined' && module.exports) {\\n\\t  module.exports = WinChan;\\n\\t}\\n\\n\\n/***/ },\\n/* 19 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar urljoin = __webpack_require__(1);\\n\\t\\n\\tvar RequestBuilder = __webpack_require__(10);\\n\\tvar qs = __webpack_require__(5);\\n\\tvar objectHelper = __webpack_require__(2);\\n\\tvar assert = __webpack_require__(4);\\n\\tvar responseHandler = __webpack_require__(6);\\n\\tvar parametersWhitelist = __webpack_require__(45);\\n\\tvar Warn = __webpack_require__(11);\\n\\t\\n\\tvar PasswordlessAuthentication = __webpack_require__(41);\\n\\tvar DBConnection = __webpack_require__(40);\\n\\t\\n\\t/**\\n\\t * Creates a new Auth0 Authentication API client\\n\\t * @constructor\\n\\t * @param {Object} options\\n\\t * @param {String} options.domain your Auth0 domain\\n\\t * @param {String} options.clientID your Auth0 client identifier obtained when creating the client in the Auth0 Dashboard\\n\\t * @param {String} [options.redirectUri] url that the Auth0 will redirect after Auth with the Authorization Response\\n\\t * @param {String} [options.responseType] type of the response used by OAuth 2.0 flow. It can be any space separated list of the values `code`, `token`, `id_token`. {@link https://openid.net/specs/oauth-v2-multiple-response-types-1_0}\\n\\t * @param {String} [options.responseMode] how the Auth response is encoded and redirected back to the client. Supported values are `query`, `fragment` and `form_post`. {@link https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#ResponseModes}\\n\\t * @param {String} [options.scope] scopes to be requested during Auth. e.g. `openid email`\\n\\t * @param {String} [options.audience] identifier of the resource server who will consume the access token issued after Auth\\n\\t * @see {@link https://auth0.com/docs/api/authentication}\\n\\t */\\n\\tfunction Authentication(options) {\\n\\t  /* eslint-disable */\\n\\t  assert.check(\\n\\t    options,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      domain: { type: 'string', message: 'domain option is required' },\\n\\t      clientID: { type: 'string', message: 'clientID option is required' },\\n\\t      responseType: { optional: true, type: 'string', message: 'responseType is not valid' },\\n\\t      responseMode: { optional: true, type: 'string', message: 'responseMode is not valid' },\\n\\t      redirectUri: { optional: true, type: 'string', message: 'redirectUri is not valid' },\\n\\t      scope: { optional: true, type: 'string', message: 'scope is not valid' },\\n\\t      audience: { optional: true, type: 'string', message: 'audience is not valid' },\\n\\t      _disableDeprecationWarnings: {\\n\\t        optional: true,\\n\\t        type: 'boolean',\\n\\t        message: '_disableDeprecationWarnings option is not valid'\\n\\t      },\\n\\t      _sendTelemetry: {\\n\\t        optional: true,\\n\\t        type: 'boolean',\\n\\t        message: '_sendTelemetry option is not valid'\\n\\t      },\\n\\t      _telemetryInfo: {\\n\\t        optional: true,\\n\\t        type: 'object',\\n\\t        message: '_telemetryInfo option is not valid'\\n\\t      }\\n\\t    }\\n\\t  );\\n\\t  /* eslint-enable */\\n\\t\\n\\t  this.baseOptions = options;\\n\\t\\n\\t  this.baseOptions._sendTelemetry = this.baseOptions._sendTelemetry === false\\n\\t    ? this.baseOptions._sendTelemetry\\n\\t    : true;\\n\\t\\n\\t  this.baseOptions.rootUrl = 'https://' + this.baseOptions.domain;\\n\\t\\n\\t  this.request = new RequestBuilder(this.baseOptions);\\n\\t\\n\\t  this.passwordless = new PasswordlessAuthentication(this.request, this.baseOptions);\\n\\t  this.dbConnection = new DBConnection(this.request, this.baseOptions);\\n\\t\\n\\t  this.warn = new Warn({\\n\\t    disableWarnings: !!options._disableDeprecationWarnings\\n\\t  });\\n\\t}\\n\\t\\n\\t/**\\n\\t * Builds and returns the `/authorize` url in order to initialize a new authN/authZ transaction\\n\\t *\\n\\t * @method buildAuthorizeUrl\\n\\t * @param {Object} options\\n\\t * @param {String} [options.domain] your Auth0 domain\\n\\t * @param {String} [options.clientID] your Auth0 client identifier obtained when creating the client in the Auth0 Dashboard\\n\\t * @param {String} options.redirectUri url that the Auth0 will redirect after Auth with the Authorization Response\\n\\t * @param {String} options.responseType type of the response used by OAuth 2.0 flow. It can be any space separated list of the values `code`, `token`, `id_token`. {@link https://openid.net/specs/oauth-v2-multiple-response-types-1_0}\\n\\t * @param {String} [options.responseMode] how the Auth response is encoded and redirected back to the client. Supported values are `query`, `fragment` and `form_post`. {@link https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#ResponseModes}\\n\\t * @param {String} [options.state] value used to mitigate XSRF attacks. {@link https://auth0.com/docs/protocols/oauth2/oauth-state}\\n\\t * @param {String} [options.nonce] value used to mitigate replay attacks when using Implicit Grant. {@link https://auth0.com/docs/api-auth/tutorials/nonce}\\n\\t * @param {String} [options.scope] scopes to be requested during Auth. e.g. `openid email`\\n\\t * @param {String} [options.audience] identifier of the resource server who will consume the access token issued after Auth\\n\\t * @see {@link https://auth0.com/docs/api/authentication#authorize-client}\\n\\t * @see {@link https://auth0.com/docs/api/authentication#social}\\n\\t */\\n\\tAuthentication.prototype.buildAuthorizeUrl = function(options) {\\n\\t  var params;\\n\\t  var qString;\\n\\t\\n\\t  assert.check(options, { type: 'object', message: 'options parameter is not valid' });\\n\\t\\n\\t  params = objectHelper\\n\\t    .merge(this.baseOptions, [\\n\\t      'clientID',\\n\\t      'responseType',\\n\\t      'responseMode',\\n\\t      'redirectUri',\\n\\t      'scope',\\n\\t      'audience'\\n\\t    ])\\n\\t    .with(options);\\n\\t\\n\\t  /* eslint-disable */\\n\\t  assert.check(\\n\\t    params,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      clientID: { type: 'string', message: 'clientID option is required' },\\n\\t      redirectUri: { optional: true, type: 'string', message: 'redirectUri option is required' },\\n\\t      responseType: { type: 'string', message: 'responseType option is required' },\\n\\t      nonce: {\\n\\t        type: 'string',\\n\\t        message: 'nonce option is required',\\n\\t        condition: function(o) {\\n\\t          return o.responseType.indexOf('code') === -1 && o.responseType.indexOf('id_token') !== -1;\\n\\t        }\\n\\t      },\\n\\t      scope: { optional: true, type: 'string', message: 'scope option is required' },\\n\\t      audience: { optional: true, type: 'string', message: 'audience option is required' }\\n\\t    }\\n\\t  );\\n\\t  /* eslint-enable */\\n\\t\\n\\t  // eslint-disable-next-line\\n\\t  if (this.baseOptions._sendTelemetry) {\\n\\t    params.auth0Client = this.request.getTelemetryData();\\n\\t  }\\n\\t\\n\\t  if (params.connection_scope && assert.isArray(params.connection_scope)) {\\n\\t    params.connection_scope = params.connection_scope.join(',');\\n\\t  }\\n\\t\\n\\t  params = objectHelper.toSnakeCase(params, ['auth0Client']);\\n\\t  params = parametersWhitelist.oauthAuthorizeParams(this.warn, params);\\n\\t\\n\\t  qString = qs.stringify(params);\\n\\t\\n\\t  return urljoin(this.baseOptions.rootUrl, 'authorize', '?' + qString);\\n\\t};\\n\\t\\n\\t/**\\n\\t * Builds and returns the Logout url in order to initialize a new authN/authZ transaction\\n\\t *\\n\\t * If you want to navigate the user to a specific URL after the logout, set that URL at the returnTo parameter. The URL should be included in any the appropriate Allowed Logout URLs list:\\n\\t *\\n\\t * - If the client_id parameter is included, the returnTo URL must be listed in the Allowed Logout URLs set at the client level (see Setting Allowed Logout URLs at the App Level).\\n\\t * - If the client_id parameter is NOT included, the returnTo URL must be listed in the Allowed Logout URLs set at the account level (see Setting Allowed Logout URLs at the Account Level).\\n\\t * @method buildLogoutUrl\\n\\t * @param {Object} options\\n\\t * @param {String} [options.clientID] identifier of your client\\n\\t * @param {String} [options.returnTo] URL to be redirected after the logout\\n\\t * @param {Boolean} [options.federated] tells Auth0 if it should logout the user also from the IdP.\\n\\t * @see {@link https://auth0.com/docs/api/authentication#logout}\\n\\t */\\n\\tAuthentication.prototype.buildLogoutUrl = function(options) {\\n\\t  var params;\\n\\t  var qString;\\n\\t\\n\\t  assert.check(options, {\\n\\t    optional: true,\\n\\t    type: 'object',\\n\\t    message: 'options parameter is not valid'\\n\\t  });\\n\\t\\n\\t  params = objectHelper.merge(this.baseOptions, ['clientID']).with(options || {});\\n\\t\\n\\t  // eslint-disable-next-line\\n\\t  if (this.baseOptions._sendTelemetry) {\\n\\t    params.auth0Client = this.request.getTelemetryData();\\n\\t  }\\n\\t\\n\\t  params = objectHelper.toSnakeCase(params, ['auth0Client', 'returnTo']);\\n\\t\\n\\t  qString = qs.stringify(params);\\n\\t\\n\\t  return urljoin(this.baseOptions.rootUrl, 'v2', 'logout', '?' + qString);\\n\\t};\\n\\t\\n\\t/**\\n\\t * @callback authorizeCallback\\n\\t * @param {Error} [err] error returned by Auth0 with the reason of the Auth failure\\n\\t * @param {Object} [result] result of the Auth request\\n\\t * @param {String} [result.accessToken] token that allows access to the specified resource server (identified by the audience parameter or by default Auth0's /userinfo endpoint)\\n\\t * @param {Number} [result.expiresIn] number of seconds until the access token expires\\n\\t * @param {String} [result.idToken] token that identifies the user\\n\\t * @param {String} [result.refreshToken] token that can be used to get new access tokens from Auth0. Note that not all clients can request them or the resource server might not allow them.\\n\\t */\\n\\t\\n\\t/**\\n\\t * @callback tokenCallback\\n\\t * @param {Error} [err] error returned by Auth0 with the reason of the Auth failure\\n\\t * @param {Object} [result] result of the Auth request\\n\\t * @param {String} result.accessToken token that allows access to the specified resource server (identified by the audience parameter or by default Auth0's /userinfo endpoint)\\n\\t * @param {Number} result.expiresIn number of seconds until the access token expires\\n\\t * @param {String} [result.idToken] token that identifies the user\\n\\t * @param {String} [result.refreshToken] token that can be used to get new access tokens from Auth0. Note that not all clients can request them or the resource server might not allow them.\\n\\t */\\n\\t\\n\\t/**\\n\\t * Makes a call to the `oauth/token` endpoint with `password` grant type to login to the default directory.\\n\\t *\\n\\t * @method loginWithDefaultDirectory\\n\\t * @param {Object} options\\n\\t * @param {String} options.username email or username of the user that will perform Auth\\n\\t * @param {String} options.password the password of the user that will perform Auth\\n\\t * @param {String} [options.scope] scopes to be requested during Auth. e.g. `openid email`\\n\\t * @param {String} [options.audience] identifier of the resource server who will consume the access token issued after Auth\\n\\t * @param {tokenCallback} cb function called with the result of the request\\n\\t * @see   {@link https://auth0.com/docs/api-auth/grant/password}\\n\\t */\\n\\tAuthentication.prototype.loginWithDefaultDirectory = function(options, cb) {\\n\\t  assert.check(\\n\\t    options,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      username: { type: 'string', message: 'username option is required' },\\n\\t      password: { type: 'string', message: 'password option is required' },\\n\\t      scope: { optional: true, type: 'string', message: 'scope option is required' },\\n\\t      audience: { optional: true, type: 'string', message: 'audience option is required' }\\n\\t    }\\n\\t  );\\n\\t\\n\\t  options.grantType = 'password';\\n\\t\\n\\t  return this.oauthToken(options, cb);\\n\\t};\\n\\t\\n\\t/**\\n\\t * Makes a call to the `oauth/token` endpoint with `password-realm` grant type\\n\\t *\\n\\t * @method login\\n\\t * @param {Object} options\\n\\t * @param {String} options.username email or username of the user that will perform Auth\\n\\t * @param {String} options.password the password of the user that will perform Auth\\n\\t * @param {String} [options.scope] scopes to be requested during Auth. e.g. `openid email`\\n\\t * @param {String} [options.audience] identifier of the resource server who will consume the access token issued after Auth\\n\\t * @param {Object} options.realm the HRD domain or the connection name where the user belongs to. e.g. `Username-Password-Authentication`\\n\\t * @param {tokenCallback} cb function called with the result of the request\\n\\t * @see   {@link https://auth0.com/docs/api-auth/grant/password}\\n\\t */\\n\\tAuthentication.prototype.login = function(options, cb) {\\n\\t  assert.check(\\n\\t    options,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      username: { type: 'string', message: 'username option is required' },\\n\\t      password: { type: 'string', message: 'password option is required' },\\n\\t      realm: { type: 'string', message: 'realm option is required' },\\n\\t      scope: { optional: true, type: 'string', message: 'scope option is required' },\\n\\t      audience: { optional: true, type: 'string', message: 'audience option is required' }\\n\\t    }\\n\\t  );\\n\\t\\n\\t  options.grantType = 'http://auth0.com/oauth/grant-type/password-realm';\\n\\t\\n\\t  return this.oauthToken(options, cb);\\n\\t};\\n\\t\\n\\t/**\\n\\t * Makes a call to the `oauth/token` endpoint\\n\\t *\\n\\t * @method oauthToken\\n\\t * @private\\n\\t */\\n\\tAuthentication.prototype.oauthToken = function(options, cb) {\\n\\t  var url;\\n\\t  var body;\\n\\t\\n\\t  assert.check(options, { type: 'object', message: 'options parameter is not valid' });\\n\\t  assert.check(cb, { type: 'function', message: 'cb parameter is not valid' });\\n\\t\\n\\t  url = urljoin(this.baseOptions.rootUrl, 'oauth', 'token');\\n\\t\\n\\t  body = objectHelper.merge(this.baseOptions, ['clientID', 'scope', 'audience']).with(options);\\n\\t\\n\\t  assert.check(\\n\\t    body,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      clientID: { type: 'string', message: 'clientID option is required' },\\n\\t      grantType: { type: 'string', message: 'grantType option is required' },\\n\\t      scope: { optional: true, type: 'string', message: 'scope option is required' },\\n\\t      audience: { optional: true, type: 'string', message: 'audience option is required' }\\n\\t    }\\n\\t  );\\n\\t\\n\\t  body = objectHelper.toSnakeCase(body, ['auth0Client']);\\n\\t  body = parametersWhitelist.oauthTokenParams(this.warn, body);\\n\\t\\n\\t  body.grant_type = body.grant_type;\\n\\t\\n\\t  return this.request.post(url).send(body).end(responseHandler(cb));\\n\\t};\\n\\t\\n\\t/**\\n\\t * Performs authentication calling `/oauth/ro` endpoint with username\\n\\t * and password for a given connection name.\\n\\t *\\n\\t * This method is not compatible with API Auth so if you need to fetch API tokens with audience\\n\\t * you should use {@link login} or {@link loginWithDefaultDirectory}.\\n\\t *\\n\\t * @method loginWithResourceOwner\\n\\t * @param {Object} options\\n\\t * @param {String} options.username email or username of the user that will perform Auth\\n\\t * @param {String} options.password the password of the user that will perform Auth\\n\\t * @param {Object} options.connection the connection name where the user belongs to. e.g. `Username-Password-Authentication`\\n\\t * @param {String} [options.scope] scopes to be requested during Auth. e.g. `openid email`\\n\\t * @param {String} [options.device] name of the device/browser where the Auth was requested\\n\\t * @param {tokenCallback} cb function called with the result of the request\\n\\t */\\n\\tAuthentication.prototype.loginWithResourceOwner = function(options, cb) {\\n\\t  var url;\\n\\t  var body;\\n\\t\\n\\t  assert.check(\\n\\t    options,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      username: { type: 'string', message: 'username option is required' },\\n\\t      password: { type: 'string', message: 'password option is required' },\\n\\t      connection: { type: 'string', message: 'connection option is required' },\\n\\t      scope: { optional: true, type: 'string', message: 'scope option is required' }\\n\\t    }\\n\\t  );\\n\\t  assert.check(cb, { type: 'function', message: 'cb parameter is not valid' });\\n\\t\\n\\t  url = urljoin(this.baseOptions.rootUrl, 'oauth', 'ro');\\n\\t\\n\\t  body = objectHelper\\n\\t    .merge(this.baseOptions, ['clientID', 'scope'])\\n\\t    .with(options, ['username', 'password', 'scope', 'connection', 'device']);\\n\\t\\n\\t  body = objectHelper.toSnakeCase(body, ['auth0Client']);\\n\\t\\n\\t  body.grant_type = body.grant_type || 'password';\\n\\t\\n\\t  return this.request.post(url).send(body).end(responseHandler(cb));\\n\\t};\\n\\t\\n\\t/**\\n\\t * Makes a call to the `/ssodata` endpoint.\\n\\t * We recommend to avoid using this method and rely on your tenant hosted login page and using prompt=none via {@link renewAuth} method.\\n\\t *\\n\\t * @method getSSOData\\n\\t * @param {Boolean} withActiveDirectories tells Auth0 to return AD data\\n\\t * @param {Function} cb\\n\\t */\\n\\tAuthentication.prototype.getSSOData = function(withActiveDirectories, cb) {\\n\\t  var url;\\n\\t  var params = '';\\n\\t\\n\\t  if (typeof withActiveDirectories === 'function') {\\n\\t    cb = withActiveDirectories;\\n\\t    withActiveDirectories = false;\\n\\t  }\\n\\t\\n\\t  assert.check(withActiveDirectories, {\\n\\t    type: 'boolean',\\n\\t    message: 'withActiveDirectories parameter is not valid'\\n\\t  });\\n\\t  assert.check(cb, { type: 'function', message: 'cb parameter is not valid' });\\n\\t\\n\\t  if (withActiveDirectories) {\\n\\t    params =\\n\\t      '?' +\\n\\t      qs.stringify({\\n\\t        ldaps: 1,\\n\\t        client_id: this.baseOptions.clientID\\n\\t      });\\n\\t  }\\n\\t\\n\\t  url = urljoin(this.baseOptions.rootUrl, 'user', 'ssodata', params);\\n\\t\\n\\t  return this.request.get(url, { noHeaders: true }).withCredentials().end(responseHandler(cb));\\n\\t};\\n\\t\\n\\t/**\\n\\t * @callback userInfoCallback\\n\\t * @param {Error} [err] error returned by Auth0\\n\\t * @param {Object} [userInfo] user information\\n\\t */\\n\\t\\n\\t/**\\n\\t * Makes a call to the `/userinfo` endpoint and returns the user profile\\n\\t *\\n\\t * @method userInfo\\n\\t * @param {String} accessToken token issued to a user after Auth\\n\\t * @param {userInfoCallback} cb\\n\\t * @see   {@link https://auth0.com/docs/api/authentication#get-user-info}\\n\\t */\\n\\tAuthentication.prototype.userInfo = function(accessToken, cb) {\\n\\t  var url;\\n\\t\\n\\t  assert.check(accessToken, { type: 'string', message: 'accessToken parameter is not valid' });\\n\\t  assert.check(cb, { type: 'function', message: 'cb parameter is not valid' });\\n\\t\\n\\t  url = urljoin(this.baseOptions.rootUrl, 'userinfo');\\n\\t\\n\\t  return this.request\\n\\t    .get(url)\\n\\t    .set('Authorization', 'Bearer ' + accessToken)\\n\\t    .end(responseHandler(cb, { ignoreCasing: true }));\\n\\t};\\n\\t\\n\\t/**\\n\\t * @callback delegationCallback\\n\\t * @param {Error} [err] error returned by Auth0 with the reason why the delegation failed\\n\\t * @param {Object} [result] result of the delegation request. The payload depends on what ai type was used\\n\\t */\\n\\t\\n\\t/**\\n\\t * Makes a call to the `/delegation` endpoint with either an `id_token` or `refresh_token`\\n\\t *\\n\\t * @method delegation\\n\\t * @param {Object} options\\n\\t * @param {String} [options.clientID] client identifier\\n\\t * @param {String} options.grantType  grant type used for delegation. The only valid value is `urn:ietf:params:oauth:grant-type:jwt-bearer`\\n\\t * @param {String} [options.idToken] valid token of the user issued after Auth. If no `refresh_token` is provided this parameter is required\\n\\t * @param {String} [options.refreshToken] valid refresh token of the user issued after Auth. If no `id_token` is provided this parameter is required\\n\\t * @param {String} [options.target] the target client id of the delegation\\n\\t * @param {String} [options.scope] either `openid` or `openid profile email`\\n\\t * @param {String} [options.apiType] the api to be called\\n\\t * @param {delegationCallback} cb\\n\\t * @see   {@link https://auth0.com/docs/api/authentication#delegation}\\n\\t */\\n\\tAuthentication.prototype.delegation = function(options, cb) {\\n\\t  var url;\\n\\t  var body;\\n\\t\\n\\t  assert.check(\\n\\t    options,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      grant_type: { type: 'string', message: 'grant_type option is required' }\\n\\t    }\\n\\t  );\\n\\t  assert.check(cb, { type: 'function', message: 'cb parameter is not valid' });\\n\\t\\n\\t  url = urljoin(this.baseOptions.rootUrl, 'delegation');\\n\\t\\n\\t  body = objectHelper.merge(this.baseOptions, ['clientID']).with(options);\\n\\t\\n\\t  body = objectHelper.toSnakeCase(body, ['auth0Client']);\\n\\t\\n\\t  return this.request.post(url).send(body).end(responseHandler(cb));\\n\\t};\\n\\t\\n\\t/**\\n\\t * Fetches the user country based on the ip.\\n\\t *\\n\\t * @method getUserCountry\\n\\t * @private\\n\\t * @param {Function} cb\\n\\t */\\n\\tAuthentication.prototype.getUserCountry = function(cb) {\\n\\t  var url;\\n\\t\\n\\t  assert.check(cb, { type: 'function', message: 'cb parameter is not valid' });\\n\\t\\n\\t  url = urljoin(this.baseOptions.rootUrl, 'user', 'geoloc', 'country');\\n\\t\\n\\t  return this.request.get(url).end(responseHandler(cb));\\n\\t};\\n\\t\\n\\tmodule.exports = Authentication;\\n\\n\\n/***/ },\\n/* 20 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar base64 = __webpack_require__(15);\\n\\t\\n\\tfunction padding(str) {\\n\\t  var mod = str.length % 4;\\n\\t  var pad = 4 - mod;\\n\\t\\n\\t  if (mod === 0) {\\n\\t    return str;\\n\\t  }\\n\\t\\n\\t  return str + new Array(1 + pad).join('=');\\n\\t}\\n\\t\\n\\tfunction stringToByteArray(str) {\\n\\t  var arr = new Array(str.length);\\n\\t  for (var a = 0; a < str.length; a++) {\\n\\t    arr[a] = str.charCodeAt(a);\\n\\t  }\\n\\t  return arr;\\n\\t}\\n\\t\\n\\tfunction byteArrayToString(array) {\\n\\t  var result = '';\\n\\t  for (var i = 0; i < array.length; i++) {\\n\\t    result += String.fromCharCode(array[i]);\\n\\t  }\\n\\t  return result;\\n\\t}\\n\\t\\n\\tfunction encode(str) {\\n\\t  return base64\\n\\t    .fromByteArray(stringToByteArray(str))\\n\\t    .replace(/\\\\+/g, '-') // Convert '+' to '-'\\n\\t    .replace(/\\\\//g, '_'); // Convert '/' to '_'\\n\\t}\\n\\t\\n\\tfunction decode(str) {\\n\\t  str = padding(str)\\n\\t    .replace(/-/g, '+') // Convert '-' to '+'\\n\\t    .replace(/_/g, '/'); // Convert '_' to '/'\\n\\t\\n\\t  return byteArrayToString(base64.toByteArray(str));\\n\\t}\\n\\t\\n\\tmodule.exports = {\\n\\t  encode: encode,\\n\\t  decode: decode\\n\\t};\\n\\n\\n/***/ },\\n/* 21 */\\n/***/ function(module, exports) {\\n\\n\\tfunction buildResponse(error, description) {\\n\\t  return {\\n\\t    error: error,\\n\\t    errorDescription: description\\n\\t  };\\n\\t}\\n\\t\\n\\tfunction invalidJwt(description) {\\n\\t  return buildResponse('invalid_token', description);\\n\\t}\\n\\t\\n\\tmodule.exports = {\\n\\t  buildResponse: buildResponse,\\n\\t  invalidJwt: invalidJwt\\n\\t};\\n\\n\\n/***/ },\\n/* 22 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar random = __webpack_require__(48);\\n\\tvar storage = __webpack_require__(49);\\n\\t\\n\\tvar DEFAULT_NAMESPACE = 'com.auth0.auth.';\\n\\t\\n\\tfunction TransactionManager(options) {\\n\\t  options = options || {};\\n\\t  this.namespace = options.namespace || DEFAULT_NAMESPACE;\\n\\t  this.keyLength = options.keyLength || 32;\\n\\t}\\n\\t\\n\\tTransactionManager.prototype.process = function(options) {\\n\\t  var transaction;\\n\\t\\n\\t  if (options.responseType.indexOf('code') !== -1) {\\n\\t    return options;\\n\\t  }\\n\\t\\n\\t  if (options.responseType.indexOf('id_token') !== -1 && !!options.nonce) {\\n\\t    return options;\\n\\t  }\\n\\t\\n\\t  transaction = this.generateTransaction(options.appState, options.state, options.nonce);\\n\\t\\n\\t  options.state = transaction.state;\\n\\t\\n\\t  if (options.responseType.indexOf('id_token') !== -1) {\\n\\t    options.nonce = transaction.nonce;\\n\\t  }\\n\\t\\n\\t  return options;\\n\\t};\\n\\t\\n\\tTransactionManager.prototype.generateTransaction = function(appState, state, nonce) {\\n\\t  var transaction = state || random.randomString(this.keyLength);\\n\\t  nonce = nonce || random.randomString(this.keyLength);\\n\\t\\n\\t  storage.setItem(this.namespace + transaction, {\\n\\t    nonce: nonce,\\n\\t    appState: appState\\n\\t  });\\n\\t\\n\\t  return {\\n\\t    state: transaction,\\n\\t    nonce: nonce\\n\\t  };\\n\\t};\\n\\t\\n\\tTransactionManager.prototype.getStoredTransaction = function(transaction) {\\n\\t  var transactionData;\\n\\t\\n\\t  transactionData = storage.getItem(this.namespace + transaction);\\n\\t  storage.removeItem(this.namespace + transaction);\\n\\t  return transactionData;\\n\\t};\\n\\t\\n\\tmodule.exports = TransactionManager;\\n\\n\\n/***/ },\\n/* 23 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\t\\r\\n\\t/**\\r\\n\\t * Expose `Emitter`.\\r\\n\\t */\\r\\n\\t\\r\\n\\tif (true) {\\r\\n\\t  module.exports = Emitter;\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * Initialize a new `Emitter`.\\r\\n\\t *\\r\\n\\t * @api public\\r\\n\\t */\\r\\n\\t\\r\\n\\tfunction Emitter(obj) {\\r\\n\\t  if (obj) return mixin(obj);\\r\\n\\t};\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * Mixin the emitter properties.\\r\\n\\t *\\r\\n\\t * @param {Object} obj\\r\\n\\t * @return {Object}\\r\\n\\t * @api private\\r\\n\\t */\\r\\n\\t\\r\\n\\tfunction mixin(obj) {\\r\\n\\t  for (var key in Emitter.prototype) {\\r\\n\\t    obj[key] = Emitter.prototype[key];\\r\\n\\t  }\\r\\n\\t  return obj;\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * Listen on the given `event` with `fn`.\\r\\n\\t *\\r\\n\\t * @param {String} event\\r\\n\\t * @param {Function} fn\\r\\n\\t * @return {Emitter}\\r\\n\\t * @api public\\r\\n\\t */\\r\\n\\t\\r\\n\\tEmitter.prototype.on =\\r\\n\\tEmitter.prototype.addEventListener = function(event, fn){\\r\\n\\t  this._callbacks = this._callbacks || {};\\r\\n\\t  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\\r\\n\\t    .push(fn);\\r\\n\\t  return this;\\r\\n\\t};\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * Adds an `event` listener that will be invoked a single\\r\\n\\t * time then automatically removed.\\r\\n\\t *\\r\\n\\t * @param {String} event\\r\\n\\t * @param {Function} fn\\r\\n\\t * @return {Emitter}\\r\\n\\t * @api public\\r\\n\\t */\\r\\n\\t\\r\\n\\tEmitter.prototype.once = function(event, fn){\\r\\n\\t  function on() {\\r\\n\\t    this.off(event, on);\\r\\n\\t    fn.apply(this, arguments);\\r\\n\\t  }\\r\\n\\t\\r\\n\\t  on.fn = fn;\\r\\n\\t  this.on(event, on);\\r\\n\\t  return this;\\r\\n\\t};\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * Remove the given callback for `event` or all\\r\\n\\t * registered callbacks.\\r\\n\\t *\\r\\n\\t * @param {String} event\\r\\n\\t * @param {Function} fn\\r\\n\\t * @return {Emitter}\\r\\n\\t * @api public\\r\\n\\t */\\r\\n\\t\\r\\n\\tEmitter.prototype.off =\\r\\n\\tEmitter.prototype.removeListener =\\r\\n\\tEmitter.prototype.removeAllListeners =\\r\\n\\tEmitter.prototype.removeEventListener = function(event, fn){\\r\\n\\t  this._callbacks = this._callbacks || {};\\r\\n\\t\\r\\n\\t  // all\\r\\n\\t  if (0 == arguments.length) {\\r\\n\\t    this._callbacks = {};\\r\\n\\t    return this;\\r\\n\\t  }\\r\\n\\t\\r\\n\\t  // specific event\\r\\n\\t  var callbacks = this._callbacks['$' + event];\\r\\n\\t  if (!callbacks) return this;\\r\\n\\t\\r\\n\\t  // remove all handlers\\r\\n\\t  if (1 == arguments.length) {\\r\\n\\t    delete this._callbacks['$' + event];\\r\\n\\t    return this;\\r\\n\\t  }\\r\\n\\t\\r\\n\\t  // remove specific handler\\r\\n\\t  var cb;\\r\\n\\t  for (var i = 0; i < callbacks.length; i++) {\\r\\n\\t    cb = callbacks[i];\\r\\n\\t    if (cb === fn || cb.fn === fn) {\\r\\n\\t      callbacks.splice(i, 1);\\r\\n\\t      break;\\r\\n\\t    }\\r\\n\\t  }\\r\\n\\t  return this;\\r\\n\\t};\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * Emit `event` with the given args.\\r\\n\\t *\\r\\n\\t * @param {String} event\\r\\n\\t * @param {Mixed} ...\\r\\n\\t * @return {Emitter}\\r\\n\\t */\\r\\n\\t\\r\\n\\tEmitter.prototype.emit = function(event){\\r\\n\\t  this._callbacks = this._callbacks || {};\\r\\n\\t  var args = [].slice.call(arguments, 1)\\r\\n\\t    , callbacks = this._callbacks['$' + event];\\r\\n\\t\\r\\n\\t  if (callbacks) {\\r\\n\\t    callbacks = callbacks.slice(0);\\r\\n\\t    for (var i = 0, len = callbacks.length; i < len; ++i) {\\r\\n\\t      callbacks[i].apply(this, args);\\r\\n\\t    }\\r\\n\\t  }\\r\\n\\t\\r\\n\\t  return this;\\r\\n\\t};\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * Return array of callbacks for `event`.\\r\\n\\t *\\r\\n\\t * @param {String} event\\r\\n\\t * @return {Array}\\r\\n\\t * @api public\\r\\n\\t */\\r\\n\\t\\r\\n\\tEmitter.prototype.listeners = function(event){\\r\\n\\t  this._callbacks = this._callbacks || {};\\r\\n\\t  return this._callbacks['$' + event] || [];\\r\\n\\t};\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * Check if this emitter has `event` handlers.\\r\\n\\t *\\r\\n\\t * @param {String} event\\r\\n\\t * @return {Boolean}\\r\\n\\t * @api public\\r\\n\\t */\\r\\n\\t\\r\\n\\tEmitter.prototype.hasListeners = function(event){\\r\\n\\t  return !! this.listeners(event).length;\\r\\n\\t};\\r\\n\\n\\n/***/ },\\n/* 24 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\t;(function (root, factory) {\\n\\t\\tif (true) {\\n\\t\\t\\t// CommonJS\\n\\t\\t\\tmodule.exports = exports = factory();\\n\\t\\t}\\n\\t\\telse if (typeof define === \\\"function\\\" && define.amd) {\\n\\t\\t\\t// AMD\\n\\t\\t\\tdefine([], factory);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// Global (browser)\\n\\t\\t\\troot.CryptoJS = factory();\\n\\t\\t}\\n\\t}(this, function () {\\n\\t\\n\\t\\t/**\\n\\t\\t * CryptoJS core components.\\n\\t\\t */\\n\\t\\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\\n\\t\\t    /*\\n\\t\\t     * Local polyfil of Object.create\\n\\t\\t     */\\n\\t\\t    var create = Object.create || (function () {\\n\\t\\t        function F() {};\\n\\t\\n\\t\\t        return function (obj) {\\n\\t\\t            var subtype;\\n\\t\\n\\t\\t            F.prototype = obj;\\n\\t\\n\\t\\t            subtype = new F();\\n\\t\\n\\t\\t            F.prototype = null;\\n\\t\\n\\t\\t            return subtype;\\n\\t\\t        };\\n\\t\\t    }())\\n\\t\\n\\t\\t    /**\\n\\t\\t     * CryptoJS namespace.\\n\\t\\t     */\\n\\t\\t    var C = {};\\n\\t\\n\\t\\t    /**\\n\\t\\t     * Library namespace.\\n\\t\\t     */\\n\\t\\t    var C_lib = C.lib = {};\\n\\t\\n\\t\\t    /**\\n\\t\\t     * Base object for prototypal inheritance.\\n\\t\\t     */\\n\\t\\t    var Base = C_lib.Base = (function () {\\n\\t\\n\\t\\n\\t\\t        return {\\n\\t\\t            /**\\n\\t\\t             * Creates a new object that inherits from this object.\\n\\t\\t             *\\n\\t\\t             * @param {Object} overrides Properties to copy into the new object.\\n\\t\\t             *\\n\\t\\t             * @return {Object} The new object.\\n\\t\\t             *\\n\\t\\t             * @static\\n\\t\\t             *\\n\\t\\t             * @example\\n\\t\\t             *\\n\\t\\t             *     var MyType = CryptoJS.lib.Base.extend({\\n\\t\\t             *         field: 'value',\\n\\t\\t             *\\n\\t\\t             *         method: function () {\\n\\t\\t             *         }\\n\\t\\t             *     });\\n\\t\\t             */\\n\\t\\t            extend: function (overrides) {\\n\\t\\t                // Spawn\\n\\t\\t                var subtype = create(this);\\n\\t\\n\\t\\t                // Augment\\n\\t\\t                if (overrides) {\\n\\t\\t                    subtype.mixIn(overrides);\\n\\t\\t                }\\n\\t\\n\\t\\t                // Create default initializer\\n\\t\\t                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\\n\\t\\t                    subtype.init = function () {\\n\\t\\t                        subtype.$super.init.apply(this, arguments);\\n\\t\\t                    };\\n\\t\\t                }\\n\\t\\n\\t\\t                // Initializer's prototype is the subtype object\\n\\t\\t                subtype.init.prototype = subtype;\\n\\t\\n\\t\\t                // Reference supertype\\n\\t\\t                subtype.$super = this;\\n\\t\\n\\t\\t                return subtype;\\n\\t\\t            },\\n\\t\\n\\t\\t            /**\\n\\t\\t             * Extends this object and runs the init method.\\n\\t\\t             * Arguments to create() will be passed to init().\\n\\t\\t             *\\n\\t\\t             * @return {Object} The new object.\\n\\t\\t             *\\n\\t\\t             * @static\\n\\t\\t             *\\n\\t\\t             * @example\\n\\t\\t             *\\n\\t\\t             *     var instance = MyType.create();\\n\\t\\t             */\\n\\t\\t            create: function () {\\n\\t\\t                var instance = this.extend();\\n\\t\\t                instance.init.apply(instance, arguments);\\n\\t\\n\\t\\t                return instance;\\n\\t\\t            },\\n\\t\\n\\t\\t            /**\\n\\t\\t             * Initializes a newly created object.\\n\\t\\t             * Override this method to add some logic when your objects are created.\\n\\t\\t             *\\n\\t\\t             * @example\\n\\t\\t             *\\n\\t\\t             *     var MyType = CryptoJS.lib.Base.extend({\\n\\t\\t             *         init: function () {\\n\\t\\t             *             // ...\\n\\t\\t             *         }\\n\\t\\t             *     });\\n\\t\\t             */\\n\\t\\t            init: function () {\\n\\t\\t            },\\n\\t\\n\\t\\t            /**\\n\\t\\t             * Copies properties into this object.\\n\\t\\t             *\\n\\t\\t             * @param {Object} properties The properties to mix in.\\n\\t\\t             *\\n\\t\\t             * @example\\n\\t\\t             *\\n\\t\\t             *     MyType.mixIn({\\n\\t\\t             *         field: 'value'\\n\\t\\t             *     });\\n\\t\\t             */\\n\\t\\t            mixIn: function (properties) {\\n\\t\\t                for (var propertyName in properties) {\\n\\t\\t                    if (properties.hasOwnProperty(propertyName)) {\\n\\t\\t                        this[propertyName] = properties[propertyName];\\n\\t\\t                    }\\n\\t\\t                }\\n\\t\\n\\t\\t                // IE won't copy toString using the loop above\\n\\t\\t                if (properties.hasOwnProperty('toString')) {\\n\\t\\t                    this.toString = properties.toString;\\n\\t\\t                }\\n\\t\\t            },\\n\\t\\n\\t\\t            /**\\n\\t\\t             * Creates a copy of this object.\\n\\t\\t             *\\n\\t\\t             * @return {Object} The clone.\\n\\t\\t             *\\n\\t\\t             * @example\\n\\t\\t             *\\n\\t\\t             *     var clone = instance.clone();\\n\\t\\t             */\\n\\t\\t            clone: function () {\\n\\t\\t                return this.init.prototype.extend(this);\\n\\t\\t            }\\n\\t\\t        };\\n\\t\\t    }());\\n\\t\\n\\t\\t    /**\\n\\t\\t     * An array of 32-bit words.\\n\\t\\t     *\\n\\t\\t     * @property {Array} words The array of 32-bit words.\\n\\t\\t     * @property {number} sigBytes The number of significant bytes in this word array.\\n\\t\\t     */\\n\\t\\t    var WordArray = C_lib.WordArray = Base.extend({\\n\\t\\t        /**\\n\\t\\t         * Initializes a newly created word array.\\n\\t\\t         *\\n\\t\\t         * @param {Array} words (Optional) An array of 32-bit words.\\n\\t\\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     var wordArray = CryptoJS.lib.WordArray.create();\\n\\t\\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\\n\\t\\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\\n\\t\\t         */\\n\\t\\t        init: function (words, sigBytes) {\\n\\t\\t            words = this.words = words || [];\\n\\t\\n\\t\\t            if (sigBytes != undefined) {\\n\\t\\t                this.sigBytes = sigBytes;\\n\\t\\t            } else {\\n\\t\\t                this.sigBytes = words.length * 4;\\n\\t\\t            }\\n\\t\\t        },\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Converts this word array to a string.\\n\\t\\t         *\\n\\t\\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\\n\\t\\t         *\\n\\t\\t         * @return {string} The stringified word array.\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     var string = wordArray + '';\\n\\t\\t         *     var string = wordArray.toString();\\n\\t\\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\\n\\t\\t         */\\n\\t\\t        toString: function (encoder) {\\n\\t\\t            return (encoder || Hex).stringify(this);\\n\\t\\t        },\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Concatenates a word array to this word array.\\n\\t\\t         *\\n\\t\\t         * @param {WordArray} wordArray The word array to append.\\n\\t\\t         *\\n\\t\\t         * @return {WordArray} This word array.\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     wordArray1.concat(wordArray2);\\n\\t\\t         */\\n\\t\\t        concat: function (wordArray) {\\n\\t\\t            // Shortcuts\\n\\t\\t            var thisWords = this.words;\\n\\t\\t            var thatWords = wordArray.words;\\n\\t\\t            var thisSigBytes = this.sigBytes;\\n\\t\\t            var thatSigBytes = wordArray.sigBytes;\\n\\t\\n\\t\\t            // Clamp excess bits\\n\\t\\t            this.clamp();\\n\\t\\n\\t\\t            // Concat\\n\\t\\t            if (thisSigBytes % 4) {\\n\\t\\t                // Copy one byte at a time\\n\\t\\t                for (var i = 0; i < thatSigBytes; i++) {\\n\\t\\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\\n\\t\\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\\n\\t\\t                }\\n\\t\\t            } else {\\n\\t\\t                // Copy one word at a time\\n\\t\\t                for (var i = 0; i < thatSigBytes; i += 4) {\\n\\t\\t                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\\n\\t\\t                }\\n\\t\\t            }\\n\\t\\t            this.sigBytes += thatSigBytes;\\n\\t\\n\\t\\t            // Chainable\\n\\t\\t            return this;\\n\\t\\t        },\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Removes insignificant bits.\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     wordArray.clamp();\\n\\t\\t         */\\n\\t\\t        clamp: function () {\\n\\t\\t            // Shortcuts\\n\\t\\t            var words = this.words;\\n\\t\\t            var sigBytes = this.sigBytes;\\n\\t\\n\\t\\t            // Clamp\\n\\t\\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\\n\\t\\t            words.length = Math.ceil(sigBytes / 4);\\n\\t\\t        },\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Creates a copy of this word array.\\n\\t\\t         *\\n\\t\\t         * @return {WordArray} The clone.\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     var clone = wordArray.clone();\\n\\t\\t         */\\n\\t\\t        clone: function () {\\n\\t\\t            var clone = Base.clone.call(this);\\n\\t\\t            clone.words = this.words.slice(0);\\n\\t\\n\\t\\t            return clone;\\n\\t\\t        },\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Creates a word array filled with random bytes.\\n\\t\\t         *\\n\\t\\t         * @param {number} nBytes The number of random bytes to generate.\\n\\t\\t         *\\n\\t\\t         * @return {WordArray} The random word array.\\n\\t\\t         *\\n\\t\\t         * @static\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\\n\\t\\t         */\\n\\t\\t        random: function (nBytes) {\\n\\t\\t            var words = [];\\n\\t\\n\\t\\t            var r = (function (m_w) {\\n\\t\\t                var m_w = m_w;\\n\\t\\t                var m_z = 0x3ade68b1;\\n\\t\\t                var mask = 0xffffffff;\\n\\t\\n\\t\\t                return function () {\\n\\t\\t                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;\\n\\t\\t                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;\\n\\t\\t                    var result = ((m_z << 0x10) + m_w) & mask;\\n\\t\\t                    result /= 0x100000000;\\n\\t\\t                    result += 0.5;\\n\\t\\t                    return result * (Math.random() > .5 ? 1 : -1);\\n\\t\\t                }\\n\\t\\t            });\\n\\t\\n\\t\\t            for (var i = 0, rcache; i < nBytes; i += 4) {\\n\\t\\t                var _r = r((rcache || Math.random()) * 0x100000000);\\n\\t\\n\\t\\t                rcache = _r() * 0x3ade67b7;\\n\\t\\t                words.push((_r() * 0x100000000) | 0);\\n\\t\\t            }\\n\\t\\n\\t\\t            return new WordArray.init(words, nBytes);\\n\\t\\t        }\\n\\t\\t    });\\n\\t\\n\\t\\t    /**\\n\\t\\t     * Encoder namespace.\\n\\t\\t     */\\n\\t\\t    var C_enc = C.enc = {};\\n\\t\\n\\t\\t    /**\\n\\t\\t     * Hex encoding strategy.\\n\\t\\t     */\\n\\t\\t    var Hex = C_enc.Hex = {\\n\\t\\t        /**\\n\\t\\t         * Converts a word array to a hex string.\\n\\t\\t         *\\n\\t\\t         * @param {WordArray} wordArray The word array.\\n\\t\\t         *\\n\\t\\t         * @return {string} The hex string.\\n\\t\\t         *\\n\\t\\t         * @static\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\\n\\t\\t         */\\n\\t\\t        stringify: function (wordArray) {\\n\\t\\t            // Shortcuts\\n\\t\\t            var words = wordArray.words;\\n\\t\\t            var sigBytes = wordArray.sigBytes;\\n\\t\\n\\t\\t            // Convert\\n\\t\\t            var hexChars = [];\\n\\t\\t            for (var i = 0; i < sigBytes; i++) {\\n\\t\\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\\n\\t\\t                hexChars.push((bite >>> 4).toString(16));\\n\\t\\t                hexChars.push((bite & 0x0f).toString(16));\\n\\t\\t            }\\n\\t\\n\\t\\t            return hexChars.join('');\\n\\t\\t        },\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Converts a hex string to a word array.\\n\\t\\t         *\\n\\t\\t         * @param {string} hexStr The hex string.\\n\\t\\t         *\\n\\t\\t         * @return {WordArray} The word array.\\n\\t\\t         *\\n\\t\\t         * @static\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\\n\\t\\t         */\\n\\t\\t        parse: function (hexStr) {\\n\\t\\t            // Shortcut\\n\\t\\t            var hexStrLength = hexStr.length;\\n\\t\\n\\t\\t            // Convert\\n\\t\\t            var words = [];\\n\\t\\t            for (var i = 0; i < hexStrLength; i += 2) {\\n\\t\\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\\n\\t\\t            }\\n\\t\\n\\t\\t            return new WordArray.init(words, hexStrLength / 2);\\n\\t\\t        }\\n\\t\\t    };\\n\\t\\n\\t\\t    /**\\n\\t\\t     * Latin1 encoding strategy.\\n\\t\\t     */\\n\\t\\t    var Latin1 = C_enc.Latin1 = {\\n\\t\\t        /**\\n\\t\\t         * Converts a word array to a Latin1 string.\\n\\t\\t         *\\n\\t\\t         * @param {WordArray} wordArray The word array.\\n\\t\\t         *\\n\\t\\t         * @return {string} The Latin1 string.\\n\\t\\t         *\\n\\t\\t         * @static\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\\n\\t\\t         */\\n\\t\\t        stringify: function (wordArray) {\\n\\t\\t            // Shortcuts\\n\\t\\t            var words = wordArray.words;\\n\\t\\t            var sigBytes = wordArray.sigBytes;\\n\\t\\n\\t\\t            // Convert\\n\\t\\t            var latin1Chars = [];\\n\\t\\t            for (var i = 0; i < sigBytes; i++) {\\n\\t\\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\\n\\t\\t                latin1Chars.push(String.fromCharCode(bite));\\n\\t\\t            }\\n\\t\\n\\t\\t            return latin1Chars.join('');\\n\\t\\t        },\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Converts a Latin1 string to a word array.\\n\\t\\t         *\\n\\t\\t         * @param {string} latin1Str The Latin1 string.\\n\\t\\t         *\\n\\t\\t         * @return {WordArray} The word array.\\n\\t\\t         *\\n\\t\\t         * @static\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\\n\\t\\t         */\\n\\t\\t        parse: function (latin1Str) {\\n\\t\\t            // Shortcut\\n\\t\\t            var latin1StrLength = latin1Str.length;\\n\\t\\n\\t\\t            // Convert\\n\\t\\t            var words = [];\\n\\t\\t            for (var i = 0; i < latin1StrLength; i++) {\\n\\t\\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\\n\\t\\t            }\\n\\t\\n\\t\\t            return new WordArray.init(words, latin1StrLength);\\n\\t\\t        }\\n\\t\\t    };\\n\\t\\n\\t\\t    /**\\n\\t\\t     * UTF-8 encoding strategy.\\n\\t\\t     */\\n\\t\\t    var Utf8 = C_enc.Utf8 = {\\n\\t\\t        /**\\n\\t\\t         * Converts a word array to a UTF-8 string.\\n\\t\\t         *\\n\\t\\t         * @param {WordArray} wordArray The word array.\\n\\t\\t         *\\n\\t\\t         * @return {string} The UTF-8 string.\\n\\t\\t         *\\n\\t\\t         * @static\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\\n\\t\\t         */\\n\\t\\t        stringify: function (wordArray) {\\n\\t\\t            try {\\n\\t\\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\\n\\t\\t            } catch (e) {\\n\\t\\t                throw new Error('Malformed UTF-8 data');\\n\\t\\t            }\\n\\t\\t        },\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Converts a UTF-8 string to a word array.\\n\\t\\t         *\\n\\t\\t         * @param {string} utf8Str The UTF-8 string.\\n\\t\\t         *\\n\\t\\t         * @return {WordArray} The word array.\\n\\t\\t         *\\n\\t\\t         * @static\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\\n\\t\\t         */\\n\\t\\t        parse: function (utf8Str) {\\n\\t\\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\\n\\t\\t        }\\n\\t\\t    };\\n\\t\\n\\t\\t    /**\\n\\t\\t     * Abstract buffered block algorithm template.\\n\\t\\t     *\\n\\t\\t     * The property blockSize must be implemented in a concrete subtype.\\n\\t\\t     *\\n\\t\\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\\n\\t\\t     */\\n\\t\\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\\n\\t\\t        /**\\n\\t\\t         * Resets this block algorithm's data buffer to its initial state.\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     bufferedBlockAlgorithm.reset();\\n\\t\\t         */\\n\\t\\t        reset: function () {\\n\\t\\t            // Initial values\\n\\t\\t            this._data = new WordArray.init();\\n\\t\\t            this._nDataBytes = 0;\\n\\t\\t        },\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Adds new data to this block algorithm's buffer.\\n\\t\\t         *\\n\\t\\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     bufferedBlockAlgorithm._append('data');\\n\\t\\t         *     bufferedBlockAlgorithm._append(wordArray);\\n\\t\\t         */\\n\\t\\t        _append: function (data) {\\n\\t\\t            // Convert string to WordArray, else assume WordArray already\\n\\t\\t            if (typeof data == 'string') {\\n\\t\\t                data = Utf8.parse(data);\\n\\t\\t            }\\n\\t\\n\\t\\t            // Append\\n\\t\\t            this._data.concat(data);\\n\\t\\t            this._nDataBytes += data.sigBytes;\\n\\t\\t        },\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Processes available data blocks.\\n\\t\\t         *\\n\\t\\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\\n\\t\\t         *\\n\\t\\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\\n\\t\\t         *\\n\\t\\t         * @return {WordArray} The processed data.\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     var processedData = bufferedBlockAlgorithm._process();\\n\\t\\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\\n\\t\\t         */\\n\\t\\t        _process: function (doFlush) {\\n\\t\\t            // Shortcuts\\n\\t\\t            var data = this._data;\\n\\t\\t            var dataWords = data.words;\\n\\t\\t            var dataSigBytes = data.sigBytes;\\n\\t\\t            var blockSize = this.blockSize;\\n\\t\\t            var blockSizeBytes = blockSize * 4;\\n\\t\\n\\t\\t            // Count blocks ready\\n\\t\\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\\n\\t\\t            if (doFlush) {\\n\\t\\t                // Round up to include partial blocks\\n\\t\\t                nBlocksReady = Math.ceil(nBlocksReady);\\n\\t\\t            } else {\\n\\t\\t                // Round down to include only full blocks,\\n\\t\\t                // less the number of blocks that must remain in the buffer\\n\\t\\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\\n\\t\\t            }\\n\\t\\n\\t\\t            // Count words ready\\n\\t\\t            var nWordsReady = nBlocksReady * blockSize;\\n\\t\\n\\t\\t            // Count bytes ready\\n\\t\\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\\n\\t\\n\\t\\t            // Process blocks\\n\\t\\t            if (nWordsReady) {\\n\\t\\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\\n\\t\\t                    // Perform concrete-algorithm logic\\n\\t\\t                    this._doProcessBlock(dataWords, offset);\\n\\t\\t                }\\n\\t\\n\\t\\t                // Remove processed words\\n\\t\\t                var processedWords = dataWords.splice(0, nWordsReady);\\n\\t\\t                data.sigBytes -= nBytesReady;\\n\\t\\t            }\\n\\t\\n\\t\\t            // Return processed words\\n\\t\\t            return new WordArray.init(processedWords, nBytesReady);\\n\\t\\t        },\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Creates a copy of this object.\\n\\t\\t         *\\n\\t\\t         * @return {Object} The clone.\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     var clone = bufferedBlockAlgorithm.clone();\\n\\t\\t         */\\n\\t\\t        clone: function () {\\n\\t\\t            var clone = Base.clone.call(this);\\n\\t\\t            clone._data = this._data.clone();\\n\\t\\n\\t\\t            return clone;\\n\\t\\t        },\\n\\t\\n\\t\\t        _minBufferSize: 0\\n\\t\\t    });\\n\\t\\n\\t\\t    /**\\n\\t\\t     * Abstract hasher template.\\n\\t\\t     *\\n\\t\\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\\n\\t\\t     */\\n\\t\\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\\n\\t\\t        /**\\n\\t\\t         * Configuration options.\\n\\t\\t         */\\n\\t\\t        cfg: Base.extend(),\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Initializes a newly created hasher.\\n\\t\\t         *\\n\\t\\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     var hasher = CryptoJS.algo.SHA256.create();\\n\\t\\t         */\\n\\t\\t        init: function (cfg) {\\n\\t\\t            // Apply config defaults\\n\\t\\t            this.cfg = this.cfg.extend(cfg);\\n\\t\\n\\t\\t            // Set initial values\\n\\t\\t            this.reset();\\n\\t\\t        },\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Resets this hasher to its initial state.\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     hasher.reset();\\n\\t\\t         */\\n\\t\\t        reset: function () {\\n\\t\\t            // Reset data buffer\\n\\t\\t            BufferedBlockAlgorithm.reset.call(this);\\n\\t\\n\\t\\t            // Perform concrete-hasher logic\\n\\t\\t            this._doReset();\\n\\t\\t        },\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Updates this hasher with a message.\\n\\t\\t         *\\n\\t\\t         * @param {WordArray|string} messageUpdate The message to append.\\n\\t\\t         *\\n\\t\\t         * @return {Hasher} This hasher.\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     hasher.update('message');\\n\\t\\t         *     hasher.update(wordArray);\\n\\t\\t         */\\n\\t\\t        update: function (messageUpdate) {\\n\\t\\t            // Append\\n\\t\\t            this._append(messageUpdate);\\n\\t\\n\\t\\t            // Update the hash\\n\\t\\t            this._process();\\n\\t\\n\\t\\t            // Chainable\\n\\t\\t            return this;\\n\\t\\t        },\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Finalizes the hash computation.\\n\\t\\t         * Note that the finalize operation is effectively a destructive, read-once operation.\\n\\t\\t         *\\n\\t\\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\\n\\t\\t         *\\n\\t\\t         * @return {WordArray} The hash.\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     var hash = hasher.finalize();\\n\\t\\t         *     var hash = hasher.finalize('message');\\n\\t\\t         *     var hash = hasher.finalize(wordArray);\\n\\t\\t         */\\n\\t\\t        finalize: function (messageUpdate) {\\n\\t\\t            // Final message update\\n\\t\\t            if (messageUpdate) {\\n\\t\\t                this._append(messageUpdate);\\n\\t\\t            }\\n\\t\\n\\t\\t            // Perform concrete-hasher logic\\n\\t\\t            var hash = this._doFinalize();\\n\\t\\n\\t\\t            return hash;\\n\\t\\t        },\\n\\t\\n\\t\\t        blockSize: 512/32,\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Creates a shortcut function to a hasher's object interface.\\n\\t\\t         *\\n\\t\\t         * @param {Hasher} hasher The hasher to create a helper for.\\n\\t\\t         *\\n\\t\\t         * @return {Function} The shortcut function.\\n\\t\\t         *\\n\\t\\t         * @static\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\\n\\t\\t         */\\n\\t\\t        _createHelper: function (hasher) {\\n\\t\\t            return function (message, cfg) {\\n\\t\\t                return new hasher.init(cfg).finalize(message);\\n\\t\\t            };\\n\\t\\t        },\\n\\t\\n\\t\\t        /**\\n\\t\\t         * Creates a shortcut function to the HMAC's object interface.\\n\\t\\t         *\\n\\t\\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\\n\\t\\t         *\\n\\t\\t         * @return {Function} The shortcut function.\\n\\t\\t         *\\n\\t\\t         * @static\\n\\t\\t         *\\n\\t\\t         * @example\\n\\t\\t         *\\n\\t\\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\\n\\t\\t         */\\n\\t\\t        _createHmacHelper: function (hasher) {\\n\\t\\t            return function (message, key) {\\n\\t\\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\\n\\t\\t            };\\n\\t\\t        }\\n\\t\\t    });\\n\\t\\n\\t\\t    /**\\n\\t\\t     * Algorithm namespace.\\n\\t\\t     */\\n\\t\\t    var C_algo = C.algo = {};\\n\\t\\n\\t\\t    return C;\\n\\t\\t}(Math));\\n\\t\\n\\t\\n\\t\\treturn CryptoJS;\\n\\t\\n\\t}));\\n\\n/***/ },\\n/* 25 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\t;(function (root, factory) {\\n\\t\\tif (true) {\\n\\t\\t\\t// CommonJS\\n\\t\\t\\tmodule.exports = exports = factory(__webpack_require__(24));\\n\\t\\t}\\n\\t\\telse if (typeof define === \\\"function\\\" && define.amd) {\\n\\t\\t\\t// AMD\\n\\t\\t\\tdefine([\\\"./core\\\"], factory);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// Global (browser)\\n\\t\\t\\tfactory(root.CryptoJS);\\n\\t\\t}\\n\\t}(this, function (CryptoJS) {\\n\\t\\n\\t\\t(function (Math) {\\n\\t\\t    // Shortcuts\\n\\t\\t    var C = CryptoJS;\\n\\t\\t    var C_lib = C.lib;\\n\\t\\t    var WordArray = C_lib.WordArray;\\n\\t\\t    var Hasher = C_lib.Hasher;\\n\\t\\t    var C_algo = C.algo;\\n\\t\\n\\t\\t    // Initialization and round constants tables\\n\\t\\t    var H = [];\\n\\t\\t    var K = [];\\n\\t\\n\\t\\t    // Compute constants\\n\\t\\t    (function () {\\n\\t\\t        function isPrime(n) {\\n\\t\\t            var sqrtN = Math.sqrt(n);\\n\\t\\t            for (var factor = 2; factor <= sqrtN; factor++) {\\n\\t\\t                if (!(n % factor)) {\\n\\t\\t                    return false;\\n\\t\\t                }\\n\\t\\t            }\\n\\t\\n\\t\\t            return true;\\n\\t\\t        }\\n\\t\\n\\t\\t        function getFractionalBits(n) {\\n\\t\\t            return ((n - (n | 0)) * 0x100000000) | 0;\\n\\t\\t        }\\n\\t\\n\\t\\t        var n = 2;\\n\\t\\t        var nPrime = 0;\\n\\t\\t        while (nPrime < 64) {\\n\\t\\t            if (isPrime(n)) {\\n\\t\\t                if (nPrime < 8) {\\n\\t\\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\\n\\t\\t                }\\n\\t\\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\\n\\t\\n\\t\\t                nPrime++;\\n\\t\\t            }\\n\\t\\n\\t\\t            n++;\\n\\t\\t        }\\n\\t\\t    }());\\n\\t\\n\\t\\t    // Reusable object\\n\\t\\t    var W = [];\\n\\t\\n\\t\\t    /**\\n\\t\\t     * SHA-256 hash algorithm.\\n\\t\\t     */\\n\\t\\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\\n\\t\\t        _doReset: function () {\\n\\t\\t            this._hash = new WordArray.init(H.slice(0));\\n\\t\\t        },\\n\\t\\n\\t\\t        _doProcessBlock: function (M, offset) {\\n\\t\\t            // Shortcut\\n\\t\\t            var H = this._hash.words;\\n\\t\\n\\t\\t            // Working variables\\n\\t\\t            var a = H[0];\\n\\t\\t            var b = H[1];\\n\\t\\t            var c = H[2];\\n\\t\\t            var d = H[3];\\n\\t\\t            var e = H[4];\\n\\t\\t            var f = H[5];\\n\\t\\t            var g = H[6];\\n\\t\\t            var h = H[7];\\n\\t\\n\\t\\t            // Computation\\n\\t\\t            for (var i = 0; i < 64; i++) {\\n\\t\\t                if (i < 16) {\\n\\t\\t                    W[i] = M[offset + i] | 0;\\n\\t\\t                } else {\\n\\t\\t                    var gamma0x = W[i - 15];\\n\\t\\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\\n\\t\\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\\n\\t\\t                                   (gamma0x >>> 3);\\n\\t\\n\\t\\t                    var gamma1x = W[i - 2];\\n\\t\\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\\n\\t\\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\\n\\t\\t                                   (gamma1x >>> 10);\\n\\t\\n\\t\\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\\n\\t\\t                }\\n\\t\\n\\t\\t                var ch  = (e & f) ^ (~e & g);\\n\\t\\t                var maj = (a & b) ^ (a & c) ^ (b & c);\\n\\t\\n\\t\\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\\n\\t\\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\\n\\t\\n\\t\\t                var t1 = h + sigma1 + ch + K[i] + W[i];\\n\\t\\t                var t2 = sigma0 + maj;\\n\\t\\n\\t\\t                h = g;\\n\\t\\t                g = f;\\n\\t\\t                f = e;\\n\\t\\t                e = (d + t1) | 0;\\n\\t\\t                d = c;\\n\\t\\t                c = b;\\n\\t\\t                b = a;\\n\\t\\t                a = (t1 + t2) | 0;\\n\\t\\t            }\\n\\t\\n\\t\\t            // Intermediate hash value\\n\\t\\t            H[0] = (H[0] + a) | 0;\\n\\t\\t            H[1] = (H[1] + b) | 0;\\n\\t\\t            H[2] = (H[2] + c) | 0;\\n\\t\\t            H[3] = (H[3] + d) | 0;\\n\\t\\t            H[4] = (H[4] + e) | 0;\\n\\t\\t            H[5] = (H[5] + f) | 0;\\n\\t\\t            H[6] = (H[6] + g) | 0;\\n\\t\\t            H[7] = (H[7] + h) | 0;\\n\\t\\t        },\\n\\t\\n\\t\\t        _doFinalize: function () {\\n\\t\\t            // Shortcuts\\n\\t\\t            var data = this._data;\\n\\t\\t            var dataWords = data.words;\\n\\t\\n\\t\\t            var nBitsTotal = this._nDataBytes * 8;\\n\\t\\t            var nBitsLeft = data.sigBytes * 8;\\n\\t\\n\\t\\t            // Add padding\\n\\t\\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\\n\\t\\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\\n\\t\\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\\n\\t\\t            data.sigBytes = dataWords.length * 4;\\n\\t\\n\\t\\t            // Hash final blocks\\n\\t\\t            this._process();\\n\\t\\n\\t\\t            // Return final computed hash\\n\\t\\t            return this._hash;\\n\\t\\t        },\\n\\t\\n\\t\\t        clone: function () {\\n\\t\\t            var clone = Hasher.clone.call(this);\\n\\t\\t            clone._hash = this._hash.clone();\\n\\t\\n\\t\\t            return clone;\\n\\t\\t        }\\n\\t\\t    });\\n\\t\\n\\t\\t    /**\\n\\t\\t     * Shortcut function to the hasher's object interface.\\n\\t\\t     *\\n\\t\\t     * @param {WordArray|string} message The message to hash.\\n\\t\\t     *\\n\\t\\t     * @return {WordArray} The hash.\\n\\t\\t     *\\n\\t\\t     * @static\\n\\t\\t     *\\n\\t\\t     * @example\\n\\t\\t     *\\n\\t\\t     *     var hash = CryptoJS.SHA256('message');\\n\\t\\t     *     var hash = CryptoJS.SHA256(wordArray);\\n\\t\\t     */\\n\\t\\t    C.SHA256 = Hasher._createHelper(SHA256);\\n\\t\\n\\t\\t    /**\\n\\t\\t     * Shortcut function to the HMAC's object interface.\\n\\t\\t     *\\n\\t\\t     * @param {WordArray|string} message The message to hash.\\n\\t\\t     * @param {WordArray|string} key The secret key.\\n\\t\\t     *\\n\\t\\t     * @return {WordArray} The HMAC.\\n\\t\\t     *\\n\\t\\t     * @static\\n\\t\\t     *\\n\\t\\t     * @example\\n\\t\\t     *\\n\\t\\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\\n\\t\\t     */\\n\\t\\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\\n\\t\\t}(Math));\\n\\t\\n\\t\\n\\t\\treturn CryptoJS.SHA256;\\n\\t\\n\\t}));\\n\\n/***/ },\\n/* 26 */\\n/***/ function(module, exports) {\\n\\n\\tfunction DummyCache() {}\\n\\t\\n\\tDummyCache.prototype.get = function () {\\n\\t  return null;\\n\\t};\\n\\t\\n\\tDummyCache.prototype.has = function () {\\n\\t  return false;\\n\\t};\\n\\t\\n\\tDummyCache.prototype.set = function () {\\n\\t};\\n\\t\\n\\tmodule.exports = DummyCache;\\n\\n\\n/***/ },\\n/* 27 */\\n/***/ function(module, exports) {\\n\\n\\tfunction ConfigurationError(message) {\\n\\t  this.name = 'ConfigurationError';\\n\\t  this.message = (message || '');\\n\\t}\\n\\tConfigurationError.prototype = Error.prototype;\\n\\t\\n\\tfunction TokenValidationError(message) {\\n\\t  this.name = 'TokenValidationError';\\n\\t  this.message = (message || '');\\n\\t}\\n\\tTokenValidationError.prototype = Error.prototype;\\n\\t\\n\\tmodule.exports = {\\n\\t  ConfigurationError: ConfigurationError,\\n\\t  TokenValidationError: TokenValidationError\\n\\t};\\n\\n\\n/***/ },\\n/* 28 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar urljoin = __webpack_require__(1);\\n\\tvar base64 = __webpack_require__(16);\\n\\tvar request = __webpack_require__(17);\\n\\t\\n\\tfunction process(jwks) {\\n\\t  var modulus = base64.decodeToHEX(jwks.n);\\n\\t  var exp = base64.decodeToHEX(jwks.e);\\n\\t\\n\\t  return {\\n\\t    modulus: modulus,\\n\\t    exp: exp\\n\\t  };\\n\\t}\\n\\t\\n\\tfunction getJWKS(options, cb) {\\n\\t  var url = urljoin(options.iss, '.well-known', 'jwks.json');\\n\\t\\n\\t  return request\\n\\t    .get(url)\\n\\t    .end(function (err, data) {\\n\\t      var matchingKey = null;\\n\\t      var a;\\n\\t      var key;\\n\\t\\n\\t      if (err) {\\n\\t        cb(err);\\n\\t      }\\n\\t\\n\\t      // eslint-disable-next-line no-plusplus\\n\\t      for (a = 0; a < data.body.keys.length && matchingKey === null; a++) {\\n\\t        key = data.body.keys[a];\\n\\t        if (key.kid === options.kid) {\\n\\t          matchingKey = key;\\n\\t        }\\n\\t      }\\n\\t\\n\\t      cb(null, process(matchingKey));\\n\\t    });\\n\\t}\\n\\t\\n\\tmodule.exports = {\\n\\t  process: process,\\n\\t  getJWKS: getJWKS\\n\\t};\\n\\n\\n/***/ },\\n/* 29 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\t/*\\n\\tBased on the work of Tom Wu\\n\\thttp://www-cs-students.stanford.edu/~tjw/jsbn/\\n\\thttp://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE\\n\\t*/\\n\\t\\n\\tvar BigInteger = __webpack_require__(31).BigInteger;\\n\\tvar SHA256 = __webpack_require__(25);\\n\\t\\n\\tvar DigestInfoHead = {\\n\\t  sha1: '3021300906052b0e03021a05000414',\\n\\t  sha224: '302d300d06096086480165030402040500041c',\\n\\t  sha256: '3031300d060960864801650304020105000420',\\n\\t  sha384: '3041300d060960864801650304020205000430',\\n\\t  sha512: '3051300d060960864801650304020305000440',\\n\\t  md2: '3020300c06082a864886f70d020205000410',\\n\\t  md5: '3020300c06082a864886f70d020505000410',\\n\\t  ripemd160: '3021300906052b2403020105000414'\\n\\t};\\n\\t\\n\\tvar DigestAlgs = {\\n\\t  sha256: SHA256\\n\\t};\\n\\t\\n\\tfunction RSAVerifier(modulus, exp) {\\n\\t  this.n = null;\\n\\t  this.e = 0;\\n\\t\\n\\t  if (modulus != null && exp != null && modulus.length > 0 && exp.length > 0) {\\n\\t    this.n = new BigInteger(modulus, 16);\\n\\t    this.e = parseInt(exp, 16);\\n\\t  } else {\\n\\t    throw new Error('Invalid key data');\\n\\t  }\\n\\t}\\n\\t\\n\\tfunction getAlgorithmFromDigest(hDigestInfo) {\\n\\t  for (var algName in DigestInfoHead) {\\n\\t    var head = DigestInfoHead[algName];\\n\\t    var len = head.length;\\n\\t\\n\\t    if (hDigestInfo.substring(0, len) === head) {\\n\\t      return {\\n\\t        alg: algName,\\n\\t        hash: hDigestInfo.substring(len)\\n\\t      };\\n\\t    }\\n\\t  }\\n\\t  return [];\\n\\t}\\n\\t\\n\\t\\n\\tRSAVerifier.prototype.verify = function (msg, encsig) {\\n\\t  encsig = encsig.replace(/[^0-9a-f]|[\\\\s\\\\n]]/ig, '');\\n\\t\\n\\t  var sig = new BigInteger(encsig, 16);\\n\\t  if (sig.bitLength() > this.n.bitLength()) {\\n\\t    throw new Error('Signature does not match with the key modulus.');\\n\\t  }\\n\\t\\n\\t  var decryptedSig = sig.modPowInt(this.e, this.n);\\n\\t  var digest = decryptedSig.toString(16).replace(/^1f+00/, '');\\n\\t\\n\\t  var digestInfo = getAlgorithmFromDigest(digest);\\n\\t  if (digestInfo.length === 0) {\\n\\t    return false;\\n\\t  }\\n\\t\\n\\t  if (!DigestAlgs.hasOwnProperty(digestInfo.alg)) {\\n\\t    throw new Error('Hashing algorithm is not supported.');\\n\\t  }\\n\\t\\n\\t  var msgHash = DigestAlgs[digestInfo.alg](msg).toString();\\n\\t  return (digestInfo.hash === msgHash);\\n\\t};\\n\\t\\n\\tmodule.exports = RSAVerifier;\\n\\n\\n/***/ },\\n/* 30 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar RSAVerifier = __webpack_require__(29);\\n\\tvar base64 = __webpack_require__(16);\\n\\tvar jwks = __webpack_require__(28);\\n\\tvar error = __webpack_require__(27);\\n\\tvar DummyCache = __webpack_require__(26);\\n\\tvar supportedAlgs = ['RS256'];\\n\\t\\n\\t/**\\n\\t * Creates a new id_token verifier\\n\\t * @constructor\\n\\t * @param {Object} parameters\\n\\t * @param {String} parameters.issuer name of the issuer of the token\\n\\t * that should match the `iss` claim in the id_token\\n\\t * @param {String} parameters.audience identifies the recipients that the JWT is intended for\\n\\t * and should match the `aud` claim\\n\\t * @param {Object} [parameters.jwksCache] cache for JSON Web Token Keys. By default it has no cache\\n\\t * @param {String} [parameters.expectedAlg='RS256'] algorithm in which the id_token was signed\\n\\t * and will be used to validate\\n\\t * @param {number} [parameters.leeway=0] number of seconds that the clock can be out of sync\\n\\t * while validating expiration of the id_token\\n\\t */\\n\\tfunction IdTokenVerifier(parameters) {\\n\\t  var options = parameters || {};\\n\\t\\n\\t  this.jwksCache = options.jwksCache || new DummyCache();\\n\\t  this.expectedAlg = options.expectedAlg || 'RS256';\\n\\t  this.issuer = options.issuer;\\n\\t  this.audience = options.audience;\\n\\t  this.leeway = options.leeway || 0;\\n\\t  this.__disableExpirationCheck = options.__disableExpirationCheck || false;\\n\\t\\n\\t  if (this.leeway < 0 || this.leeway > 60) {\\n\\t    throw new error.ConfigurationError('The leeway should be positive and lower than a minute.');\\n\\t  }\\n\\t\\n\\t  if (supportedAlgs.indexOf(this.expectedAlg) === -1) {\\n\\t    throw new error.ConfigurationError('Algorithm ' + this.expectedAlg +\\n\\t      ' is not supported. (Expected algs: [' + supportedAlgs.join(',') + '])');\\n\\t  }\\n\\t}\\n\\t\\n\\t/**\\n\\t * @callback verifyCallback\\n\\t * @param {Error} [err] error returned if the verify cannot be performed\\n\\t * @param {boolean} [status] if the token is valid or not\\n\\t */\\n\\t\\n\\t/**\\n\\t * Verifies an id_token\\n\\t *\\n\\t * It will validate:\\n\\t * - signature according to the algorithm configured in the verifier.\\n\\t * - if nonce is present and matches the one provided\\n\\t * - if `iss` and `aud` claims matches the configured issuer and audience\\n\\t * - if token is not expired and valid (if the `nbf` claim is in the past)\\n\\t *\\n\\t * @method verify\\n\\t * @param {String} token id_token to verify\\n\\t * @param {String} [nonce] nonce value that should match the one in the id_token claims\\n\\t * @param {verifyCallback} cb callback used to notify the results of the validation\\n\\t */\\n\\tIdTokenVerifier.prototype.verify = function (token, nonce, cb) {\\n\\t  var jwt = this.decode(token);\\n\\t\\n\\t  if (jwt instanceof Error) {\\n\\t    return cb(jwt, false);\\n\\t  }\\n\\t\\n\\t  /* eslint-disable vars-on-top */\\n\\t  var headAndPayload = jwt.encoded.header + '.' + jwt.encoded.payload;\\n\\t  var signature = base64.decodeToHEX(jwt.encoded.signature);\\n\\t\\n\\t  var alg = jwt.header.alg;\\n\\t  var kid = jwt.header.kid;\\n\\t\\n\\t  var aud = jwt.payload.aud;\\n\\t  var iss = jwt.payload.iss;\\n\\t  var exp = jwt.payload.exp;\\n\\t  var nbf = jwt.payload.nbf;\\n\\t  var tnonce = jwt.payload.nonce || null;\\n\\t  /* eslint-enable vars-on-top */\\n\\t\\n\\t  if (this.issuer !== iss) {\\n\\t    return cb(new error.TokenValidationError('Issuer ' + iss + ' is not valid.'), false);\\n\\t  }\\n\\t\\n\\t  if (this.audience !== aud) {\\n\\t    return cb(new error.TokenValidationError('Audience ' + aud + ' is not valid.'), false);\\n\\t  }\\n\\t\\n\\t  if (this.expectedAlg !== alg) {\\n\\t    return cb(new error.TokenValidationError('Algorithm ' + alg +\\n\\t      ' is not supported. (Expected algs: [' + supportedAlgs.join(',') + '])'), false);\\n\\t  }\\n\\t\\n\\t  if (tnonce !== nonce) {\\n\\t    return cb(new error.TokenValidationError('Nonce does not match.'), false);\\n\\t  }\\n\\t\\n\\t  var expirationError = this.verifyExpAndNbf(exp, nbf); // eslint-disable-line vars-on-top\\n\\t\\n\\t  if (expirationError) {\\n\\t    return cb(expirationError, false);\\n\\t  }\\n\\t\\n\\t  return this.getRsaVerifier(iss, kid, function (err, rsaVerifier) {\\n\\t    if (err) {\\n\\t      return cb(err);\\n\\t    }\\n\\t    if (rsaVerifier.verify(headAndPayload, signature)) {\\n\\t      return cb(null, jwt.payload);\\n\\t    }\\n\\t    return cb(new error.TokenValidationError('Invalid signature.'));\\n\\t  });\\n\\t};\\n\\t\\n\\t/**\\n\\t * Verifies that the `exp` and `nbf` claims are valid in the current moment.\\n\\t *\\n\\t * @method verifyExpAndNbf\\n\\t * @param {String} exp value of `exp` claim\\n\\t * @param {String} nbf value of `nbf` claim\\n\\t * @return {boolean} if token is valid according to `exp` and `nbf`\\n\\t */\\n\\tIdTokenVerifier.prototype.verifyExpAndNbf = function (exp, nbf) {\\n\\t  var now = new Date();\\n\\t  var expDate = new Date(0);\\n\\t  var nbfDate = new Date(0);\\n\\t\\n\\t  if (this.__disableExpirationCheck) {\\n\\t    return null;\\n\\t  }\\n\\t\\n\\t  expDate.setUTCSeconds(exp + this.leeway);\\n\\t\\n\\t  if (now > expDate) {\\n\\t    return new error.TokenValidationError('Expired token.');\\n\\t  }\\n\\t\\n\\t  if (typeof nbf === 'undefined') {\\n\\t    return null;\\n\\t  }\\n\\t  nbfDate.setUTCSeconds(nbf - this.leeway);\\n\\t  if (now < nbfDate) {\\n\\t    return new error.TokenValidationError('The token is not valid until later in the future. ' +\\n\\t      'Please check your computed clock.');\\n\\t  }\\n\\t\\n\\t  return null;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Verifies that the `exp` and `iat` claims are valid in the current moment.\\n\\t *\\n\\t * @method verifyExpAndIat\\n\\t * @param {String} exp value of `exp` claim\\n\\t * @param {String} iat value of `iat` claim\\n\\t * @return {boolean} if token is valid according to `exp` and `iat`\\n\\t */\\n\\tIdTokenVerifier.prototype.verifyExpAndIat = function (exp, iat) {\\n\\t  var now = new Date();\\n\\t  var expDate = new Date(0);\\n\\t  var iatDate = new Date(0);\\n\\t\\n\\t  if (this.__disableExpirationCheck) {\\n\\t    return null;\\n\\t  }\\n\\t\\n\\t  expDate.setUTCSeconds(exp + this.leeway);\\n\\t\\n\\t  if (now > expDate) {\\n\\t    return new error.TokenValidationError('Expired token.');\\n\\t  }\\n\\t\\n\\t  iatDate.setUTCSeconds(iat - this.leeway);\\n\\t\\n\\t  if (now < iatDate) {\\n\\t    return new error.TokenValidationError('The token was issued in the future. ' +\\n\\t      'Please check your computed clock.');\\n\\t  }\\n\\t  return null;\\n\\t};\\n\\t\\n\\tIdTokenVerifier.prototype.getRsaVerifier = function (iss, kid, cb) {\\n\\t  var _this = this;\\n\\t  var cachekey = iss + kid;\\n\\t\\n\\t  if (!this.jwksCache.has(cachekey)) {\\n\\t    jwks.getJWKS({\\n\\t      iss: iss,\\n\\t      kid: kid\\n\\t    }, function (err, keyInfo) {\\n\\t      if (err) {\\n\\t        cb(err);\\n\\t      }\\n\\t      _this.jwksCache.set(cachekey, keyInfo);\\n\\t      cb(null, new RSAVerifier(keyInfo.modulus, keyInfo.exp));\\n\\t    });\\n\\t  } else {\\n\\t    var keyInfo = this.jwksCache.get(cachekey); // eslint-disable-line vars-on-top\\n\\t    cb(null, new RSAVerifier(keyInfo.modulus, keyInfo.exp));\\n\\t  }\\n\\t};\\n\\t\\n\\t\\n\\t/**\\n\\t * @typedef DecodedToken\\n\\t * @type {Object}\\n\\t * @property {Object} header - content of the JWT header.\\n\\t * @property {Object} payload - token claims.\\n\\t * @property {Object} encoded - encoded parts of the token.\\n\\t */\\n\\t\\n\\t/**\\n\\t * Decodes a well formed JWT without any verification\\n\\t *\\n\\t * @method decode\\n\\t * @param {String} token decodes the token\\n\\t * @return {DecodedToken} if token is valid according to `exp` and `nbf`\\n\\t */\\n\\tIdTokenVerifier.prototype.decode = function (token) {\\n\\t  var parts = token.split('.');\\n\\t  var header;\\n\\t  var payload;\\n\\t\\n\\t  if (parts.length !== 3) {\\n\\t    return new error.TokenValidationError('Cannot decode a malformed JWT');\\n\\t  }\\n\\t\\n\\t  try {\\n\\t    header = JSON.parse(base64.decodeToString(parts[0]));\\n\\t    payload = JSON.parse(base64.decodeToString(parts[1]));\\n\\t  } catch (e) {\\n\\t    return new error.TokenValidationError('Token header or payload is not valid JSON');\\n\\t  }\\n\\t\\n\\t  return {\\n\\t    header: header,\\n\\t    payload: payload,\\n\\t    encoded: {\\n\\t      header: parts[0],\\n\\t      payload: parts[1],\\n\\t      signature: parts[2]\\n\\t    }\\n\\t  };\\n\\t};\\n\\t\\n\\tmodule.exports = IdTokenVerifier;\\n\\n\\n/***/ },\\n/* 31 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\t(function(){\\n\\t\\n\\t    // Copyright (c) 2005  Tom Wu\\n\\t    // All Rights Reserved.\\n\\t    // See \\\"LICENSE\\\" for details.\\n\\t\\n\\t    // Basic JavaScript BN library - subset useful for RSA encryption.\\n\\t\\n\\t    // Bits per digit\\n\\t    var dbits;\\n\\t\\n\\t    // JavaScript engine analysis\\n\\t    var canary = 0xdeadbeefcafe;\\n\\t    var j_lm = ((canary&0xffffff)==0xefcafe);\\n\\t\\n\\t    // (public) Constructor\\n\\t    function BigInteger(a,b,c) {\\n\\t      if(a != null)\\n\\t        if(\\\"number\\\" == typeof a) this.fromNumber(a,b,c);\\n\\t        else if(b == null && \\\"string\\\" != typeof a) this.fromString(a,256);\\n\\t        else this.fromString(a,b);\\n\\t    }\\n\\t\\n\\t    // return new, unset BigInteger\\n\\t    function nbi() { return new BigInteger(null); }\\n\\t\\n\\t    // am: Compute w_j += (x*this_i), propagate carries,\\n\\t    // c is initial carry, returns final carry.\\n\\t    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\\n\\t    // We need to select the fastest one that works in this environment.\\n\\t\\n\\t    // am1: use a single mult and divide to get the high bits,\\n\\t    // max digit bits should be 26 because\\n\\t    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\\n\\t    function am1(i,x,w,j,c,n) {\\n\\t      while(--n >= 0) {\\n\\t        var v = x*this[i++]+w[j]+c;\\n\\t        c = Math.floor(v/0x4000000);\\n\\t        w[j++] = v&0x3ffffff;\\n\\t      }\\n\\t      return c;\\n\\t    }\\n\\t    // am2 avoids a big mult-and-extract completely.\\n\\t    // Max digit bits should be <= 30 because we do bitwise ops\\n\\t    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\\n\\t    function am2(i,x,w,j,c,n) {\\n\\t      var xl = x&0x7fff, xh = x>>15;\\n\\t      while(--n >= 0) {\\n\\t        var l = this[i]&0x7fff;\\n\\t        var h = this[i++]>>15;\\n\\t        var m = xh*l+h*xl;\\n\\t        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\\n\\t        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\\n\\t        w[j++] = l&0x3fffffff;\\n\\t      }\\n\\t      return c;\\n\\t    }\\n\\t    // Alternately, set max digit bits to 28 since some\\n\\t    // browsers slow down when dealing with 32-bit numbers.\\n\\t    function am3(i,x,w,j,c,n) {\\n\\t      var xl = x&0x3fff, xh = x>>14;\\n\\t      while(--n >= 0) {\\n\\t        var l = this[i]&0x3fff;\\n\\t        var h = this[i++]>>14;\\n\\t        var m = xh*l+h*xl;\\n\\t        l = xl*l+((m&0x3fff)<<14)+w[j]+c;\\n\\t        c = (l>>28)+(m>>14)+xh*h;\\n\\t        w[j++] = l&0xfffffff;\\n\\t      }\\n\\t      return c;\\n\\t    }\\n\\t    var inBrowser = typeof navigator !== \\\"undefined\\\";\\n\\t    if(inBrowser && j_lm && (navigator.appName == \\\"Microsoft Internet Explorer\\\")) {\\n\\t      BigInteger.prototype.am = am2;\\n\\t      dbits = 30;\\n\\t    }\\n\\t    else if(inBrowser && j_lm && (navigator.appName != \\\"Netscape\\\")) {\\n\\t      BigInteger.prototype.am = am1;\\n\\t      dbits = 26;\\n\\t    }\\n\\t    else { // Mozilla/Netscape seems to prefer am3\\n\\t      BigInteger.prototype.am = am3;\\n\\t      dbits = 28;\\n\\t    }\\n\\t\\n\\t    BigInteger.prototype.DB = dbits;\\n\\t    BigInteger.prototype.DM = ((1<<dbits)-1);\\n\\t    BigInteger.prototype.DV = (1<<dbits);\\n\\t\\n\\t    var BI_FP = 52;\\n\\t    BigInteger.prototype.FV = Math.pow(2,BI_FP);\\n\\t    BigInteger.prototype.F1 = BI_FP-dbits;\\n\\t    BigInteger.prototype.F2 = 2*dbits-BI_FP;\\n\\t\\n\\t    // Digit conversions\\n\\t    var BI_RM = \\\"0123456789abcdefghijklmnopqrstuvwxyz\\\";\\n\\t    var BI_RC = new Array();\\n\\t    var rr,vv;\\n\\t    rr = \\\"0\\\".charCodeAt(0);\\n\\t    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\\n\\t    rr = \\\"a\\\".charCodeAt(0);\\n\\t    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\\n\\t    rr = \\\"A\\\".charCodeAt(0);\\n\\t    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\\n\\t\\n\\t    function int2char(n) { return BI_RM.charAt(n); }\\n\\t    function intAt(s,i) {\\n\\t      var c = BI_RC[s.charCodeAt(i)];\\n\\t      return (c==null)?-1:c;\\n\\t    }\\n\\t\\n\\t    // (protected) copy this to r\\n\\t    function bnpCopyTo(r) {\\n\\t      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\\n\\t      r.t = this.t;\\n\\t      r.s = this.s;\\n\\t    }\\n\\t\\n\\t    // (protected) set from integer value x, -DV <= x < DV\\n\\t    function bnpFromInt(x) {\\n\\t      this.t = 1;\\n\\t      this.s = (x<0)?-1:0;\\n\\t      if(x > 0) this[0] = x;\\n\\t      else if(x < -1) this[0] = x+this.DV;\\n\\t      else this.t = 0;\\n\\t    }\\n\\t\\n\\t    // return bigint initialized to value\\n\\t    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }\\n\\t\\n\\t    // (protected) set from string and radix\\n\\t    function bnpFromString(s,b) {\\n\\t      var k;\\n\\t      if(b == 16) k = 4;\\n\\t      else if(b == 8) k = 3;\\n\\t      else if(b == 256) k = 8; // byte array\\n\\t      else if(b == 2) k = 1;\\n\\t      else if(b == 32) k = 5;\\n\\t      else if(b == 4) k = 2;\\n\\t      else { this.fromRadix(s,b); return; }\\n\\t      this.t = 0;\\n\\t      this.s = 0;\\n\\t      var i = s.length, mi = false, sh = 0;\\n\\t      while(--i >= 0) {\\n\\t        var x = (k==8)?s[i]&0xff:intAt(s,i);\\n\\t        if(x < 0) {\\n\\t          if(s.charAt(i) == \\\"-\\\") mi = true;\\n\\t          continue;\\n\\t        }\\n\\t        mi = false;\\n\\t        if(sh == 0)\\n\\t          this[this.t++] = x;\\n\\t        else if(sh+k > this.DB) {\\n\\t          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\\n\\t          this[this.t++] = (x>>(this.DB-sh));\\n\\t        }\\n\\t        else\\n\\t          this[this.t-1] |= x<<sh;\\n\\t        sh += k;\\n\\t        if(sh >= this.DB) sh -= this.DB;\\n\\t      }\\n\\t      if(k == 8 && (s[0]&0x80) != 0) {\\n\\t        this.s = -1;\\n\\t        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\\n\\t      }\\n\\t      this.clamp();\\n\\t      if(mi) BigInteger.ZERO.subTo(this,this);\\n\\t    }\\n\\t\\n\\t    // (protected) clamp off excess high words\\n\\t    function bnpClamp() {\\n\\t      var c = this.s&this.DM;\\n\\t      while(this.t > 0 && this[this.t-1] == c) --this.t;\\n\\t    }\\n\\t\\n\\t    // (public) return string representation in given radix\\n\\t    function bnToString(b) {\\n\\t      if(this.s < 0) return \\\"-\\\"+this.negate().toString(b);\\n\\t      var k;\\n\\t      if(b == 16) k = 4;\\n\\t      else if(b == 8) k = 3;\\n\\t      else if(b == 2) k = 1;\\n\\t      else if(b == 32) k = 5;\\n\\t      else if(b == 4) k = 2;\\n\\t      else return this.toRadix(b);\\n\\t      var km = (1<<k)-1, d, m = false, r = \\\"\\\", i = this.t;\\n\\t      var p = this.DB-(i*this.DB)%k;\\n\\t      if(i-- > 0) {\\n\\t        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\\n\\t        while(i >= 0) {\\n\\t          if(p < k) {\\n\\t            d = (this[i]&((1<<p)-1))<<(k-p);\\n\\t            d |= this[--i]>>(p+=this.DB-k);\\n\\t          }\\n\\t          else {\\n\\t            d = (this[i]>>(p-=k))&km;\\n\\t            if(p <= 0) { p += this.DB; --i; }\\n\\t          }\\n\\t          if(d > 0) m = true;\\n\\t          if(m) r += int2char(d);\\n\\t        }\\n\\t      }\\n\\t      return m?r:\\\"0\\\";\\n\\t    }\\n\\t\\n\\t    // (public) -this\\n\\t    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\\n\\t\\n\\t    // (public) |this|\\n\\t    function bnAbs() { return (this.s<0)?this.negate():this; }\\n\\t\\n\\t    // (public) return + if this > a, - if this < a, 0 if equal\\n\\t    function bnCompareTo(a) {\\n\\t      var r = this.s-a.s;\\n\\t      if(r != 0) return r;\\n\\t      var i = this.t;\\n\\t      r = i-a.t;\\n\\t      if(r != 0) return (this.s<0)?-r:r;\\n\\t      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\\n\\t      return 0;\\n\\t    }\\n\\t\\n\\t    // returns bit length of the integer x\\n\\t    function nbits(x) {\\n\\t      var r = 1, t;\\n\\t      if((t=x>>>16) != 0) { x = t; r += 16; }\\n\\t      if((t=x>>8) != 0) { x = t; r += 8; }\\n\\t      if((t=x>>4) != 0) { x = t; r += 4; }\\n\\t      if((t=x>>2) != 0) { x = t; r += 2; }\\n\\t      if((t=x>>1) != 0) { x = t; r += 1; }\\n\\t      return r;\\n\\t    }\\n\\t\\n\\t    // (public) return the number of bits in \\\"this\\\"\\n\\t    function bnBitLength() {\\n\\t      if(this.t <= 0) return 0;\\n\\t      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\\n\\t    }\\n\\t\\n\\t    // (protected) r = this << n*DB\\n\\t    function bnpDLShiftTo(n,r) {\\n\\t      var i;\\n\\t      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\\n\\t      for(i = n-1; i >= 0; --i) r[i] = 0;\\n\\t      r.t = this.t+n;\\n\\t      r.s = this.s;\\n\\t    }\\n\\t\\n\\t    // (protected) r = this >> n*DB\\n\\t    function bnpDRShiftTo(n,r) {\\n\\t      for(var i = n; i < this.t; ++i) r[i-n] = this[i];\\n\\t      r.t = Math.max(this.t-n,0);\\n\\t      r.s = this.s;\\n\\t    }\\n\\t\\n\\t    // (protected) r = this << n\\n\\t    function bnpLShiftTo(n,r) {\\n\\t      var bs = n%this.DB;\\n\\t      var cbs = this.DB-bs;\\n\\t      var bm = (1<<cbs)-1;\\n\\t      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\\n\\t      for(i = this.t-1; i >= 0; --i) {\\n\\t        r[i+ds+1] = (this[i]>>cbs)|c;\\n\\t        c = (this[i]&bm)<<bs;\\n\\t      }\\n\\t      for(i = ds-1; i >= 0; --i) r[i] = 0;\\n\\t      r[ds] = c;\\n\\t      r.t = this.t+ds+1;\\n\\t      r.s = this.s;\\n\\t      r.clamp();\\n\\t    }\\n\\t\\n\\t    // (protected) r = this >> n\\n\\t    function bnpRShiftTo(n,r) {\\n\\t      r.s = this.s;\\n\\t      var ds = Math.floor(n/this.DB);\\n\\t      if(ds >= this.t) { r.t = 0; return; }\\n\\t      var bs = n%this.DB;\\n\\t      var cbs = this.DB-bs;\\n\\t      var bm = (1<<bs)-1;\\n\\t      r[0] = this[ds]>>bs;\\n\\t      for(var i = ds+1; i < this.t; ++i) {\\n\\t        r[i-ds-1] |= (this[i]&bm)<<cbs;\\n\\t        r[i-ds] = this[i]>>bs;\\n\\t      }\\n\\t      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\\n\\t      r.t = this.t-ds;\\n\\t      r.clamp();\\n\\t    }\\n\\t\\n\\t    // (protected) r = this - a\\n\\t    function bnpSubTo(a,r) {\\n\\t      var i = 0, c = 0, m = Math.min(a.t,this.t);\\n\\t      while(i < m) {\\n\\t        c += this[i]-a[i];\\n\\t        r[i++] = c&this.DM;\\n\\t        c >>= this.DB;\\n\\t      }\\n\\t      if(a.t < this.t) {\\n\\t        c -= a.s;\\n\\t        while(i < this.t) {\\n\\t          c += this[i];\\n\\t          r[i++] = c&this.DM;\\n\\t          c >>= this.DB;\\n\\t        }\\n\\t        c += this.s;\\n\\t      }\\n\\t      else {\\n\\t        c += this.s;\\n\\t        while(i < a.t) {\\n\\t          c -= a[i];\\n\\t          r[i++] = c&this.DM;\\n\\t          c >>= this.DB;\\n\\t        }\\n\\t        c -= a.s;\\n\\t      }\\n\\t      r.s = (c<0)?-1:0;\\n\\t      if(c < -1) r[i++] = this.DV+c;\\n\\t      else if(c > 0) r[i++] = c;\\n\\t      r.t = i;\\n\\t      r.clamp();\\n\\t    }\\n\\t\\n\\t    // (protected) r = this * a, r != this,a (HAC 14.12)\\n\\t    // \\\"this\\\" should be the larger one if appropriate.\\n\\t    function bnpMultiplyTo(a,r) {\\n\\t      var x = this.abs(), y = a.abs();\\n\\t      var i = x.t;\\n\\t      r.t = i+y.t;\\n\\t      while(--i >= 0) r[i] = 0;\\n\\t      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\\n\\t      r.s = 0;\\n\\t      r.clamp();\\n\\t      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\\n\\t    }\\n\\t\\n\\t    // (protected) r = this^2, r != this (HAC 14.16)\\n\\t    function bnpSquareTo(r) {\\n\\t      var x = this.abs();\\n\\t      var i = r.t = 2*x.t;\\n\\t      while(--i >= 0) r[i] = 0;\\n\\t      for(i = 0; i < x.t-1; ++i) {\\n\\t        var c = x.am(i,x[i],r,2*i,0,1);\\n\\t        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\\n\\t          r[i+x.t] -= x.DV;\\n\\t          r[i+x.t+1] = 1;\\n\\t        }\\n\\t      }\\n\\t      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\\n\\t      r.s = 0;\\n\\t      r.clamp();\\n\\t    }\\n\\t\\n\\t    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\\n\\t    // r != q, this != m.  q or r may be null.\\n\\t    function bnpDivRemTo(m,q,r) {\\n\\t      var pm = m.abs();\\n\\t      if(pm.t <= 0) return;\\n\\t      var pt = this.abs();\\n\\t      if(pt.t < pm.t) {\\n\\t        if(q != null) q.fromInt(0);\\n\\t        if(r != null) this.copyTo(r);\\n\\t        return;\\n\\t      }\\n\\t      if(r == null) r = nbi();\\n\\t      var y = nbi(), ts = this.s, ms = m.s;\\n\\t      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus\\n\\t      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\\n\\t      else { pm.copyTo(y); pt.copyTo(r); }\\n\\t      var ys = y.t;\\n\\t      var y0 = y[ys-1];\\n\\t      if(y0 == 0) return;\\n\\t      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\\n\\t      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\\n\\t      var i = r.t, j = i-ys, t = (q==null)?nbi():q;\\n\\t      y.dlShiftTo(j,t);\\n\\t      if(r.compareTo(t) >= 0) {\\n\\t        r[r.t++] = 1;\\n\\t        r.subTo(t,r);\\n\\t      }\\n\\t      BigInteger.ONE.dlShiftTo(ys,t);\\n\\t      t.subTo(y,y);  // \\\"negative\\\" y so we can replace sub with am later\\n\\t      while(y.t < ys) y[y.t++] = 0;\\n\\t      while(--j >= 0) {\\n\\t        // Estimate quotient digit\\n\\t        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\\n\\t        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out\\n\\t          y.dlShiftTo(j,t);\\n\\t          r.subTo(t,r);\\n\\t          while(r[i] < --qd) r.subTo(t,r);\\n\\t        }\\n\\t      }\\n\\t      if(q != null) {\\n\\t        r.drShiftTo(ys,q);\\n\\t        if(ts != ms) BigInteger.ZERO.subTo(q,q);\\n\\t      }\\n\\t      r.t = ys;\\n\\t      r.clamp();\\n\\t      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder\\n\\t      if(ts < 0) BigInteger.ZERO.subTo(r,r);\\n\\t    }\\n\\t\\n\\t    // (public) this mod a\\n\\t    function bnMod(a) {\\n\\t      var r = nbi();\\n\\t      this.abs().divRemTo(a,null,r);\\n\\t      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\\n\\t      return r;\\n\\t    }\\n\\t\\n\\t    // Modular reduction using \\\"classic\\\" algorithm\\n\\t    function Classic(m) { this.m = m; }\\n\\t    function cConvert(x) {\\n\\t      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\\n\\t      else return x;\\n\\t    }\\n\\t    function cRevert(x) { return x; }\\n\\t    function cReduce(x) { x.divRemTo(this.m,null,x); }\\n\\t    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\\n\\t    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\\n\\t\\n\\t    Classic.prototype.convert = cConvert;\\n\\t    Classic.prototype.revert = cRevert;\\n\\t    Classic.prototype.reduce = cReduce;\\n\\t    Classic.prototype.mulTo = cMulTo;\\n\\t    Classic.prototype.sqrTo = cSqrTo;\\n\\t\\n\\t    // (protected) return \\\"-1/this % 2^DB\\\"; useful for Mont. reduction\\n\\t    // justification:\\n\\t    //         xy == 1 (mod m)\\n\\t    //         xy =  1+km\\n\\t    //   xy(2-xy) = (1+km)(1-km)\\n\\t    // x[y(2-xy)] = 1-k^2m^2\\n\\t    // x[y(2-xy)] == 1 (mod m^2)\\n\\t    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\\n\\t    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\\n\\t    // JS multiply \\\"overflows\\\" differently from C/C++, so care is needed here.\\n\\t    function bnpInvDigit() {\\n\\t      if(this.t < 1) return 0;\\n\\t      var x = this[0];\\n\\t      if((x&1) == 0) return 0;\\n\\t      var y = x&3;       // y == 1/x mod 2^2\\n\\t      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4\\n\\t      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8\\n\\t      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16\\n\\t      // last step - calculate inverse mod DV directly;\\n\\t      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\\n\\t      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits\\n\\t      // we really want the negative inverse, and -DV < y < DV\\n\\t      return (y>0)?this.DV-y:-y;\\n\\t    }\\n\\t\\n\\t    // Montgomery reduction\\n\\t    function Montgomery(m) {\\n\\t      this.m = m;\\n\\t      this.mp = m.invDigit();\\n\\t      this.mpl = this.mp&0x7fff;\\n\\t      this.mph = this.mp>>15;\\n\\t      this.um = (1<<(m.DB-15))-1;\\n\\t      this.mt2 = 2*m.t;\\n\\t    }\\n\\t\\n\\t    // xR mod m\\n\\t    function montConvert(x) {\\n\\t      var r = nbi();\\n\\t      x.abs().dlShiftTo(this.m.t,r);\\n\\t      r.divRemTo(this.m,null,r);\\n\\t      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\\n\\t      return r;\\n\\t    }\\n\\t\\n\\t    // x/R mod m\\n\\t    function montRevert(x) {\\n\\t      var r = nbi();\\n\\t      x.copyTo(r);\\n\\t      this.reduce(r);\\n\\t      return r;\\n\\t    }\\n\\t\\n\\t    // x = x/R mod m (HAC 14.32)\\n\\t    function montReduce(x) {\\n\\t      while(x.t <= this.mt2) // pad x so am has enough room later\\n\\t        x[x.t++] = 0;\\n\\t      for(var i = 0; i < this.m.t; ++i) {\\n\\t        // faster way of calculating u0 = x[i]*mp mod DV\\n\\t        var j = x[i]&0x7fff;\\n\\t        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\\n\\t        // use am to combine the multiply-shift-add into one call\\n\\t        j = i+this.m.t;\\n\\t        x[j] += this.m.am(0,u0,x,i,0,this.m.t);\\n\\t        // propagate carry\\n\\t        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\\n\\t      }\\n\\t      x.clamp();\\n\\t      x.drShiftTo(this.m.t,x);\\n\\t      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\\n\\t    }\\n\\t\\n\\t    // r = \\\"x^2/R mod m\\\"; x != r\\n\\t    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\\n\\t\\n\\t    // r = \\\"xy/R mod m\\\"; x,y != r\\n\\t    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\\n\\t\\n\\t    Montgomery.prototype.convert = montConvert;\\n\\t    Montgomery.prototype.revert = montRevert;\\n\\t    Montgomery.prototype.reduce = montReduce;\\n\\t    Montgomery.prototype.mulTo = montMulTo;\\n\\t    Montgomery.prototype.sqrTo = montSqrTo;\\n\\t\\n\\t    // (protected) true iff this is even\\n\\t    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\\n\\t\\n\\t    // (protected) this^e, e < 2^32, doing sqr and mul with \\\"r\\\" (HAC 14.79)\\n\\t    function bnpExp(e,z) {\\n\\t      if(e > 0xffffffff || e < 1) return BigInteger.ONE;\\n\\t      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\\n\\t      g.copyTo(r);\\n\\t      while(--i >= 0) {\\n\\t        z.sqrTo(r,r2);\\n\\t        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\\n\\t        else { var t = r; r = r2; r2 = t; }\\n\\t      }\\n\\t      return z.revert(r);\\n\\t    }\\n\\t\\n\\t    // (public) this^e % m, 0 <= e < 2^32\\n\\t    function bnModPowInt(e,m) {\\n\\t      var z;\\n\\t      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\\n\\t      return this.exp(e,z);\\n\\t    }\\n\\t\\n\\t    // protected\\n\\t    BigInteger.prototype.copyTo = bnpCopyTo;\\n\\t    BigInteger.prototype.fromInt = bnpFromInt;\\n\\t    BigInteger.prototype.fromString = bnpFromString;\\n\\t    BigInteger.prototype.clamp = bnpClamp;\\n\\t    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\\n\\t    BigInteger.prototype.drShiftTo = bnpDRShiftTo;\\n\\t    BigInteger.prototype.lShiftTo = bnpLShiftTo;\\n\\t    BigInteger.prototype.rShiftTo = bnpRShiftTo;\\n\\t    BigInteger.prototype.subTo = bnpSubTo;\\n\\t    BigInteger.prototype.multiplyTo = bnpMultiplyTo;\\n\\t    BigInteger.prototype.squareTo = bnpSquareTo;\\n\\t    BigInteger.prototype.divRemTo = bnpDivRemTo;\\n\\t    BigInteger.prototype.invDigit = bnpInvDigit;\\n\\t    BigInteger.prototype.isEven = bnpIsEven;\\n\\t    BigInteger.prototype.exp = bnpExp;\\n\\t\\n\\t    // public\\n\\t    BigInteger.prototype.toString = bnToString;\\n\\t    BigInteger.prototype.negate = bnNegate;\\n\\t    BigInteger.prototype.abs = bnAbs;\\n\\t    BigInteger.prototype.compareTo = bnCompareTo;\\n\\t    BigInteger.prototype.bitLength = bnBitLength;\\n\\t    BigInteger.prototype.mod = bnMod;\\n\\t    BigInteger.prototype.modPowInt = bnModPowInt;\\n\\t\\n\\t    // \\\"constants\\\"\\n\\t    BigInteger.ZERO = nbv(0);\\n\\t    BigInteger.ONE = nbv(1);\\n\\t\\n\\t    // Copyright (c) 2005-2009  Tom Wu\\n\\t    // All Rights Reserved.\\n\\t    // See \\\"LICENSE\\\" for details.\\n\\t\\n\\t    // Extended JavaScript BN functions, required for RSA private ops.\\n\\t\\n\\t    // Version 1.1: new BigInteger(\\\"0\\\", 10) returns \\\"proper\\\" zero\\n\\t    // Version 1.2: square() API, isProbablePrime fix\\n\\t\\n\\t    // (public)\\n\\t    function bnClone() { var r = nbi(); this.copyTo(r); return r; }\\n\\t\\n\\t    // (public) return value as integer\\n\\t    function bnIntValue() {\\n\\t      if(this.s < 0) {\\n\\t        if(this.t == 1) return this[0]-this.DV;\\n\\t        else if(this.t == 0) return -1;\\n\\t      }\\n\\t      else if(this.t == 1) return this[0];\\n\\t      else if(this.t == 0) return 0;\\n\\t      // assumes 16 < DB < 32\\n\\t      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\\n\\t    }\\n\\t\\n\\t    // (public) return value as byte\\n\\t    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\\n\\t\\n\\t    // (public) return value as short (assumes DB>=16)\\n\\t    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\\n\\t\\n\\t    // (protected) return x s.t. r^x < DV\\n\\t    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\\n\\t\\n\\t    // (public) 0 if this == 0, 1 if this > 0\\n\\t    function bnSigNum() {\\n\\t      if(this.s < 0) return -1;\\n\\t      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\\n\\t      else return 1;\\n\\t    }\\n\\t\\n\\t    // (protected) convert to radix string\\n\\t    function bnpToRadix(b) {\\n\\t      if(b == null) b = 10;\\n\\t      if(this.signum() == 0 || b < 2 || b > 36) return \\\"0\\\";\\n\\t      var cs = this.chunkSize(b);\\n\\t      var a = Math.pow(b,cs);\\n\\t      var d = nbv(a), y = nbi(), z = nbi(), r = \\\"\\\";\\n\\t      this.divRemTo(d,y,z);\\n\\t      while(y.signum() > 0) {\\n\\t        r = (a+z.intValue()).toString(b).substr(1) + r;\\n\\t        y.divRemTo(d,y,z);\\n\\t      }\\n\\t      return z.intValue().toString(b) + r;\\n\\t    }\\n\\t\\n\\t    // (protected) convert from radix string\\n\\t    function bnpFromRadix(s,b) {\\n\\t      this.fromInt(0);\\n\\t      if(b == null) b = 10;\\n\\t      var cs = this.chunkSize(b);\\n\\t      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\\n\\t      for(var i = 0; i < s.length; ++i) {\\n\\t        var x = intAt(s,i);\\n\\t        if(x < 0) {\\n\\t          if(s.charAt(i) == \\\"-\\\" && this.signum() == 0) mi = true;\\n\\t          continue;\\n\\t        }\\n\\t        w = b*w+x;\\n\\t        if(++j >= cs) {\\n\\t          this.dMultiply(d);\\n\\t          this.dAddOffset(w,0);\\n\\t          j = 0;\\n\\t          w = 0;\\n\\t        }\\n\\t      }\\n\\t      if(j > 0) {\\n\\t        this.dMultiply(Math.pow(b,j));\\n\\t        this.dAddOffset(w,0);\\n\\t      }\\n\\t      if(mi) BigInteger.ZERO.subTo(this,this);\\n\\t    }\\n\\t\\n\\t    // (protected) alternate constructor\\n\\t    function bnpFromNumber(a,b,c) {\\n\\t      if(\\\"number\\\" == typeof b) {\\n\\t        // new BigInteger(int,int,RNG)\\n\\t        if(a < 2) this.fromInt(1);\\n\\t        else {\\n\\t          this.fromNumber(a,c);\\n\\t          if(!this.testBit(a-1))\\t// force MSB set\\n\\t            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\\n\\t          if(this.isEven()) this.dAddOffset(1,0); // force odd\\n\\t          while(!this.isProbablePrime(b)) {\\n\\t            this.dAddOffset(2,0);\\n\\t            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\\n\\t          }\\n\\t        }\\n\\t      }\\n\\t      else {\\n\\t        // new BigInteger(int,RNG)\\n\\t        var x = new Array(), t = a&7;\\n\\t        x.length = (a>>3)+1;\\n\\t        b.nextBytes(x);\\n\\t        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\\n\\t        this.fromString(x,256);\\n\\t      }\\n\\t    }\\n\\t\\n\\t    // (public) convert to bigendian byte array\\n\\t    function bnToByteArray() {\\n\\t      var i = this.t, r = new Array();\\n\\t      r[0] = this.s;\\n\\t      var p = this.DB-(i*this.DB)%8, d, k = 0;\\n\\t      if(i-- > 0) {\\n\\t        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\\n\\t          r[k++] = d|(this.s<<(this.DB-p));\\n\\t        while(i >= 0) {\\n\\t          if(p < 8) {\\n\\t            d = (this[i]&((1<<p)-1))<<(8-p);\\n\\t            d |= this[--i]>>(p+=this.DB-8);\\n\\t          }\\n\\t          else {\\n\\t            d = (this[i]>>(p-=8))&0xff;\\n\\t            if(p <= 0) { p += this.DB; --i; }\\n\\t          }\\n\\t          if((d&0x80) != 0) d |= -256;\\n\\t          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\\n\\t          if(k > 0 || d != this.s) r[k++] = d;\\n\\t        }\\n\\t      }\\n\\t      return r;\\n\\t    }\\n\\t\\n\\t    function bnEquals(a) { return(this.compareTo(a)==0); }\\n\\t    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }\\n\\t    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }\\n\\t\\n\\t    // (protected) r = this op a (bitwise)\\n\\t    function bnpBitwiseTo(a,op,r) {\\n\\t      var i, f, m = Math.min(a.t,this.t);\\n\\t      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\\n\\t      if(a.t < this.t) {\\n\\t        f = a.s&this.DM;\\n\\t        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\\n\\t        r.t = this.t;\\n\\t      }\\n\\t      else {\\n\\t        f = this.s&this.DM;\\n\\t        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\\n\\t        r.t = a.t;\\n\\t      }\\n\\t      r.s = op(this.s,a.s);\\n\\t      r.clamp();\\n\\t    }\\n\\t\\n\\t    // (public) this & a\\n\\t    function op_and(x,y) { return x&y; }\\n\\t    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\\n\\t\\n\\t    // (public) this | a\\n\\t    function op_or(x,y) { return x|y; }\\n\\t    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\\n\\t\\n\\t    // (public) this ^ a\\n\\t    function op_xor(x,y) { return x^y; }\\n\\t    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\\n\\t\\n\\t    // (public) this & ~a\\n\\t    function op_andnot(x,y) { return x&~y; }\\n\\t    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\\n\\t\\n\\t    // (public) ~this\\n\\t    function bnNot() {\\n\\t      var r = nbi();\\n\\t      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\\n\\t      r.t = this.t;\\n\\t      r.s = ~this.s;\\n\\t      return r;\\n\\t    }\\n\\t\\n\\t    // (public) this << n\\n\\t    function bnShiftLeft(n) {\\n\\t      var r = nbi();\\n\\t      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\\n\\t      return r;\\n\\t    }\\n\\t\\n\\t    // (public) this >> n\\n\\t    function bnShiftRight(n) {\\n\\t      var r = nbi();\\n\\t      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\\n\\t      return r;\\n\\t    }\\n\\t\\n\\t    // return index of lowest 1-bit in x, x < 2^31\\n\\t    function lbit(x) {\\n\\t      if(x == 0) return -1;\\n\\t      var r = 0;\\n\\t      if((x&0xffff) == 0) { x >>= 16; r += 16; }\\n\\t      if((x&0xff) == 0) { x >>= 8; r += 8; }\\n\\t      if((x&0xf) == 0) { x >>= 4; r += 4; }\\n\\t      if((x&3) == 0) { x >>= 2; r += 2; }\\n\\t      if((x&1) == 0) ++r;\\n\\t      return r;\\n\\t    }\\n\\t\\n\\t    // (public) returns index of lowest 1-bit (or -1 if none)\\n\\t    function bnGetLowestSetBit() {\\n\\t      for(var i = 0; i < this.t; ++i)\\n\\t        if(this[i] != 0) return i*this.DB+lbit(this[i]);\\n\\t      if(this.s < 0) return this.t*this.DB;\\n\\t      return -1;\\n\\t    }\\n\\t\\n\\t    // return number of 1 bits in x\\n\\t    function cbit(x) {\\n\\t      var r = 0;\\n\\t      while(x != 0) { x &= x-1; ++r; }\\n\\t      return r;\\n\\t    }\\n\\t\\n\\t    // (public) return number of set bits\\n\\t    function bnBitCount() {\\n\\t      var r = 0, x = this.s&this.DM;\\n\\t      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\\n\\t      return r;\\n\\t    }\\n\\t\\n\\t    // (public) true iff nth bit is set\\n\\t    function bnTestBit(n) {\\n\\t      var j = Math.floor(n/this.DB);\\n\\t      if(j >= this.t) return(this.s!=0);\\n\\t      return((this[j]&(1<<(n%this.DB)))!=0);\\n\\t    }\\n\\t\\n\\t    // (protected) this op (1<<n)\\n\\t    function bnpChangeBit(n,op) {\\n\\t      var r = BigInteger.ONE.shiftLeft(n);\\n\\t      this.bitwiseTo(r,op,r);\\n\\t      return r;\\n\\t    }\\n\\t\\n\\t    // (public) this | (1<<n)\\n\\t    function bnSetBit(n) { return this.changeBit(n,op_or); }\\n\\t\\n\\t    // (public) this & ~(1<<n)\\n\\t    function bnClearBit(n) { return this.changeBit(n,op_andnot); }\\n\\t\\n\\t    // (public) this ^ (1<<n)\\n\\t    function bnFlipBit(n) { return this.changeBit(n,op_xor); }\\n\\t\\n\\t    // (protected) r = this + a\\n\\t    function bnpAddTo(a,r) {\\n\\t      var i = 0, c = 0, m = Math.min(a.t,this.t);\\n\\t      while(i < m) {\\n\\t        c += this[i]+a[i];\\n\\t        r[i++] = c&this.DM;\\n\\t        c >>= this.DB;\\n\\t      }\\n\\t      if(a.t < this.t) {\\n\\t        c += a.s;\\n\\t        while(i < this.t) {\\n\\t          c += this[i];\\n\\t          r[i++] = c&this.DM;\\n\\t          c >>= this.DB;\\n\\t        }\\n\\t        c += this.s;\\n\\t      }\\n\\t      else {\\n\\t        c += this.s;\\n\\t        while(i < a.t) {\\n\\t          c += a[i];\\n\\t          r[i++] = c&this.DM;\\n\\t          c >>= this.DB;\\n\\t        }\\n\\t        c += a.s;\\n\\t      }\\n\\t      r.s = (c<0)?-1:0;\\n\\t      if(c > 0) r[i++] = c;\\n\\t      else if(c < -1) r[i++] = this.DV+c;\\n\\t      r.t = i;\\n\\t      r.clamp();\\n\\t    }\\n\\t\\n\\t    // (public) this + a\\n\\t    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\\n\\t\\n\\t    // (public) this - a\\n\\t    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\\n\\t\\n\\t    // (public) this * a\\n\\t    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\\n\\t\\n\\t    // (public) this^2\\n\\t    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }\\n\\t\\n\\t    // (public) this / a\\n\\t    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\\n\\t\\n\\t    // (public) this % a\\n\\t    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\\n\\t\\n\\t    // (public) [this/a,this%a]\\n\\t    function bnDivideAndRemainder(a) {\\n\\t      var q = nbi(), r = nbi();\\n\\t      this.divRemTo(a,q,r);\\n\\t      return new Array(q,r);\\n\\t    }\\n\\t\\n\\t    // (protected) this *= n, this >= 0, 1 < n < DV\\n\\t    function bnpDMultiply(n) {\\n\\t      this[this.t] = this.am(0,n-1,this,0,0,this.t);\\n\\t      ++this.t;\\n\\t      this.clamp();\\n\\t    }\\n\\t\\n\\t    // (protected) this += n << w words, this >= 0\\n\\t    function bnpDAddOffset(n,w) {\\n\\t      if(n == 0) return;\\n\\t      while(this.t <= w) this[this.t++] = 0;\\n\\t      this[w] += n;\\n\\t      while(this[w] >= this.DV) {\\n\\t        this[w] -= this.DV;\\n\\t        if(++w >= this.t) this[this.t++] = 0;\\n\\t        ++this[w];\\n\\t      }\\n\\t    }\\n\\t\\n\\t    // A \\\"null\\\" reducer\\n\\t    function NullExp() {}\\n\\t    function nNop(x) { return x; }\\n\\t    function nMulTo(x,y,r) { x.multiplyTo(y,r); }\\n\\t    function nSqrTo(x,r) { x.squareTo(r); }\\n\\t\\n\\t    NullExp.prototype.convert = nNop;\\n\\t    NullExp.prototype.revert = nNop;\\n\\t    NullExp.prototype.mulTo = nMulTo;\\n\\t    NullExp.prototype.sqrTo = nSqrTo;\\n\\t\\n\\t    // (public) this^e\\n\\t    function bnPow(e) { return this.exp(e,new NullExp()); }\\n\\t\\n\\t    // (protected) r = lower n words of \\\"this * a\\\", a.t <= n\\n\\t    // \\\"this\\\" should be the larger one if appropriate.\\n\\t    function bnpMultiplyLowerTo(a,n,r) {\\n\\t      var i = Math.min(this.t+a.t,n);\\n\\t      r.s = 0; // assumes a,this >= 0\\n\\t      r.t = i;\\n\\t      while(i > 0) r[--i] = 0;\\n\\t      var j;\\n\\t      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\\n\\t      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\\n\\t      r.clamp();\\n\\t    }\\n\\t\\n\\t    // (protected) r = \\\"this * a\\\" without lower n words, n > 0\\n\\t    // \\\"this\\\" should be the larger one if appropriate.\\n\\t    function bnpMultiplyUpperTo(a,n,r) {\\n\\t      --n;\\n\\t      var i = r.t = this.t+a.t-n;\\n\\t      r.s = 0; // assumes a,this >= 0\\n\\t      while(--i >= 0) r[i] = 0;\\n\\t      for(i = Math.max(n-this.t,0); i < a.t; ++i)\\n\\t        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\\n\\t      r.clamp();\\n\\t      r.drShiftTo(1,r);\\n\\t    }\\n\\t\\n\\t    // Barrett modular reduction\\n\\t    function Barrett(m) {\\n\\t      // setup Barrett\\n\\t      this.r2 = nbi();\\n\\t      this.q3 = nbi();\\n\\t      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\\n\\t      this.mu = this.r2.divide(m);\\n\\t      this.m = m;\\n\\t    }\\n\\t\\n\\t    function barrettConvert(x) {\\n\\t      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\\n\\t      else if(x.compareTo(this.m) < 0) return x;\\n\\t      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\\n\\t    }\\n\\t\\n\\t    function barrettRevert(x) { return x; }\\n\\t\\n\\t    // x = x mod m (HAC 14.42)\\n\\t    function barrettReduce(x) {\\n\\t      x.drShiftTo(this.m.t-1,this.r2);\\n\\t      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\\n\\t      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\\n\\t      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\\n\\t      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\\n\\t      x.subTo(this.r2,x);\\n\\t      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\\n\\t    }\\n\\t\\n\\t    // r = x^2 mod m; x != r\\n\\t    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\\n\\t\\n\\t    // r = x*y mod m; x,y != r\\n\\t    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\\n\\t\\n\\t    Barrett.prototype.convert = barrettConvert;\\n\\t    Barrett.prototype.revert = barrettRevert;\\n\\t    Barrett.prototype.reduce = barrettReduce;\\n\\t    Barrett.prototype.mulTo = barrettMulTo;\\n\\t    Barrett.prototype.sqrTo = barrettSqrTo;\\n\\t\\n\\t    // (public) this^e % m (HAC 14.85)\\n\\t    function bnModPow(e,m) {\\n\\t      var i = e.bitLength(), k, r = nbv(1), z;\\n\\t      if(i <= 0) return r;\\n\\t      else if(i < 18) k = 1;\\n\\t      else if(i < 48) k = 3;\\n\\t      else if(i < 144) k = 4;\\n\\t      else if(i < 768) k = 5;\\n\\t      else k = 6;\\n\\t      if(i < 8)\\n\\t        z = new Classic(m);\\n\\t      else if(m.isEven())\\n\\t        z = new Barrett(m);\\n\\t      else\\n\\t        z = new Montgomery(m);\\n\\t\\n\\t      // precomputation\\n\\t      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\\n\\t      g[1] = z.convert(this);\\n\\t      if(k > 1) {\\n\\t        var g2 = nbi();\\n\\t        z.sqrTo(g[1],g2);\\n\\t        while(n <= km) {\\n\\t          g[n] = nbi();\\n\\t          z.mulTo(g2,g[n-2],g[n]);\\n\\t          n += 2;\\n\\t        }\\n\\t      }\\n\\t\\n\\t      var j = e.t-1, w, is1 = true, r2 = nbi(), t;\\n\\t      i = nbits(e[j])-1;\\n\\t      while(j >= 0) {\\n\\t        if(i >= k1) w = (e[j]>>(i-k1))&km;\\n\\t        else {\\n\\t          w = (e[j]&((1<<(i+1))-1))<<(k1-i);\\n\\t          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\\n\\t        }\\n\\t\\n\\t        n = k;\\n\\t        while((w&1) == 0) { w >>= 1; --n; }\\n\\t        if((i -= n) < 0) { i += this.DB; --j; }\\n\\t        if(is1) {\\t// ret == 1, don't bother squaring or multiplying it\\n\\t          g[w].copyTo(r);\\n\\t          is1 = false;\\n\\t        }\\n\\t        else {\\n\\t          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\\n\\t          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\\n\\t          z.mulTo(r2,g[w],r);\\n\\t        }\\n\\t\\n\\t        while(j >= 0 && (e[j]&(1<<i)) == 0) {\\n\\t          z.sqrTo(r,r2); t = r; r = r2; r2 = t;\\n\\t          if(--i < 0) { i = this.DB-1; --j; }\\n\\t        }\\n\\t      }\\n\\t      return z.revert(r);\\n\\t    }\\n\\t\\n\\t    // (public) gcd(this,a) (HAC 14.54)\\n\\t    function bnGCD(a) {\\n\\t      var x = (this.s<0)?this.negate():this.clone();\\n\\t      var y = (a.s<0)?a.negate():a.clone();\\n\\t      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\\n\\t      var i = x.getLowestSetBit(), g = y.getLowestSetBit();\\n\\t      if(g < 0) return x;\\n\\t      if(i < g) g = i;\\n\\t      if(g > 0) {\\n\\t        x.rShiftTo(g,x);\\n\\t        y.rShiftTo(g,y);\\n\\t      }\\n\\t      while(x.signum() > 0) {\\n\\t        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\\n\\t        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\\n\\t        if(x.compareTo(y) >= 0) {\\n\\t          x.subTo(y,x);\\n\\t          x.rShiftTo(1,x);\\n\\t        }\\n\\t        else {\\n\\t          y.subTo(x,y);\\n\\t          y.rShiftTo(1,y);\\n\\t        }\\n\\t      }\\n\\t      if(g > 0) y.lShiftTo(g,y);\\n\\t      return y;\\n\\t    }\\n\\t\\n\\t    // (protected) this % n, n < 2^26\\n\\t    function bnpModInt(n) {\\n\\t      if(n <= 0) return 0;\\n\\t      var d = this.DV%n, r = (this.s<0)?n-1:0;\\n\\t      if(this.t > 0)\\n\\t        if(d == 0) r = this[0]%n;\\n\\t        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\\n\\t      return r;\\n\\t    }\\n\\t\\n\\t    // (public) 1/this % m (HAC 14.61)\\n\\t    function bnModInverse(m) {\\n\\t      var ac = m.isEven();\\n\\t      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\\n\\t      var u = m.clone(), v = this.clone();\\n\\t      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\\n\\t      while(u.signum() != 0) {\\n\\t        while(u.isEven()) {\\n\\t          u.rShiftTo(1,u);\\n\\t          if(ac) {\\n\\t            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\\n\\t            a.rShiftTo(1,a);\\n\\t          }\\n\\t          else if(!b.isEven()) b.subTo(m,b);\\n\\t          b.rShiftTo(1,b);\\n\\t        }\\n\\t        while(v.isEven()) {\\n\\t          v.rShiftTo(1,v);\\n\\t          if(ac) {\\n\\t            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\\n\\t            c.rShiftTo(1,c);\\n\\t          }\\n\\t          else if(!d.isEven()) d.subTo(m,d);\\n\\t          d.rShiftTo(1,d);\\n\\t        }\\n\\t        if(u.compareTo(v) >= 0) {\\n\\t          u.subTo(v,u);\\n\\t          if(ac) a.subTo(c,a);\\n\\t          b.subTo(d,b);\\n\\t        }\\n\\t        else {\\n\\t          v.subTo(u,v);\\n\\t          if(ac) c.subTo(a,c);\\n\\t          d.subTo(b,d);\\n\\t        }\\n\\t      }\\n\\t      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\\n\\t      if(d.compareTo(m) >= 0) return d.subtract(m);\\n\\t      if(d.signum() < 0) d.addTo(m,d); else return d;\\n\\t      if(d.signum() < 0) return d.add(m); else return d;\\n\\t    }\\n\\t\\n\\t    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\\n\\t    var lplim = (1<<26)/lowprimes[lowprimes.length-1];\\n\\t\\n\\t    // (public) test primality with certainty >= 1-.5^t\\n\\t    function bnIsProbablePrime(t) {\\n\\t      var i, x = this.abs();\\n\\t      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\\n\\t        for(i = 0; i < lowprimes.length; ++i)\\n\\t          if(x[0] == lowprimes[i]) return true;\\n\\t        return false;\\n\\t      }\\n\\t      if(x.isEven()) return false;\\n\\t      i = 1;\\n\\t      while(i < lowprimes.length) {\\n\\t        var m = lowprimes[i], j = i+1;\\n\\t        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\\n\\t        m = x.modInt(m);\\n\\t        while(i < j) if(m%lowprimes[i++] == 0) return false;\\n\\t      }\\n\\t      return x.millerRabin(t);\\n\\t    }\\n\\t\\n\\t    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\\n\\t    function bnpMillerRabin(t) {\\n\\t      var n1 = this.subtract(BigInteger.ONE);\\n\\t      var k = n1.getLowestSetBit();\\n\\t      if(k <= 0) return false;\\n\\t      var r = n1.shiftRight(k);\\n\\t      t = (t+1)>>1;\\n\\t      if(t > lowprimes.length) t = lowprimes.length;\\n\\t      var a = nbi();\\n\\t      for(var i = 0; i < t; ++i) {\\n\\t        //Pick bases at random, instead of starting at 2\\n\\t        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\\n\\t        var y = a.modPow(r,this);\\n\\t        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\\n\\t          var j = 1;\\n\\t          while(j++ < k && y.compareTo(n1) != 0) {\\n\\t            y = y.modPowInt(2,this);\\n\\t            if(y.compareTo(BigInteger.ONE) == 0) return false;\\n\\t          }\\n\\t          if(y.compareTo(n1) != 0) return false;\\n\\t        }\\n\\t      }\\n\\t      return true;\\n\\t    }\\n\\t\\n\\t    // protected\\n\\t    BigInteger.prototype.chunkSize = bnpChunkSize;\\n\\t    BigInteger.prototype.toRadix = bnpToRadix;\\n\\t    BigInteger.prototype.fromRadix = bnpFromRadix;\\n\\t    BigInteger.prototype.fromNumber = bnpFromNumber;\\n\\t    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\\n\\t    BigInteger.prototype.changeBit = bnpChangeBit;\\n\\t    BigInteger.prototype.addTo = bnpAddTo;\\n\\t    BigInteger.prototype.dMultiply = bnpDMultiply;\\n\\t    BigInteger.prototype.dAddOffset = bnpDAddOffset;\\n\\t    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\\n\\t    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\\n\\t    BigInteger.prototype.modInt = bnpModInt;\\n\\t    BigInteger.prototype.millerRabin = bnpMillerRabin;\\n\\t\\n\\t    // public\\n\\t    BigInteger.prototype.clone = bnClone;\\n\\t    BigInteger.prototype.intValue = bnIntValue;\\n\\t    BigInteger.prototype.byteValue = bnByteValue;\\n\\t    BigInteger.prototype.shortValue = bnShortValue;\\n\\t    BigInteger.prototype.signum = bnSigNum;\\n\\t    BigInteger.prototype.toByteArray = bnToByteArray;\\n\\t    BigInteger.prototype.equals = bnEquals;\\n\\t    BigInteger.prototype.min = bnMin;\\n\\t    BigInteger.prototype.max = bnMax;\\n\\t    BigInteger.prototype.and = bnAnd;\\n\\t    BigInteger.prototype.or = bnOr;\\n\\t    BigInteger.prototype.xor = bnXor;\\n\\t    BigInteger.prototype.andNot = bnAndNot;\\n\\t    BigInteger.prototype.not = bnNot;\\n\\t    BigInteger.prototype.shiftLeft = bnShiftLeft;\\n\\t    BigInteger.prototype.shiftRight = bnShiftRight;\\n\\t    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\\n\\t    BigInteger.prototype.bitCount = bnBitCount;\\n\\t    BigInteger.prototype.testBit = bnTestBit;\\n\\t    BigInteger.prototype.setBit = bnSetBit;\\n\\t    BigInteger.prototype.clearBit = bnClearBit;\\n\\t    BigInteger.prototype.flipBit = bnFlipBit;\\n\\t    BigInteger.prototype.add = bnAdd;\\n\\t    BigInteger.prototype.subtract = bnSubtract;\\n\\t    BigInteger.prototype.multiply = bnMultiply;\\n\\t    BigInteger.prototype.divide = bnDivide;\\n\\t    BigInteger.prototype.remainder = bnRemainder;\\n\\t    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\\n\\t    BigInteger.prototype.modPow = bnModPow;\\n\\t    BigInteger.prototype.modInverse = bnModInverse;\\n\\t    BigInteger.prototype.pow = bnPow;\\n\\t    BigInteger.prototype.gcd = bnGCD;\\n\\t    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\\n\\t\\n\\t    // JSBN-specific extension\\n\\t    BigInteger.prototype.square = bnSquare;\\n\\t\\n\\t    // Expose the Barrett function\\n\\t    BigInteger.prototype.Barrett = Barrett\\n\\t\\n\\t    // BigInteger interfaces not implemented in jsbn:\\n\\t\\n\\t    // BigInteger(int signum, byte[] magnitude)\\n\\t    // double doubleValue()\\n\\t    // float floatValue()\\n\\t    // int hashCode()\\n\\t    // long longValue()\\n\\t    // static BigInteger valueOf(long val)\\n\\t\\n\\t\\t// Random number generator - requires a PRNG backend, e.g. prng4.js\\n\\t\\n\\t\\t// For best results, put code like\\n\\t\\t// <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>\\n\\t\\t// in your main HTML document.\\n\\t\\n\\t\\tvar rng_state;\\n\\t\\tvar rng_pool;\\n\\t\\tvar rng_pptr;\\n\\t\\n\\t\\t// Mix in a 32-bit integer into the pool\\n\\t\\tfunction rng_seed_int(x) {\\n\\t\\t  rng_pool[rng_pptr++] ^= x & 255;\\n\\t\\t  rng_pool[rng_pptr++] ^= (x >> 8) & 255;\\n\\t\\t  rng_pool[rng_pptr++] ^= (x >> 16) & 255;\\n\\t\\t  rng_pool[rng_pptr++] ^= (x >> 24) & 255;\\n\\t\\t  if(rng_pptr >= rng_psize) rng_pptr -= rng_psize;\\n\\t\\t}\\n\\t\\n\\t\\t// Mix in the current time (w/milliseconds) into the pool\\n\\t\\tfunction rng_seed_time() {\\n\\t\\t  rng_seed_int(new Date().getTime());\\n\\t\\t}\\n\\t\\n\\t\\t// Initialize the pool with junk if needed.\\n\\t\\tif(rng_pool == null) {\\n\\t\\t  rng_pool = new Array();\\n\\t\\t  rng_pptr = 0;\\n\\t\\t  var t;\\n\\t\\t  if(typeof window !== \\\"undefined\\\" && window.crypto) {\\n\\t\\t\\tif (window.crypto.getRandomValues) {\\n\\t\\t\\t  // Use webcrypto if available\\n\\t\\t\\t  var ua = new Uint8Array(32);\\n\\t\\t\\t  window.crypto.getRandomValues(ua);\\n\\t\\t\\t  for(t = 0; t < 32; ++t)\\n\\t\\t\\t\\trng_pool[rng_pptr++] = ua[t];\\n\\t\\t\\t}\\n\\t\\t\\telse if(navigator.appName == \\\"Netscape\\\" && navigator.appVersion < \\\"5\\\") {\\n\\t\\t\\t  // Extract entropy (256 bits) from NS4 RNG if available\\n\\t\\t\\t  var z = window.crypto.random(32);\\n\\t\\t\\t  for(t = 0; t < z.length; ++t)\\n\\t\\t\\t\\trng_pool[rng_pptr++] = z.charCodeAt(t) & 255;\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t  while(rng_pptr < rng_psize) {  // extract some randomness from Math.random()\\n\\t\\t\\tt = Math.floor(65536 * Math.random());\\n\\t\\t\\trng_pool[rng_pptr++] = t >>> 8;\\n\\t\\t\\trng_pool[rng_pptr++] = t & 255;\\n\\t\\t  }\\n\\t\\t  rng_pptr = 0;\\n\\t\\t  rng_seed_time();\\n\\t\\t  //rng_seed_int(window.screenX);\\n\\t\\t  //rng_seed_int(window.screenY);\\n\\t\\t}\\n\\t\\n\\t\\tfunction rng_get_byte() {\\n\\t\\t  if(rng_state == null) {\\n\\t\\t\\trng_seed_time();\\n\\t\\t\\trng_state = prng_newstate();\\n\\t\\t\\trng_state.init(rng_pool);\\n\\t\\t\\tfor(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)\\n\\t\\t\\t  rng_pool[rng_pptr] = 0;\\n\\t\\t\\trng_pptr = 0;\\n\\t\\t\\t//rng_pool = null;\\n\\t\\t  }\\n\\t\\t  // TODO: allow reseeding after first request\\n\\t\\t  return rng_state.next();\\n\\t\\t}\\n\\t\\n\\t\\tfunction rng_get_bytes(ba) {\\n\\t\\t  var i;\\n\\t\\t  for(i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();\\n\\t\\t}\\n\\t\\n\\t\\tfunction SecureRandom() {}\\n\\t\\n\\t\\tSecureRandom.prototype.nextBytes = rng_get_bytes;\\n\\t\\n\\t\\t// prng4.js - uses Arcfour as a PRNG\\n\\t\\n\\t\\tfunction Arcfour() {\\n\\t\\t  this.i = 0;\\n\\t\\t  this.j = 0;\\n\\t\\t  this.S = new Array();\\n\\t\\t}\\n\\t\\n\\t\\t// Initialize arcfour context from key, an array of ints, each from [0..255]\\n\\t\\tfunction ARC4init(key) {\\n\\t\\t  var i, j, t;\\n\\t\\t  for(i = 0; i < 256; ++i)\\n\\t\\t\\tthis.S[i] = i;\\n\\t\\t  j = 0;\\n\\t\\t  for(i = 0; i < 256; ++i) {\\n\\t\\t\\tj = (j + this.S[i] + key[i % key.length]) & 255;\\n\\t\\t\\tt = this.S[i];\\n\\t\\t\\tthis.S[i] = this.S[j];\\n\\t\\t\\tthis.S[j] = t;\\n\\t\\t  }\\n\\t\\t  this.i = 0;\\n\\t\\t  this.j = 0;\\n\\t\\t}\\n\\t\\n\\t\\tfunction ARC4next() {\\n\\t\\t  var t;\\n\\t\\t  this.i = (this.i + 1) & 255;\\n\\t\\t  this.j = (this.j + this.S[this.i]) & 255;\\n\\t\\t  t = this.S[this.i];\\n\\t\\t  this.S[this.i] = this.S[this.j];\\n\\t\\t  this.S[this.j] = t;\\n\\t\\t  return this.S[(t + this.S[this.i]) & 255];\\n\\t\\t}\\n\\t\\n\\t\\tArcfour.prototype.init = ARC4init;\\n\\t\\tArcfour.prototype.next = ARC4next;\\n\\t\\n\\t\\t// Plug in your RNG constructor here\\n\\t\\tfunction prng_newstate() {\\n\\t\\t  return new Arcfour();\\n\\t\\t}\\n\\t\\n\\t\\t// Pool size must be a multiple of 4 and greater than 32.\\n\\t\\t// An array of bytes the size of the pool will be passed to init()\\n\\t\\tvar rng_psize = 256;\\n\\t\\n\\t  BigInteger.SecureRandom = SecureRandom;\\n\\t  BigInteger.BigInteger = BigInteger;\\n\\t  if (true) {\\n\\t    exports = module.exports = BigInteger;\\n\\t  } else {\\n\\t    this.BigInteger = BigInteger;\\n\\t    this.SecureRandom = SecureRandom;\\n\\t  }\\n\\t\\n\\t}).call(this);\\n\\n\\n/***/ },\\n/* 32 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\t/**\\n\\t * Check if `fn` is a function.\\n\\t *\\n\\t * @param {Function} fn\\n\\t * @return {Boolean}\\n\\t * @api private\\n\\t */\\n\\tvar isObject = __webpack_require__(14);\\n\\t\\n\\tfunction isFunction(fn) {\\n\\t  var tag = isObject(fn) ? Object.prototype.toString.call(fn) : '';\\n\\t  return tag === '[object Function]';\\n\\t}\\n\\t\\n\\tmodule.exports = isFunction;\\n\\n\\n/***/ },\\n/* 33 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\t/**\\n\\t * Module of mixed-in functions shared between node and client code\\n\\t */\\n\\tvar isObject = __webpack_require__(14);\\n\\t\\n\\t/**\\n\\t * Expose `RequestBase`.\\n\\t */\\n\\t\\n\\tmodule.exports = RequestBase;\\n\\t\\n\\t/**\\n\\t * Initialize a new `RequestBase`.\\n\\t *\\n\\t * @api public\\n\\t */\\n\\t\\n\\tfunction RequestBase(obj) {\\n\\t  if (obj) return mixin(obj);\\n\\t}\\n\\t\\n\\t/**\\n\\t * Mixin the prototype properties.\\n\\t *\\n\\t * @param {Object} obj\\n\\t * @return {Object}\\n\\t * @api private\\n\\t */\\n\\t\\n\\tfunction mixin(obj) {\\n\\t  for (var key in RequestBase.prototype) {\\n\\t    obj[key] = RequestBase.prototype[key];\\n\\t  }\\n\\t  return obj;\\n\\t}\\n\\t\\n\\t/**\\n\\t * Clear previous timeout.\\n\\t *\\n\\t * @return {Request} for chaining\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequestBase.prototype.clearTimeout = function _clearTimeout(){\\n\\t  clearTimeout(this._timer);\\n\\t  clearTimeout(this._responseTimeoutTimer);\\n\\t  delete this._timer;\\n\\t  delete this._responseTimeoutTimer;\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Override default response body parser\\n\\t *\\n\\t * This function will be called to convert incoming data into request.body\\n\\t *\\n\\t * @param {Function}\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequestBase.prototype.parse = function parse(fn){\\n\\t  this._parser = fn;\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Set format of binary response body.\\n\\t * In browser valid formats are 'blob' and 'arraybuffer',\\n\\t * which return Blob and ArrayBuffer, respectively.\\n\\t *\\n\\t * In Node all values result in Buffer.\\n\\t *\\n\\t * Examples:\\n\\t *\\n\\t *      req.get('/')\\n\\t *        .responseType('blob')\\n\\t *        .end(callback);\\n\\t *\\n\\t * @param {String} val\\n\\t * @return {Request} for chaining\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequestBase.prototype.responseType = function(val){\\n\\t  this._responseType = val;\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Override default request body serializer\\n\\t *\\n\\t * This function will be called to convert data set via .send or .attach into payload to send\\n\\t *\\n\\t * @param {Function}\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequestBase.prototype.serialize = function serialize(fn){\\n\\t  this._serializer = fn;\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Set timeouts.\\n\\t *\\n\\t * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.\\n\\t * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.\\n\\t *\\n\\t * Value of 0 or false means no timeout.\\n\\t *\\n\\t * @param {Number|Object} ms or {response, read, deadline}\\n\\t * @return {Request} for chaining\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequestBase.prototype.timeout = function timeout(options){\\n\\t  if (!options || 'object' !== typeof options) {\\n\\t    this._timeout = options;\\n\\t    this._responseTimeout = 0;\\n\\t    return this;\\n\\t  }\\n\\t\\n\\t  for(var option in options) {\\n\\t    switch(option) {\\n\\t      case 'deadline':\\n\\t        this._timeout = options.deadline;\\n\\t        break;\\n\\t      case 'response':\\n\\t        this._responseTimeout = options.response;\\n\\t        break;\\n\\t      default:\\n\\t        console.warn(\\\"Unknown timeout option\\\", option);\\n\\t    }\\n\\t  }\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Set number of retry attempts on error.\\n\\t *\\n\\t * Failed requests will be retried 'count' times if timeout or err.code >= 500.\\n\\t *\\n\\t * @param {Number} count\\n\\t * @return {Request} for chaining\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequestBase.prototype.retry = function retry(count){\\n\\t  // Default to 1 if no count passed or true\\n\\t  if (arguments.length === 0 || count === true) count = 1;\\n\\t  if (count <= 0) count = 0;\\n\\t  this._maxRetries = count;\\n\\t  this._retries = 0;\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Retry request\\n\\t *\\n\\t * @return {Request} for chaining\\n\\t * @api private\\n\\t */\\n\\t\\n\\tRequestBase.prototype._retry = function() {\\n\\t  this.clearTimeout();\\n\\t\\n\\t  // node\\n\\t  if (this.req) {\\n\\t    this.req = null;\\n\\t    this.req = this.request();\\n\\t  }\\n\\t\\n\\t  this._aborted = false;\\n\\t  this.timedout = false;\\n\\t\\n\\t  return this._end();\\n\\t};\\n\\t\\n\\t/**\\n\\t * Promise support\\n\\t *\\n\\t * @param {Function} resolve\\n\\t * @param {Function} [reject]\\n\\t * @return {Request}\\n\\t */\\n\\t\\n\\tRequestBase.prototype.then = function then(resolve, reject) {\\n\\t  if (!this._fullfilledPromise) {\\n\\t    var self = this;\\n\\t    if (this._endCalled) {\\n\\t      console.warn(\\\"Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises\\\");\\n\\t    }\\n\\t    this._fullfilledPromise = new Promise(function(innerResolve, innerReject){\\n\\t      self.end(function(err, res){\\n\\t        if (err) innerReject(err); else innerResolve(res);\\n\\t      });\\n\\t    });\\n\\t  }\\n\\t  return this._fullfilledPromise.then(resolve, reject);\\n\\t}\\n\\t\\n\\tRequestBase.prototype.catch = function(cb) {\\n\\t  return this.then(undefined, cb);\\n\\t};\\n\\t\\n\\t/**\\n\\t * Allow for extension\\n\\t */\\n\\t\\n\\tRequestBase.prototype.use = function use(fn) {\\n\\t  fn(this);\\n\\t  return this;\\n\\t}\\n\\t\\n\\tRequestBase.prototype.ok = function(cb) {\\n\\t  if ('function' !== typeof cb) throw Error(\\\"Callback required\\\");\\n\\t  this._okCallback = cb;\\n\\t  return this;\\n\\t};\\n\\t\\n\\tRequestBase.prototype._isResponseOK = function(res) {\\n\\t  if (!res) {\\n\\t    return false;\\n\\t  }\\n\\t\\n\\t  if (this._okCallback) {\\n\\t    return this._okCallback(res);\\n\\t  }\\n\\t\\n\\t  return res.status >= 200 && res.status < 300;\\n\\t};\\n\\t\\n\\t\\n\\t/**\\n\\t * Get request header `field`.\\n\\t * Case-insensitive.\\n\\t *\\n\\t * @param {String} field\\n\\t * @return {String}\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequestBase.prototype.get = function(field){\\n\\t  return this._header[field.toLowerCase()];\\n\\t};\\n\\t\\n\\t/**\\n\\t * Get case-insensitive header `field` value.\\n\\t * This is a deprecated internal API. Use `.get(field)` instead.\\n\\t *\\n\\t * (getHeader is no longer used internally by the superagent code base)\\n\\t *\\n\\t * @param {String} field\\n\\t * @return {String}\\n\\t * @api private\\n\\t * @deprecated\\n\\t */\\n\\t\\n\\tRequestBase.prototype.getHeader = RequestBase.prototype.get;\\n\\t\\n\\t/**\\n\\t * Set header `field` to `val`, or multiple fields with one object.\\n\\t * Case-insensitive.\\n\\t *\\n\\t * Examples:\\n\\t *\\n\\t *      req.get('/')\\n\\t *        .set('Accept', 'application/json')\\n\\t *        .set('X-API-Key', 'foobar')\\n\\t *        .end(callback);\\n\\t *\\n\\t *      req.get('/')\\n\\t *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\\n\\t *        .end(callback);\\n\\t *\\n\\t * @param {String|Object} field\\n\\t * @param {String} val\\n\\t * @return {Request} for chaining\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequestBase.prototype.set = function(field, val){\\n\\t  if (isObject(field)) {\\n\\t    for (var key in field) {\\n\\t      this.set(key, field[key]);\\n\\t    }\\n\\t    return this;\\n\\t  }\\n\\t  this._header[field.toLowerCase()] = val;\\n\\t  this.header[field] = val;\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Remove header `field`.\\n\\t * Case-insensitive.\\n\\t *\\n\\t * Example:\\n\\t *\\n\\t *      req.get('/')\\n\\t *        .unset('User-Agent')\\n\\t *        .end(callback);\\n\\t *\\n\\t * @param {String} field\\n\\t */\\n\\tRequestBase.prototype.unset = function(field){\\n\\t  delete this._header[field.toLowerCase()];\\n\\t  delete this.header[field];\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Write the field `name` and `val`, or multiple fields with one object\\n\\t * for \\\"multipart/form-data\\\" request bodies.\\n\\t *\\n\\t * ``` js\\n\\t * request.post('/upload')\\n\\t *   .field('foo', 'bar')\\n\\t *   .end(callback);\\n\\t *\\n\\t * request.post('/upload')\\n\\t *   .field({ foo: 'bar', baz: 'qux' })\\n\\t *   .end(callback);\\n\\t * ```\\n\\t *\\n\\t * @param {String|Object} name\\n\\t * @param {String|Blob|File|Buffer|fs.ReadStream} val\\n\\t * @return {Request} for chaining\\n\\t * @api public\\n\\t */\\n\\tRequestBase.prototype.field = function(name, val) {\\n\\t\\n\\t  // name should be either a string or an object.\\n\\t  if (null === name ||  undefined === name) {\\n\\t    throw new Error('.field(name, val) name can not be empty');\\n\\t  }\\n\\t\\n\\t  if (this._data) {\\n\\t    console.error(\\\".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()\\\");\\n\\t  }\\n\\t\\n\\t  if (isObject(name)) {\\n\\t    for (var key in name) {\\n\\t      this.field(key, name[key]);\\n\\t    }\\n\\t    return this;\\n\\t  }\\n\\t\\n\\t  if (Array.isArray(val)) {\\n\\t    for (var i in val) {\\n\\t      this.field(name, val[i]);\\n\\t    }\\n\\t    return this;\\n\\t  }\\n\\t\\n\\t  // val should be defined now\\n\\t  if (null === val || undefined === val) {\\n\\t    throw new Error('.field(name, val) val can not be empty');\\n\\t  }\\n\\t  if ('boolean' === typeof val) {\\n\\t    val = '' + val;\\n\\t  }\\n\\t  this._getFormData().append(name, val);\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Abort the request, and clear potential timeout.\\n\\t *\\n\\t * @return {Request}\\n\\t * @api public\\n\\t */\\n\\tRequestBase.prototype.abort = function(){\\n\\t  if (this._aborted) {\\n\\t    return this;\\n\\t  }\\n\\t  this._aborted = true;\\n\\t  this.xhr && this.xhr.abort(); // browser\\n\\t  this.req && this.req.abort(); // node\\n\\t  this.clearTimeout();\\n\\t  this.emit('abort');\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Enable transmission of cookies with x-domain requests.\\n\\t *\\n\\t * Note that for this to work the origin must not be\\n\\t * using \\\"Access-Control-Allow-Origin\\\" with a wildcard,\\n\\t * and also must set \\\"Access-Control-Allow-Credentials\\\"\\n\\t * to \\\"true\\\".\\n\\t *\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequestBase.prototype.withCredentials = function(on){\\n\\t  // This is browser-only functionality. Node side is no-op.\\n\\t  if(on==undefined) on = true;\\n\\t  this._withCredentials = on;\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Set the max redirects to `n`. Does noting in browser XHR implementation.\\n\\t *\\n\\t * @param {Number} n\\n\\t * @return {Request} for chaining\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequestBase.prototype.redirects = function(n){\\n\\t  this._maxRedirects = n;\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Convert to a plain javascript object (not JSON string) of scalar properties.\\n\\t * Note as this method is designed to return a useful non-this value,\\n\\t * it cannot be chained.\\n\\t *\\n\\t * @return {Object} describing method, url, and data of this request\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequestBase.prototype.toJSON = function(){\\n\\t  return {\\n\\t    method: this.method,\\n\\t    url: this.url,\\n\\t    data: this._data,\\n\\t    headers: this._header\\n\\t  };\\n\\t};\\n\\t\\n\\t\\n\\t/**\\n\\t * Send `data` as the request body, defaulting the `.type()` to \\\"json\\\" when\\n\\t * an object is given.\\n\\t *\\n\\t * Examples:\\n\\t *\\n\\t *       // manual json\\n\\t *       request.post('/user')\\n\\t *         .type('json')\\n\\t *         .send('{\\\"name\\\":\\\"tj\\\"}')\\n\\t *         .end(callback)\\n\\t *\\n\\t *       // auto json\\n\\t *       request.post('/user')\\n\\t *         .send({ name: 'tj' })\\n\\t *         .end(callback)\\n\\t *\\n\\t *       // manual x-www-form-urlencoded\\n\\t *       request.post('/user')\\n\\t *         .type('form')\\n\\t *         .send('name=tj')\\n\\t *         .end(callback)\\n\\t *\\n\\t *       // auto x-www-form-urlencoded\\n\\t *       request.post('/user')\\n\\t *         .type('form')\\n\\t *         .send({ name: 'tj' })\\n\\t *         .end(callback)\\n\\t *\\n\\t *       // defaults to x-www-form-urlencoded\\n\\t *      request.post('/user')\\n\\t *        .send('name=tobi')\\n\\t *        .send('species=ferret')\\n\\t *        .end(callback)\\n\\t *\\n\\t * @param {String|Object} data\\n\\t * @return {Request} for chaining\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequestBase.prototype.send = function(data){\\n\\t  var isObj = isObject(data);\\n\\t  var type = this._header['content-type'];\\n\\t\\n\\t  if (this._formData) {\\n\\t    console.error(\\\".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()\\\");\\n\\t  }\\n\\t\\n\\t  if (isObj && !this._data) {\\n\\t    if (Array.isArray(data)) {\\n\\t      this._data = [];\\n\\t    } else if (!this._isHost(data)) {\\n\\t      this._data = {};\\n\\t    }\\n\\t  } else if (data && this._data && this._isHost(this._data)) {\\n\\t    throw Error(\\\"Can't merge these send calls\\\");\\n\\t  }\\n\\t\\n\\t  // merge\\n\\t  if (isObj && isObject(this._data)) {\\n\\t    for (var key in data) {\\n\\t      this._data[key] = data[key];\\n\\t    }\\n\\t  } else if ('string' == typeof data) {\\n\\t    // default to x-www-form-urlencoded\\n\\t    if (!type) this.type('form');\\n\\t    type = this._header['content-type'];\\n\\t    if ('application/x-www-form-urlencoded' == type) {\\n\\t      this._data = this._data\\n\\t        ? this._data + '&' + data\\n\\t        : data;\\n\\t    } else {\\n\\t      this._data = (this._data || '') + data;\\n\\t    }\\n\\t  } else {\\n\\t    this._data = data;\\n\\t  }\\n\\t\\n\\t  if (!isObj || this._isHost(data)) {\\n\\t    return this;\\n\\t  }\\n\\t\\n\\t  // default to json\\n\\t  if (!type) this.type('json');\\n\\t  return this;\\n\\t};\\n\\t\\n\\t\\n\\t/**\\n\\t * Sort `querystring` by the sort function\\n\\t *\\n\\t *\\n\\t * Examples:\\n\\t *\\n\\t *       // default order\\n\\t *       request.get('/user')\\n\\t *         .query('name=Nick')\\n\\t *         .query('search=Manny')\\n\\t *         .sortQuery()\\n\\t *         .end(callback)\\n\\t *\\n\\t *       // customized sort function\\n\\t *       request.get('/user')\\n\\t *         .query('name=Nick')\\n\\t *         .query('search=Manny')\\n\\t *         .sortQuery(function(a, b){\\n\\t *           return a.length - b.length;\\n\\t *         })\\n\\t *         .end(callback)\\n\\t *\\n\\t *\\n\\t * @param {Function} sort\\n\\t * @return {Request} for chaining\\n\\t * @api public\\n\\t */\\n\\t\\n\\tRequestBase.prototype.sortQuery = function(sort) {\\n\\t  // _sort default to true but otherwise can be a function or boolean\\n\\t  this._sort = typeof sort === 'undefined' ? true : sort;\\n\\t  return this;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Invoke callback with timeout error.\\n\\t *\\n\\t * @api private\\n\\t */\\n\\t\\n\\tRequestBase.prototype._timeoutError = function(reason, timeout, errno){\\n\\t  if (this._aborted) {\\n\\t    return;\\n\\t  }\\n\\t  var err = new Error(reason + timeout + 'ms exceeded');\\n\\t  err.timeout = timeout;\\n\\t  err.code = 'ECONNABORTED';\\n\\t  err.errno = errno;\\n\\t  this.timedout = true;\\n\\t  this.abort();\\n\\t  this.callback(err);\\n\\t};\\n\\t\\n\\tRequestBase.prototype._setTimeouts = function() {\\n\\t  var self = this;\\n\\t\\n\\t  // deadline\\n\\t  if (this._timeout && !this._timer) {\\n\\t    this._timer = setTimeout(function(){\\n\\t      self._timeoutError('Timeout of ', self._timeout, 'ETIME');\\n\\t    }, this._timeout);\\n\\t  }\\n\\t  // response timeout\\n\\t  if (this._responseTimeout && !this._responseTimeoutTimer) {\\n\\t    this._responseTimeoutTimer = setTimeout(function(){\\n\\t      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');\\n\\t    }, this._responseTimeout);\\n\\t  }\\n\\t}\\n\\n\\n/***/ },\\n/* 34 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\t\\n\\t/**\\n\\t * Module dependencies.\\n\\t */\\n\\t\\n\\tvar utils = __webpack_require__(36);\\n\\t\\n\\t/**\\n\\t * Expose `ResponseBase`.\\n\\t */\\n\\t\\n\\tmodule.exports = ResponseBase;\\n\\t\\n\\t/**\\n\\t * Initialize a new `ResponseBase`.\\n\\t *\\n\\t * @api public\\n\\t */\\n\\t\\n\\tfunction ResponseBase(obj) {\\n\\t  if (obj) return mixin(obj);\\n\\t}\\n\\t\\n\\t/**\\n\\t * Mixin the prototype properties.\\n\\t *\\n\\t * @param {Object} obj\\n\\t * @return {Object}\\n\\t * @api private\\n\\t */\\n\\t\\n\\tfunction mixin(obj) {\\n\\t  for (var key in ResponseBase.prototype) {\\n\\t    obj[key] = ResponseBase.prototype[key];\\n\\t  }\\n\\t  return obj;\\n\\t}\\n\\t\\n\\t/**\\n\\t * Get case-insensitive `field` value.\\n\\t *\\n\\t * @param {String} field\\n\\t * @return {String}\\n\\t * @api public\\n\\t */\\n\\t\\n\\tResponseBase.prototype.get = function(field){\\n\\t    return this.header[field.toLowerCase()];\\n\\t};\\n\\t\\n\\t/**\\n\\t * Set header related properties:\\n\\t *\\n\\t *   - `.type` the content type without params\\n\\t *\\n\\t * A response of \\\"Content-Type: text/plain; charset=utf-8\\\"\\n\\t * will provide you with a `.type` of \\\"text/plain\\\".\\n\\t *\\n\\t * @param {Object} header\\n\\t * @api private\\n\\t */\\n\\t\\n\\tResponseBase.prototype._setHeaderProperties = function(header){\\n\\t    // TODO: moar!\\n\\t    // TODO: make this a util\\n\\t\\n\\t    // content-type\\n\\t    var ct = header['content-type'] || '';\\n\\t    this.type = utils.type(ct);\\n\\t\\n\\t    // params\\n\\t    var params = utils.params(ct);\\n\\t    for (var key in params) this[key] = params[key];\\n\\t\\n\\t    this.links = {};\\n\\t\\n\\t    // links\\n\\t    try {\\n\\t        if (header.link) {\\n\\t            this.links = utils.parseLinks(header.link);\\n\\t        }\\n\\t    } catch (err) {\\n\\t        // ignore\\n\\t    }\\n\\t};\\n\\t\\n\\t/**\\n\\t * Set flags such as `.ok` based on `status`.\\n\\t *\\n\\t * For example a 2xx response will give you a `.ok` of __true__\\n\\t * whereas 5xx will be __false__ and `.error` will be __true__. The\\n\\t * `.clientError` and `.serverError` are also available to be more\\n\\t * specific, and `.statusType` is the class of error ranging from 1..5\\n\\t * sometimes useful for mapping respond colors etc.\\n\\t *\\n\\t * \\\"sugar\\\" properties are also defined for common cases. Currently providing:\\n\\t *\\n\\t *   - .noContent\\n\\t *   - .badRequest\\n\\t *   - .unauthorized\\n\\t *   - .notAcceptable\\n\\t *   - .notFound\\n\\t *\\n\\t * @param {Number} status\\n\\t * @api private\\n\\t */\\n\\t\\n\\tResponseBase.prototype._setStatusProperties = function(status){\\n\\t    var type = status / 100 | 0;\\n\\t\\n\\t    // status / class\\n\\t    this.status = this.statusCode = status;\\n\\t    this.statusType = type;\\n\\t\\n\\t    // basics\\n\\t    this.info = 1 == type;\\n\\t    this.ok = 2 == type;\\n\\t    this.redirect = 3 == type;\\n\\t    this.clientError = 4 == type;\\n\\t    this.serverError = 5 == type;\\n\\t    this.error = (4 == type || 5 == type)\\n\\t        ? this.toError()\\n\\t        : false;\\n\\t\\n\\t    // sugar\\n\\t    this.accepted = 202 == status;\\n\\t    this.noContent = 204 == status;\\n\\t    this.badRequest = 400 == status;\\n\\t    this.unauthorized = 401 == status;\\n\\t    this.notAcceptable = 406 == status;\\n\\t    this.forbidden = 403 == status;\\n\\t    this.notFound = 404 == status;\\n\\t};\\n\\n\\n/***/ },\\n/* 35 */\\n/***/ function(module, exports) {\\n\\n\\tvar ERROR_CODES = [\\n\\t  'ECONNRESET',\\n\\t  'ETIMEDOUT',\\n\\t  'EADDRINFO',\\n\\t  'ESOCKETTIMEDOUT'\\n\\t];\\n\\t\\n\\t/**\\n\\t * Determine if a request should be retried.\\n\\t * (Borrowed from segmentio/superagent-retry)\\n\\t *\\n\\t * @param {Error} err\\n\\t * @param {Response} [res]\\n\\t * @returns {Boolean}\\n\\t */\\n\\tmodule.exports = function shouldRetry(err, res) {\\n\\t  if (err && err.code && ~ERROR_CODES.indexOf(err.code)) return true;\\n\\t  if (res && res.status && res.status >= 500) return true;\\n\\t  // Superagent timeout\\n\\t  if (err && 'timeout' in err && err.code == 'ECONNABORTED') return true;\\n\\t  return false;\\n\\t};\\n\\n/***/ },\\n/* 36 */\\n/***/ function(module, exports) {\\n\\n\\t\\n\\t/**\\n\\t * Return the mime type for the given `str`.\\n\\t *\\n\\t * @param {String} str\\n\\t * @return {String}\\n\\t * @api private\\n\\t */\\n\\t\\n\\texports.type = function(str){\\n\\t  return str.split(/ *; */).shift();\\n\\t};\\n\\t\\n\\t/**\\n\\t * Return header field parameters.\\n\\t *\\n\\t * @param {String} str\\n\\t * @return {Object}\\n\\t * @api private\\n\\t */\\n\\t\\n\\texports.params = function(str){\\n\\t  return str.split(/ *; */).reduce(function(obj, str){\\n\\t    var parts = str.split(/ *= */);\\n\\t    var key = parts.shift();\\n\\t    var val = parts.shift();\\n\\t\\n\\t    if (key && val) obj[key] = val;\\n\\t    return obj;\\n\\t  }, {});\\n\\t};\\n\\t\\n\\t/**\\n\\t * Parse Link header fields.\\n\\t *\\n\\t * @param {String} str\\n\\t * @return {Object}\\n\\t * @api private\\n\\t */\\n\\t\\n\\texports.parseLinks = function(str){\\n\\t  return str.split(/ *, */).reduce(function(obj, str){\\n\\t    var parts = str.split(/ *; */);\\n\\t    var url = parts[0].slice(1, -1);\\n\\t    var rel = parts[1].split(/ *= */)[1].slice(1, -1);\\n\\t    obj[rel] = url;\\n\\t    return obj;\\n\\t  }, {});\\n\\t};\\n\\t\\n\\t/**\\n\\t * Strip content related fields from `header`.\\n\\t *\\n\\t * @param {Object} header\\n\\t * @return {Object} header\\n\\t * @api private\\n\\t */\\n\\t\\n\\texports.cleanHeader = function(header, shouldStripCookie){\\n\\t  delete header['content-type'];\\n\\t  delete header['content-length'];\\n\\t  delete header['transfer-encoding'];\\n\\t  delete header['host'];\\n\\t  if (shouldStripCookie) {\\n\\t    delete header['cookie'];\\n\\t  }\\n\\t  return header;\\n\\t};\\n\\n/***/ },\\n/* 37 */,\\n/* 38 */,\\n/* 39 */,\\n/* 40 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar urljoin = __webpack_require__(1);\\n\\t\\n\\tvar objectHelper = __webpack_require__(2);\\n\\tvar assert = __webpack_require__(4);\\n\\tvar responseHandler = __webpack_require__(6);\\n\\t\\n\\tfunction DBConnection(request, options) {\\n\\t  this.baseOptions = options;\\n\\t  this.request = request;\\n\\t}\\n\\t\\n\\t/**\\n\\t * @callback signUpCallback\\n\\t * @param {Error} [err] error returned by Auth0 with the reason why the signup failed\\n\\t * @param {Object} [result] result of the signup request\\n\\t * @param {Object} result.email user's email\\n\\t * @param {Object} result.emailVerified if the user's email was verified\\n\\t */\\n\\t\\n\\t/**\\n\\t * Creates a new user in a Auth0 Database connection\\n\\t *\\n\\t * @method signup\\n\\t * @param {Object} options\\n\\t * @param {String} options.email user email address\\n\\t * @param {String} options.password user password\\n\\t * @param {String} options.connection name of the connection where the user will be created\\n\\t * @param {Object} [options.userMetadata] additional signup attributes used for creating the user. Will be stored in `user_metadata`\\n\\t * @param {signUpCallback} cb\\n\\t * @see   {@link https://auth0.com/docs/api/authentication#signup}\\n\\t */\\n\\tDBConnection.prototype.signup = function(options, cb) {\\n\\t  var url;\\n\\t  var body;\\n\\t  var metadata;\\n\\t\\n\\t  assert.check(\\n\\t    options,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      connection: { type: 'string', message: 'connection option is required' },\\n\\t      email: { type: 'string', message: 'email option is required' },\\n\\t      password: { type: 'string', message: 'password option is required' }\\n\\t    }\\n\\t  );\\n\\t  assert.check(cb, { type: 'function', message: 'cb parameter is not valid' });\\n\\t\\n\\t  url = urljoin(this.baseOptions.rootUrl, 'dbconnections', 'signup');\\n\\t\\n\\t  body = objectHelper.merge(this.baseOptions, ['clientID']).with(options);\\n\\t\\n\\t  metadata = body.user_metadata || body.userMetadata;\\n\\t\\n\\t  body = objectHelper.blacklist(body, ['scope', 'userMetadata', 'user_metadata']);\\n\\t\\n\\t  body = objectHelper.toSnakeCase(body, ['auth0Client']);\\n\\t\\n\\t  if (metadata) {\\n\\t    body.user_metadata = metadata;\\n\\t  }\\n\\t\\n\\t  return this.request.post(url).send(body).end(responseHandler(cb));\\n\\t};\\n\\t\\n\\t/**\\n\\t * @callback changePasswordCallback\\n\\t * @param {Error} [err] error returned by Auth0 with the reason why the request failed\\n\\t */\\n\\t\\n\\t/**\\n\\t * Request an email with instruction to change a user's password\\n\\t *\\n\\t * @method changePassword\\n\\t * @param {Object} options\\n\\t * @param {String} options.email address where the user will recieve the change password email. It should match the user's email in Auth0\\n\\t * @param {String} options.connection name of the connection where the user was created\\n\\t * @param {changePasswordCallback} cb\\n\\t * @see   {@link https://auth0.com/docs/api/authentication#change-password}\\n\\t */\\n\\tDBConnection.prototype.changePassword = function(options, cb) {\\n\\t  var url;\\n\\t  var body;\\n\\t\\n\\t  assert.check(\\n\\t    options,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      connection: { type: 'string', message: 'connection option is required' },\\n\\t      email: { type: 'string', message: 'email option is required' }\\n\\t    }\\n\\t  );\\n\\t  assert.check(cb, { type: 'function', message: 'cb parameter is not valid' });\\n\\t\\n\\t  url = urljoin(this.baseOptions.rootUrl, 'dbconnections', 'change_password');\\n\\t\\n\\t  body = objectHelper.merge(this.baseOptions, ['clientID']).with(options, ['email', 'connection']);\\n\\t\\n\\t  body = objectHelper.toSnakeCase(body, ['auth0Client']);\\n\\t\\n\\t  return this.request.post(url).send(body).end(responseHandler(cb));\\n\\t};\\n\\t\\n\\tmodule.exports = DBConnection;\\n\\n\\n/***/ },\\n/* 41 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar urljoin = __webpack_require__(1);\\n\\t\\n\\tvar objectHelper = __webpack_require__(2);\\n\\tvar assert = __webpack_require__(4);\\n\\tvar qs = __webpack_require__(5);\\n\\tvar responseHandler = __webpack_require__(6);\\n\\t\\n\\tfunction PasswordlessAuthentication(request, options) {\\n\\t  this.baseOptions = options;\\n\\t  this.request = request;\\n\\t}\\n\\t\\n\\tPasswordlessAuthentication.prototype.buildVerifyUrl = function(options) {\\n\\t  var params;\\n\\t  var qString;\\n\\t\\n\\t  /* eslint-disable */\\n\\t  assert.check(\\n\\t    options,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      connection: { type: 'string', message: 'connection option is required' },\\n\\t      verificationCode: { type: 'string', message: 'verificationCode option is required' },\\n\\t      phoneNumber: {\\n\\t        optional: false,\\n\\t        type: 'string',\\n\\t        message: 'phoneNumber option is required',\\n\\t        condition: function(o) {\\n\\t          return !o.email;\\n\\t        }\\n\\t      },\\n\\t      email: {\\n\\t        optional: false,\\n\\t        type: 'string',\\n\\t        message: 'email option is required',\\n\\t        condition: function(o) {\\n\\t          return !o.phoneNumber;\\n\\t        }\\n\\t      }\\n\\t    }\\n\\t  );\\n\\t  /* eslint-enable */\\n\\t\\n\\t  params = objectHelper\\n\\t    .merge(this.baseOptions, [\\n\\t      'clientID',\\n\\t      'responseType',\\n\\t      'responseMode',\\n\\t      'redirectUri',\\n\\t      'scope',\\n\\t      'audience',\\n\\t      '_csrf',\\n\\t      'state',\\n\\t      '_intstate',\\n\\t      'protocol',\\n\\t      'nonce'\\n\\t    ])\\n\\t    .with(options);\\n\\t\\n\\t  // eslint-disable-next-line\\n\\t  if (this.baseOptions._sendTelemetry) {\\n\\t    params.auth0Client = this.request.getTelemetryData();\\n\\t  }\\n\\t\\n\\t  params = objectHelper.toSnakeCase(params, ['auth0Client']);\\n\\t\\n\\t  qString = qs.stringify(params);\\n\\t\\n\\t  return urljoin(this.baseOptions.rootUrl, 'passwordless', 'verify_redirect', '?' + qString);\\n\\t};\\n\\t\\n\\tPasswordlessAuthentication.prototype.start = function(options, cb) {\\n\\t  var url;\\n\\t  var body;\\n\\t\\n\\t  /* eslint-disable */\\n\\t  assert.check(\\n\\t    options,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      connection: { type: 'string', message: 'connection option is required' },\\n\\t      send: {\\n\\t        type: 'string',\\n\\t        message: 'send option is required',\\n\\t        values: ['link', 'code'],\\n\\t        value_message: 'send is not valid ([link, code])'\\n\\t      },\\n\\t      phoneNumber: {\\n\\t        optional: true,\\n\\t        type: 'string',\\n\\t        message: 'phoneNumber option is required',\\n\\t        condition: function(o) {\\n\\t          return o.send === 'code' || !o.email;\\n\\t        }\\n\\t      },\\n\\t      email: {\\n\\t        optional: true,\\n\\t        type: 'string',\\n\\t        message: 'email option is required',\\n\\t        condition: function(o) {\\n\\t          return o.send === 'link' || !o.phoneNumber;\\n\\t        }\\n\\t      },\\n\\t      authParams: { optional: true, type: 'object', message: 'authParams option is required' }\\n\\t    }\\n\\t  );\\n\\t  /* eslint-enable */\\n\\t\\n\\t  assert.check(cb, { type: 'function', message: 'cb parameter is not valid' });\\n\\t\\n\\t  url = urljoin(this.baseOptions.rootUrl, 'passwordless', 'start');\\n\\t\\n\\t  body = objectHelper\\n\\t    .merge(this.baseOptions, ['clientID', 'responseType', 'redirectUri', 'scope'])\\n\\t    .with(options);\\n\\t\\n\\t  if (body.scope) {\\n\\t    body.authParams = body.authParams || {};\\n\\t    body.authParams.scope = body.scope;\\n\\t  }\\n\\t\\n\\t  if (body.redirectUri) {\\n\\t    body.authParams = body.authParams || {};\\n\\t    body.authParams.redirect_uri = body.redirectUri;\\n\\t  }\\n\\t\\n\\t  if (body.responseType) {\\n\\t    body.authParams = body.authParams || {};\\n\\t    body.authParams.response_type = body.responseType;\\n\\t  }\\n\\t\\n\\t  delete body.redirectUri;\\n\\t  delete body.responseType;\\n\\t  delete body.scope;\\n\\t\\n\\t  body = objectHelper.toSnakeCase(body, ['auth0Client', 'authParams']);\\n\\t\\n\\t  return this.request.post(url).send(body).end(responseHandler(cb));\\n\\t};\\n\\t\\n\\tPasswordlessAuthentication.prototype.verify = function(options, cb) {\\n\\t  var url;\\n\\t  var cleanOption;\\n\\t\\n\\t  /* eslint-disable */\\n\\t  assert.check(\\n\\t    options,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      connection: { type: 'string', message: 'connection option is required' },\\n\\t      verificationCode: { type: 'string', message: 'verificationCode option is required' },\\n\\t      phoneNumber: {\\n\\t        optional: false,\\n\\t        type: 'string',\\n\\t        message: 'phoneNumber option is required',\\n\\t        condition: function(o) {\\n\\t          return !o.email;\\n\\t        }\\n\\t      },\\n\\t      email: {\\n\\t        optional: false,\\n\\t        type: 'string',\\n\\t        message: 'email option is required',\\n\\t        condition: function(o) {\\n\\t          return !o.phoneNumber;\\n\\t        }\\n\\t      }\\n\\t    }\\n\\t  );\\n\\t  /* eslint-enable */\\n\\t\\n\\t  assert.check(cb, { type: 'function', message: 'cb parameter is not valid' });\\n\\t\\n\\t  cleanOption = objectHelper.pick(options, [\\n\\t    'connection',\\n\\t    'verificationCode',\\n\\t    'phoneNumber',\\n\\t    'email',\\n\\t    'auth0Client'\\n\\t  ]);\\n\\t  cleanOption = objectHelper.toSnakeCase(cleanOption, ['auth0Client']);\\n\\t\\n\\t  url = urljoin(this.baseOptions.rootUrl, 'passwordless', 'verify');\\n\\t\\n\\t  return this.request.post(url).send(cleanOption).end(responseHandler(cb));\\n\\t};\\n\\t\\n\\tmodule.exports = PasswordlessAuthentication;\\n\\n\\n/***/ },\\n/* 42 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar windowHandler = __webpack_require__(3);\\n\\tvar base64Url = __webpack_require__(20);\\n\\t\\n\\tfunction create(name, value, days) {\\n\\t  var date;\\n\\t  var expires;\\n\\t\\n\\t  if (\\n\\t    windowHandler.getDocument().cookie === undefined ||\\n\\t    windowHandler.getDocument().cookie === null\\n\\t  ) {\\n\\t    throw new Error('cookie storage not available');\\n\\t  }\\n\\t\\n\\t  if (days) {\\n\\t    var timeToExpire = days * 24 * 60 * 60 * 1000;\\n\\t    date = new Date();\\n\\t    date.setTime(date.getTime() + timeToExpire);\\n\\t    expires = '; expires=' + date.toGMTString();\\n\\t  } else {\\n\\t    expires = '';\\n\\t  }\\n\\t\\n\\t  windowHandler.getDocument().cookie = name + '=' + base64Url.encode(value) + expires + '; path=/';\\n\\t}\\n\\t\\n\\tfunction read(name) {\\n\\t  var i;\\n\\t  var cookie;\\n\\t  var cookies;\\n\\t  var nameEQ = name + '=';\\n\\t\\n\\t  if (\\n\\t    windowHandler.getDocument().cookie === undefined ||\\n\\t    windowHandler.getDocument().cookie === null\\n\\t  ) {\\n\\t    throw new Error('cookie storage not available');\\n\\t  }\\n\\t\\n\\t  cookies = windowHandler.getDocument().cookie.split(';');\\n\\t\\n\\t  for (i = 0; i < cookies.length; i++) {\\n\\t    cookie = cookies[i];\\n\\t    while (cookie.charAt(0) === ' ') {\\n\\t      cookie = cookie.substring(1, cookie.length);\\n\\t    }\\n\\t    if (cookie.indexOf(nameEQ) === 0) {\\n\\t      return base64Url.decode(cookie.substring(nameEQ.length, cookie.length));\\n\\t    }\\n\\t  }\\n\\t\\n\\t  return null;\\n\\t}\\n\\t\\n\\tfunction erase(name) {\\n\\t  create(name, '', -1);\\n\\t}\\n\\t\\n\\tmodule.exports = {\\n\\t  create: create,\\n\\t  read: read,\\n\\t  erase: erase\\n\\t};\\n\\n\\n/***/ },\\n/* 43 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar windowHelper = __webpack_require__(3);\\n\\t\\n\\tfunction IframeHandler(options) {\\n\\t  this.url = options.url;\\n\\t  this.callback = options.callback;\\n\\t  this.timeout = options.timeout || 60 * 1000;\\n\\t  this.timeoutCallback = options.timeoutCallback || null;\\n\\t  this.eventListenerType = options.eventListenerType || 'message';\\n\\t  this.iframe = null;\\n\\t  this.timeoutHandle = null;\\n\\t  this._destroyTimeout = null;\\n\\t  this.transientMessageEventListener = null;\\n\\t  this.proxyEventListener = null;\\n\\t  // If no event identifier specified, set default\\n\\t  this.eventValidator = options.eventValidator || {\\n\\t    isValid: function() {\\n\\t      return true;\\n\\t    }\\n\\t  };\\n\\t\\n\\t  if (typeof this.callback !== 'function') {\\n\\t    throw new Error('options.callback must be a function');\\n\\t  }\\n\\t}\\n\\t\\n\\tIframeHandler.prototype.init = function() {\\n\\t  var _this = this;\\n\\t  var _window = windowHelper.getWindow();\\n\\t\\n\\t  this.iframe = _window.document.createElement('iframe');\\n\\t  this.iframe.style.display = 'none';\\n\\t  this.iframe.src = this.url;\\n\\t\\n\\t  // Workaround to avoid using bind that does not work in IE8\\n\\t  this.proxyEventListener = function(e) {\\n\\t    _this.eventListener(e);\\n\\t  };\\n\\t\\n\\t  switch (this.eventListenerType) {\\n\\t    case 'message':\\n\\t      this.eventSourceObject = _window;\\n\\t      break;\\n\\t    case 'load':\\n\\t      this.eventSourceObject = this.iframe;\\n\\t      break;\\n\\t    default:\\n\\t      throw new Error('Unsupported event listener type: ' + this.eventListenerType);\\n\\t  }\\n\\t\\n\\t  this.eventSourceObject.addEventListener(this.eventListenerType, this.proxyEventListener, false);\\n\\t\\n\\t  _window.document.body.appendChild(this.iframe);\\n\\t\\n\\t  this.timeoutHandle = setTimeout(function() {\\n\\t    _this.timeoutHandler();\\n\\t  }, this.timeout);\\n\\t};\\n\\t\\n\\tIframeHandler.prototype.eventListener = function(event) {\\n\\t  var eventData = { event: event, sourceObject: this.eventSourceObject };\\n\\t\\n\\t  if (!this.eventValidator.isValid(eventData)) {\\n\\t    return;\\n\\t  }\\n\\t\\n\\t  this.destroy();\\n\\t  this.callback(eventData);\\n\\t};\\n\\t\\n\\tIframeHandler.prototype.timeoutHandler = function() {\\n\\t  this.destroy();\\n\\t  if (this.timeoutCallback) {\\n\\t    this.timeoutCallback();\\n\\t  }\\n\\t};\\n\\t\\n\\tIframeHandler.prototype.destroy = function() {\\n\\t  var _this = this;\\n\\t  var _window = windowHelper.getWindow();\\n\\t\\n\\t  clearTimeout(this.timeoutHandle);\\n\\t\\n\\t  this._destroyTimeout = setTimeout(function() {\\n\\t    _this.eventSourceObject.removeEventListener(\\n\\t      _this.eventListenerType,\\n\\t      _this.proxyEventListener,\\n\\t      false\\n\\t    );\\n\\t    _window.document.body.removeChild(_this.iframe);\\n\\t  }, 0);\\n\\t};\\n\\t\\n\\tmodule.exports = IframeHandler;\\n\\n\\n/***/ },\\n/* 44 */\\n/***/ function(module, exports) {\\n\\n\\t/* eslint-disable no-continue */\\n\\t\\n\\tfunction get() {\\n\\t  if (!Object.assign) {\\n\\t    return objectAssignPolyfill;\\n\\t  }\\n\\t\\n\\t  return Object.assign;\\n\\t}\\n\\t\\n\\tfunction objectAssignPolyfill(target) {\\n\\t  'use strict';\\n\\t  if (target === undefined || target === null) {\\n\\t    throw new TypeError('Cannot convert first argument to object');\\n\\t  }\\n\\t\\n\\t  var to = Object(target);\\n\\t  for (var i = 1; i < arguments.length; i++) {\\n\\t    var nextSource = arguments[i];\\n\\t    if (nextSource === undefined || nextSource === null) {\\n\\t      continue;\\n\\t    }\\n\\t\\n\\t    var keysArray = Object.keys(Object(nextSource));\\n\\t    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\\n\\t      var nextKey = keysArray[nextIndex];\\n\\t      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\\n\\t      if (desc !== undefined && desc.enumerable) {\\n\\t        to[nextKey] = nextSource[nextKey];\\n\\t      }\\n\\t    }\\n\\t  }\\n\\t  return to;\\n\\t}\\n\\t\\n\\tmodule.exports = {\\n\\t  get: get,\\n\\t  objectAssignPolyfill: objectAssignPolyfill\\n\\t};\\n\\n\\n/***/ },\\n/* 45 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar objectHelper = __webpack_require__(2);\\n\\t\\n\\tvar tokenParams = [\\n\\t  // auth0\\n\\t  'realm',\\n\\t  'audience',\\n\\t  // oauth2\\n\\t  'client_id',\\n\\t  'client_secret',\\n\\t  'redirect_uri',\\n\\t  'scope',\\n\\t  'code',\\n\\t  'grant_type',\\n\\t  'username',\\n\\t  'password',\\n\\t  'refresh_token',\\n\\t  'assertion',\\n\\t  'client_assertion',\\n\\t  'client_assertion_type',\\n\\t  'code_verifier'\\n\\t];\\n\\t\\n\\tvar authorizeParams = [\\n\\t  // auth0\\n\\t  'connection',\\n\\t  'connection_scope',\\n\\t  'auth0Client',\\n\\t  'owp',\\n\\t  'device',\\n\\t\\n\\t  'protocol',\\n\\t  '_csrf',\\n\\t  '_intstate',\\n\\t  'login_ticket',\\n\\t\\n\\t  // oauth2\\n\\t  'client_id',\\n\\t  'response_type',\\n\\t  'response_mode',\\n\\t  'redirect_uri',\\n\\t  'audience',\\n\\t  'scope',\\n\\t  'state',\\n\\t  'nonce',\\n\\t  'display',\\n\\t  'prompt',\\n\\t  'max_age',\\n\\t  'ui_locales',\\n\\t  'claims_locales',\\n\\t  'id_token_hint',\\n\\t  'login_hint',\\n\\t  'acr_values',\\n\\t  'claims',\\n\\t  'registration',\\n\\t  'request',\\n\\t  'request_uri',\\n\\t  'code_challenge',\\n\\t  'code_challenge_method'\\n\\t];\\n\\t\\n\\tfunction oauthAuthorizeParams(warn, params) {\\n\\t  var notAllowed = objectHelper.getKeysNotIn(params, authorizeParams);\\n\\t\\n\\t  if (notAllowed.length > 0) {\\n\\t    warn.warning(\\n\\t      'Following parameters are not allowed on the `/authorize` endpoint: [' +\\n\\t        notAllowed.join(',') +\\n\\t        ']'\\n\\t    );\\n\\t  }\\n\\t\\n\\t  return params;\\n\\t}\\n\\t\\n\\tfunction oauthTokenParams(warn, params) {\\n\\t  return objectHelper.pick(params, tokenParams);\\n\\t}\\n\\t\\n\\tmodule.exports = {\\n\\t  oauthTokenParams: oauthTokenParams,\\n\\t  oauthAuthorizeParams: oauthAuthorizeParams\\n\\t};\\n\\n\\n/***/ },\\n/* 46 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar version = __webpack_require__(9);\\n\\t\\n\\tfunction PluginHandler(webAuth, plugins) {\\n\\t  this.plugins = plugins;\\n\\t\\n\\t  for (var a = 0; a < this.plugins.length; a++) {\\n\\t    if (this.plugins[a].version !== version.raw) {\\n\\t      var pluginName = '';\\n\\t\\n\\t      if (this.plugins[a].constructor && this.plugins[a].constructor.name) {\\n\\t        pluginName = this.plugins[a].constructor.name;\\n\\t      }\\n\\t\\n\\t      throw new Error(\\n\\t        'Plugin ' +\\n\\t          pluginName +\\n\\t          ' version (' +\\n\\t          this.plugins[a].version +\\n\\t          ') ' +\\n\\t          'is not compatible with the SDK version (' +\\n\\t          version.raw +\\n\\t          ')'\\n\\t      );\\n\\t    }\\n\\t\\n\\t    this.plugins[a].setWebAuth(webAuth);\\n\\t  }\\n\\t}\\n\\t\\n\\tPluginHandler.prototype.get = function(extensibilityPoint) {\\n\\t  for (var a = 0; a < this.plugins.length; a++) {\\n\\t    if (this.plugins[a].supports(extensibilityPoint)) {\\n\\t      return this.plugins[a].init();\\n\\t    }\\n\\t  }\\n\\t\\n\\t  return null;\\n\\t};\\n\\t\\n\\tmodule.exports = PluginHandler;\\n\\n\\n/***/ },\\n/* 47 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\t/* eslint-disable no-restricted-syntax */\\n\\t/* eslint-disable guard-for-in */\\n\\tvar WinChan = __webpack_require__(18);\\n\\t\\n\\tvar windowHandler = __webpack_require__(3);\\n\\tvar objectHelper = __webpack_require__(2);\\n\\tvar qs = __webpack_require__(5);\\n\\t\\n\\tfunction PopupHandler() {\\n\\t  this._current_popup = null;\\n\\t}\\n\\t\\n\\tPopupHandler.prototype.calculatePosition = function(options) {\\n\\t  var width = options.width || 500;\\n\\t  var height = options.height || 600;\\n\\t  var _window = windowHandler.getWindow();\\n\\t\\n\\t  var screenX = typeof _window.screenX !== 'undefined' ? _window.screenX : _window.screenLeft;\\n\\t  var screenY = typeof _window.screenY !== 'undefined' ? _window.screenY : _window.screenTop;\\n\\t\\n\\t  var outerWidth = typeof _window.outerWidth !== 'undefined'\\n\\t    ? _window.outerWidth\\n\\t    : _window.document.body.clientWidth;\\n\\t\\n\\t  var outerHeight = typeof _window.outerHeight !== 'undefined'\\n\\t    ? _window.outerHeight\\n\\t    : _window.document.body.clientHeight;\\n\\t\\n\\t  var left = (outerWidth - width) / 2;\\n\\t  var top = (outerHeight - height) / 2;\\n\\t\\n\\t  return { width: width, height: height, left: screenX + left, top: screenY + top };\\n\\t};\\n\\t\\n\\tPopupHandler.prototype.preload = function(options) {\\n\\t  var _this = this;\\n\\t  var _window = windowHandler.getWindow();\\n\\t  var popupPosition = this.calculatePosition(options.popupOptions || {});\\n\\t  var popupOptions = objectHelper.merge(popupPosition).with(options.popupOptions);\\n\\t  var url = options.url || 'about:blank';\\n\\t  var windowFeatures = qs.stringify(popupOptions, {\\n\\t    encode: false,\\n\\t    delimiter: ','\\n\\t  });\\n\\t\\n\\t  if (this._current_popup && !this._current_popup.closed) {\\n\\t    return this._current_popup;\\n\\t  }\\n\\t\\n\\t  this._current_popup = _window.open(url, 'auth0_signup_popup', windowFeatures);\\n\\t\\n\\t  this._current_popup.kill = function() {\\n\\t    this.close();\\n\\t    _this._current_popup = null;\\n\\t  };\\n\\t\\n\\t  return this._current_popup;\\n\\t};\\n\\t\\n\\tPopupHandler.prototype.load = function(url, relayUrl, options, cb) {\\n\\t  var _this = this;\\n\\t  var popupPosition = this.calculatePosition(options.popupOptions || {});\\n\\t  var popupOptions = objectHelper.merge(popupPosition).with(options.popupOptions);\\n\\t\\n\\t  var winchanOptions = objectHelper\\n\\t    .merge({\\n\\t      url: url,\\n\\t      relay_url: relayUrl,\\n\\t      window_features: qs.stringify(popupOptions, {\\n\\t        delimiter: ',',\\n\\t        encode: false\\n\\t      }),\\n\\t      popup: this._current_popup\\n\\t    })\\n\\t    .with(options);\\n\\t\\n\\t  var popup = WinChan.open(winchanOptions, function(err, data) {\\n\\t    _this._current_popup = null;\\n\\t    return cb(err, data);\\n\\t  });\\n\\t\\n\\t  popup.focus();\\n\\t\\n\\t  return popup;\\n\\t};\\n\\t\\n\\tmodule.exports = PopupHandler;\\n\\n\\n/***/ },\\n/* 48 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar windowHelper = __webpack_require__(3);\\n\\t\\n\\tfunction randomString(length) {\\n\\t  // eslint-disable-next-line\\n\\t  var bytes = new Uint8Array(length);\\n\\t  var result = [];\\n\\t  var charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._~';\\n\\t\\n\\t  var cryptoObj = windowHelper.getWindow().crypto || windowHelper.getWindow().msCrypto;\\n\\t  if (!cryptoObj) {\\n\\t    return null;\\n\\t  }\\n\\t\\n\\t  var random = cryptoObj.getRandomValues(bytes);\\n\\t\\n\\t  for (var a = 0; a < random.length; a++) {\\n\\t    result.push(charset[random[a] % charset.length]);\\n\\t  }\\n\\t\\n\\t  return result.join('');\\n\\t}\\n\\t\\n\\tmodule.exports = {\\n\\t  randomString: randomString\\n\\t};\\n\\n\\n/***/ },\\n/* 49 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar StorageHandler = __webpack_require__(52);\\n\\tvar storage;\\n\\t\\n\\tfunction getStorage(force) {\\n\\t  if (!storage || force) {\\n\\t    storage = new StorageHandler();\\n\\t  }\\n\\t  return storage;\\n\\t}\\n\\t\\n\\tmodule.exports = {\\n\\t  getItem: function(key) {\\n\\t    var value = getStorage().getItem(key);\\n\\t    return value ? JSON.parse(value) : value;\\n\\t  },\\n\\t  removeItem: function(key) {\\n\\t    return getStorage().removeItem(key);\\n\\t  },\\n\\t  setItem: function(key, value) {\\n\\t    var json = JSON.stringify(value);\\n\\t    return getStorage().setItem(key, json);\\n\\t  },\\n\\t  reload: function() {\\n\\t    getStorage(true);\\n\\t  }\\n\\t};\\n\\n\\n/***/ },\\n/* 50 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar cookies = __webpack_require__(42);\\n\\t\\n\\tfunction CookieStorage() {}\\n\\t\\n\\tCookieStorage.prototype.getItem = function(key) {\\n\\t  return cookies.read(key);\\n\\t};\\n\\t\\n\\tCookieStorage.prototype.removeItem = function(key) {\\n\\t  cookies.erase(key);\\n\\t};\\n\\t\\n\\tCookieStorage.prototype.setItem = function(key, value) {\\n\\t  cookies.create(key, value, 1);\\n\\t};\\n\\t\\n\\tmodule.exports = CookieStorage;\\n\\n\\n/***/ },\\n/* 51 */\\n/***/ function(module, exports) {\\n\\n\\tfunction DummyStorage() {}\\n\\t\\n\\tDummyStorage.prototype.getItem = function() {\\n\\t  return null;\\n\\t};\\n\\t\\n\\tDummyStorage.prototype.removeItem = function() {};\\n\\t\\n\\tDummyStorage.prototype.setItem = function() {};\\n\\t\\n\\tmodule.exports = DummyStorage;\\n\\n\\n/***/ },\\n/* 52 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar windowHandler = __webpack_require__(3);\\n\\tvar DummyStorage = __webpack_require__(51);\\n\\tvar CookieStorage = __webpack_require__(50);\\n\\tvar Warn = __webpack_require__(11);\\n\\t\\n\\tfunction StorageHandler() {\\n\\t  this.warn = new Warn({});\\n\\t  this.storage = windowHandler.getWindow().localStorage || new CookieStorage();\\n\\t}\\n\\t\\n\\tStorageHandler.prototype.failover = function() {\\n\\t  if (this.storage instanceof DummyStorage) {\\n\\t    this.warn.warning('DummyStorage: ignore failover');\\n\\t    return;\\n\\t  } else if (this.storage instanceof CookieStorage) {\\n\\t    this.warn.warning('CookieStorage: failing over DummyStorage');\\n\\t    this.storage = new DummyStorage();\\n\\t  } else {\\n\\t    this.warn.warning('LocalStorage: failing over CookieStorage');\\n\\t    this.storage = new CookieStorage();\\n\\t  }\\n\\t};\\n\\t\\n\\tStorageHandler.prototype.getItem = function(key) {\\n\\t  try {\\n\\t    return this.storage.getItem(key);\\n\\t  } catch (e) {\\n\\t    this.warn.warning(e);\\n\\t    this.failover();\\n\\t    return this.getItem(key);\\n\\t  }\\n\\t};\\n\\t\\n\\tStorageHandler.prototype.removeItem = function(key) {\\n\\t  try {\\n\\t    return this.storage.removeItem(key);\\n\\t  } catch (e) {\\n\\t    this.warn.warning(e);\\n\\t    this.failover();\\n\\t    return this.removeItem(key);\\n\\t  }\\n\\t};\\n\\t\\n\\tStorageHandler.prototype.setItem = function(key, value) {\\n\\t  try {\\n\\t    return this.storage.setItem(key, value);\\n\\t  } catch (e) {\\n\\t    this.warn.warning(e);\\n\\t    this.failover();\\n\\t    return this.setItem(key, value);\\n\\t  }\\n\\t};\\n\\t\\n\\tmodule.exports = StorageHandler;\\n\\n\\n/***/ },\\n/* 53 */\\n/***/ function(module, exports) {\\n\\n\\t// given a URL, extract the origin. Taken from: https://github.com/firebase/firebase-simple-login/blob/d2cb95b9f812d8488bdbfba51c3a7c153ba1a074/js/src/simple-login/transports/WinChan.js#L25-L30\\n\\tfunction extractOrigin(url) {\\n\\t  if (!/^https?:\\\\/\\\\//.test(url)) url = window.location.href;\\n\\t  var m = /^(https?:\\\\/\\\\/[-_a-zA-Z.0-9:]+)/.exec(url);\\n\\t  if (m) return m[1];\\n\\t  return url;\\n\\t}\\n\\t\\n\\tmodule.exports = {\\n\\t  extractOrigin: extractOrigin\\n\\t};\\n\\n\\n/***/ },\\n/* 54 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar Authentication = __webpack_require__(19);\\n\\tvar Management = __webpack_require__(55);\\n\\tvar WebAuth = __webpack_require__(57);\\n\\tvar version = __webpack_require__(9);\\n\\t\\n\\tmodule.exports = {\\n\\t  Authentication: Authentication,\\n\\t  Management: Management,\\n\\t  WebAuth: WebAuth,\\n\\t  version: version.raw\\n\\t};\\n\\n\\n/***/ },\\n/* 55 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar urljoin = __webpack_require__(1);\\n\\t\\n\\tvar RequestBuilder = __webpack_require__(10);\\n\\tvar assert = __webpack_require__(4);\\n\\tvar responseHandler = __webpack_require__(6);\\n\\t\\n\\t/**\\n\\t * Auth0 Management API Client (methods allowed to be called from the browser only)\\n\\t * @constructor\\n\\t * @param {Object} options\\n\\t * @param {Object} options.domain your Auth0 acount domain\\n\\t * @param {Object} options.token a valid API token\\n\\t */\\n\\tfunction Management(options) {\\n\\t  /* eslint-disable */\\n\\t  assert.check(\\n\\t    options,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      domain: { type: 'string', message: 'domain option is required' },\\n\\t      token: { type: 'string', message: 'token option is required' },\\n\\t      _sendTelemetry: {\\n\\t        optional: true,\\n\\t        type: 'boolean',\\n\\t        message: '_sendTelemetry option is not valid'\\n\\t      },\\n\\t      _telemetryInfo: {\\n\\t        optional: true,\\n\\t        type: 'object',\\n\\t        message: '_telemetryInfo option is not valid'\\n\\t      }\\n\\t    }\\n\\t  );\\n\\t  /* eslint-enable */\\n\\t\\n\\t  this.baseOptions = options;\\n\\t\\n\\t  this.baseOptions.headers = { Authorization: 'Bearer ' + this.baseOptions.token };\\n\\t\\n\\t  this.request = new RequestBuilder(this.baseOptions);\\n\\t  this.baseOptions.rootUrl = urljoin('https://' + this.baseOptions.domain, 'api', 'v2');\\n\\t}\\n\\t\\n\\t/**\\n\\t * @callback userCallback\\n\\t * @param {Error} [err] failure reason for the failed request to Management API\\n\\t * @param {Object} [result] user profile\\n\\t */\\n\\t\\n\\t/**\\n\\t * Returns the user profile\\n\\t *\\n\\t * @method getUser\\n\\t * @param {String} userId identifier of the user to retrieve\\n\\t * @param {userCallback} cb\\n\\t * @see https://auth0.com/docs/api/management/v2#!/Users/get_users_by_id\\n\\t */\\n\\tManagement.prototype.getUser = function(userId, cb) {\\n\\t  var url;\\n\\t\\n\\t  assert.check(userId, { type: 'string', message: 'userId parameter is not valid' });\\n\\t  assert.check(cb, { type: 'function', message: 'cb parameter is not valid' });\\n\\t\\n\\t  url = urljoin(this.baseOptions.rootUrl, 'users', userId);\\n\\t\\n\\t  return this.request.get(url).end(responseHandler(cb, { ignoreCasing: true }));\\n\\t};\\n\\t\\n\\t/**\\n\\t * Updates the user metdata. It will patch the user metdata with the attributes sent.\\n\\t *\\n\\t *\\n\\t * @method patchUserMetadata\\n\\t * @param {String} userId\\n\\t * @param {Object} userMetadata\\n\\t * @param {userCallback} cb\\n\\t * @see   {@link https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id}\\n\\t */\\n\\tManagement.prototype.patchUserMetadata = function(userId, userMetadata, cb) {\\n\\t  var url;\\n\\t\\n\\t  assert.check(userId, { type: 'string', message: 'userId parameter is not valid' });\\n\\t  assert.check(userMetadata, { type: 'object', message: 'userMetadata parameter is not valid' });\\n\\t  assert.check(cb, { type: 'function', message: 'cb parameter is not valid' });\\n\\t\\n\\t  url = urljoin(this.baseOptions.rootUrl, 'users', userId);\\n\\t\\n\\t  return this.request\\n\\t    .patch(url)\\n\\t    .send({ user_metadata: userMetadata })\\n\\t    .end(responseHandler(cb, { ignoreCasing: true }));\\n\\t};\\n\\t\\n\\t/**\\n\\t * Link two users\\n\\t *\\n\\t * @method linkUser\\n\\t * @param {String} userId\\n\\t * @param {String} secondaryUserToken\\n\\t * @param {userCallback} cb\\n\\t * @see   {@link https://auth0.com/docs/api/management/v2#!/Users/post_identities}\\n\\t */\\n\\tManagement.prototype.linkUser = function(userId, secondaryUserToken, cb) {\\n\\t  var url;\\n\\t  /* eslint-disable */\\n\\t  assert.check(userId, { type: 'string', message: 'userId parameter is not valid' });\\n\\t  assert.check(secondaryUserToken, {\\n\\t    type: 'string',\\n\\t    message: 'secondaryUserToken parameter is not valid'\\n\\t  });\\n\\t  assert.check(cb, { type: 'function', message: 'cb parameter is not valid' });\\n\\t  /* eslint-enable */\\n\\t\\n\\t  url = urljoin(this.baseOptions.rootUrl, 'users', userId, 'identities');\\n\\t\\n\\t  return this.request\\n\\t    .post(url)\\n\\t    .send({ link_with: secondaryUserToken })\\n\\t    .end(responseHandler(cb, { ignoreCasing: true }));\\n\\t};\\n\\t\\n\\tmodule.exports = Management;\\n\\n\\n/***/ },\\n/* 56 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar urljoin = __webpack_require__(1);\\n\\t\\n\\tvar windowHelper = __webpack_require__(3);\\n\\tvar objectHelper = __webpack_require__(2);\\n\\tvar RequestBuilder = __webpack_require__(10);\\n\\t\\n\\tfunction CrossOriginAuthentication(webAuth, options) {\\n\\t  this.webAuth = webAuth;\\n\\t  this.baseOptions = options;\\n\\t  this.request = new RequestBuilder(options);\\n\\t}\\n\\t\\n\\tfunction getFragment(name) {\\n\\t  var theWindow = windowHelper.getWindow();\\n\\t  var value = '&' + theWindow.location.hash.substring(1);\\n\\t  var parts = value.split('&' + name + '=');\\n\\t  if (parts.length === 2) {\\n\\t    return parts.pop().split('&').shift();\\n\\t  }\\n\\t}\\n\\t\\n\\tfunction createKey(origin, coId) {\\n\\t  return ['co/verifier', encodeURIComponent(origin), encodeURIComponent(coId)].join('/');\\n\\t}\\n\\t\\n\\t/**\\n\\t * Logs in the user with username and password using the cross origin authentication (/co/authenticate) flow. You can use either `username` or `email` to identify the user, but `username` will take precedence over `email`.\\n\\t * This only works when 3rd party cookies are enabled in the browser. After the /co/authenticate call, you'll have to use the {@link parseHash} function at the `redirectUri` specified in the constructor.\\n\\t *\\n\\t * @method login\\n\\t * @param {Object} options options used in the {@link authorize} call after the login_ticket is acquired\\n\\t * @param {String} [options.username] Username (mutually exclusive with email)\\n\\t * @param {String} [options.email] Email  (mutually exclusive with username)\\n\\t * @param {String} options.password Password\\n\\t * @param {String} [options.realm] Realm used to authenticate the user, it can be a realm name or a database connection name\\n\\t * @param {crossOriginLoginCallback} cb Callback function called only when an authentication error, like invalid username or password, occurs. For other types of errors, there will be a redirect to the `redirectUri`.\\n\\t */\\n\\tCrossOriginAuthentication.prototype.login = function(options, cb) {\\n\\t  var _this = this;\\n\\t  var theWindow = windowHelper.getWindow();\\n\\t  var url = urljoin(this.baseOptions.rootUrl, '/co/authenticate');\\n\\t  var authenticateBody = {\\n\\t    client_id: options.clientID || this.baseOptions.clientID,\\n\\t    username: options.username || options.email\\n\\t  };\\n\\t  if (options.password) {\\n\\t    authenticateBody.password = options.password;\\n\\t  }\\n\\t  if (options.otp) {\\n\\t    authenticateBody.otp = options.otp;\\n\\t  }\\n\\t  var realm = options.realm || this.baseOptions.realm;\\n\\t\\n\\t  if (realm) {\\n\\t    var credentialType =\\n\\t      options.credentialType ||\\n\\t      this.baseOptions.credentialType ||\\n\\t      'http://auth0.com/oauth/grant-type/password-realm';\\n\\t    authenticateBody.realm = realm;\\n\\t    authenticateBody.credential_type = credentialType;\\n\\t  } else {\\n\\t    authenticateBody.credential_type = 'password';\\n\\t  }\\n\\t  this.request.post(url).withCredentials().send(authenticateBody).end(function(err, data) {\\n\\t    if (err) {\\n\\t      var errorObject = (err.response && err.response.body) || {\\n\\t        error: 'request_error',\\n\\t        error_description: JSON.stringify(err)\\n\\t      };\\n\\t      return cb(errorObject);\\n\\t    }\\n\\t    options = objectHelper.blacklist(options, ['username', 'password', 'credentialType', 'otp']);\\n\\t    var authorizeOptions = objectHelper\\n\\t      .merge(options)\\n\\t      .with({ loginTicket: data.body.login_ticket });\\n\\t    var key = createKey(_this.baseOptions.rootUrl, data.body.co_id);\\n\\t    theWindow.sessionStorage[key] = data.body.co_verifier;\\n\\t    _this.webAuth.authorize(authorizeOptions);\\n\\t  });\\n\\t};\\n\\t\\n\\tfunction tryGetVerifier(theWindow, key) {\\n\\t  try {\\n\\t    var verifier = theWindow.sessionStorage[key];\\n\\t    theWindow.sessionStorage.removeItem(key);\\n\\t    return verifier;\\n\\t  } catch (e) {\\n\\t    return '';\\n\\t  }\\n\\t}\\n\\t\\n\\t/**\\n\\t * Runs the callback code for the cross origin authentication call. This method is meant to be called by the cross origin authentication callback url.\\n\\t *\\n\\t * @method callback\\n\\t */\\n\\tCrossOriginAuthentication.prototype.callback = function() {\\n\\t  var targetOrigin = decodeURIComponent(getFragment('origin'));\\n\\t  var theWindow = windowHelper.getWindow();\\n\\t\\n\\t  theWindow.addEventListener('message', function(evt) {\\n\\t    if (evt.data.type !== 'co_verifier_request') {\\n\\t      return;\\n\\t    }\\n\\t    var key = createKey(evt.origin, evt.data.request.id);\\n\\t    var verifier = tryGetVerifier(theWindow, key);\\n\\t\\n\\t    evt.source.postMessage(\\n\\t      {\\n\\t        type: 'co_verifier_response',\\n\\t        response: {\\n\\t          verifier: verifier\\n\\t        }\\n\\t      },\\n\\t      evt.origin\\n\\t    );\\n\\t  });\\n\\t\\n\\t  theWindow.parent.postMessage({ type: 'ready' }, targetOrigin);\\n\\t};\\n\\t\\n\\tmodule.exports = CrossOriginAuthentication;\\n\\n\\n/***/ },\\n/* 57 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar IdTokenVerifier = __webpack_require__(30);\\n\\t\\n\\tvar assert = __webpack_require__(4);\\n\\tvar error = __webpack_require__(21);\\n\\tvar qs = __webpack_require__(5);\\n\\tvar PluginHandler = __webpack_require__(46);\\n\\tvar windowHelper = __webpack_require__(3);\\n\\tvar objectHelper = __webpack_require__(2);\\n\\tvar TransactionManager = __webpack_require__(22);\\n\\tvar Authentication = __webpack_require__(19);\\n\\tvar Redirect = __webpack_require__(59);\\n\\tvar Popup = __webpack_require__(58);\\n\\tvar SilentAuthenticationHandler = __webpack_require__(60);\\n\\tvar CrossOriginAuthentication = __webpack_require__(56);\\n\\t/**\\n\\t * Handles all the browser's AuthN/AuthZ flows\\n\\t * @constructor\\n\\t * @param {Object} options\\n\\t * @param {String} options.domain your Auth0 domain\\n\\t * @param {String} options.clientID your Auth0 client identifier obtained when creating the client in the Auth0 Dashboard\\n\\t * @param {String} [options.redirectUri] url that the Auth0 will redirect after Auth with the Authorization Response\\n\\t * @param {String} [options.responseType] type of the response used by OAuth 2.0 flow. It can be any space separated list of the values `code`, `token`, `id_token`. {@link https://openid.net/specs/oauth-v2-multiple-response-types-1_0}\\n\\t * @param {String} [options.responseMode] how the Auth response is encoded and redirected back to the client. Supported values are `query`, `fragment` and `form_post`. {@link https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#ResponseModes}\\n\\t * @param {String} [options.scope] scopes to be requested during Auth. e.g. `openid email`\\n\\t * @param {String} [options.audience] identifier of the resource server who will consume the access token issued after Auth\\n\\t * @param {Array} [options.plugins]\\n\\t * @param {Number} [options._timesToRetryFailedRequests] Number of times to retry a failed request, according to {@link https://github.com/visionmedia/superagent/blob/master/lib/should-retry.js}\\n\\t * @see {@link https://auth0.com/docs/api/authentication}\\n\\t */\\n\\tfunction WebAuth(options) {\\n\\t  /* eslint-disable */\\n\\t  assert.check(\\n\\t    options,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      domain: { type: 'string', message: 'domain option is required' },\\n\\t      clientID: { type: 'string', message: 'clientID option is required' },\\n\\t      responseType: { optional: true, type: 'string', message: 'responseType is not valid' },\\n\\t      responseMode: { optional: true, type: 'string', message: 'responseMode is not valid' },\\n\\t      redirectUri: { optional: true, type: 'string', message: 'redirectUri is not valid' },\\n\\t      scope: { optional: true, type: 'string', message: 'scope is not valid' },\\n\\t      audience: { optional: true, type: 'string', message: 'audience is not valid' },\\n\\t      leeway: { optional: true, type: 'number', message: 'leeway is not valid' },\\n\\t      plugins: { optional: true, type: 'array', message: 'plugins is not valid' },\\n\\t      _disableDeprecationWarnings: {\\n\\t        optional: true,\\n\\t        type: 'boolean',\\n\\t        message: '_disableDeprecationWarnings option is not valid'\\n\\t      },\\n\\t      _sendTelemetry: {\\n\\t        optional: true,\\n\\t        type: 'boolean',\\n\\t        message: '_sendTelemetry option is not valid'\\n\\t      },\\n\\t      _telemetryInfo: {\\n\\t        optional: true,\\n\\t        type: 'object',\\n\\t        message: '_telemetryInfo option is not valid'\\n\\t      },\\n\\t      _timesToRetryFailedRequests: {\\n\\t        optional: true,\\n\\t        type: 'number',\\n\\t        message: '_timesToRetryFailedRequests option is not valid'\\n\\t      }\\n\\t    }\\n\\t  );\\n\\t\\n\\t  if (options.overrides) {\\n\\t    assert.check(\\n\\t      options.overrides,\\n\\t      { type: 'object', message: 'overrides option is not valid' },\\n\\t      {\\n\\t        __tenant: { type: 'string', message: '__tenant option is required' },\\n\\t        __token_issuer: { type: 'string', message: '__token_issuer option is required' }\\n\\t      }\\n\\t    );\\n\\t  }\\n\\t  /* eslint-enable */\\n\\t\\n\\t  this.baseOptions = options;\\n\\t  this.baseOptions.plugins = new PluginHandler(this, this.baseOptions.plugins || []);\\n\\t\\n\\t  this.baseOptions._sendTelemetry = this.baseOptions._sendTelemetry === false\\n\\t    ? this.baseOptions._sendTelemetry\\n\\t    : true;\\n\\t\\n\\t  this.baseOptions._timesToRetryFailedRequests = options._timesToRetryFailedRequests\\n\\t    ? parseInt(options._timesToRetryFailedRequests, 0)\\n\\t    : 0;\\n\\t\\n\\t  this.baseOptions.tenant =\\n\\t    (this.baseOptions.overrides && this.baseOptions.overrides.__tenant) ||\\n\\t    this.baseOptions.domain.split('.')[0];\\n\\t\\n\\t  this.baseOptions.token_issuer =\\n\\t    (this.baseOptions.overrides && this.baseOptions.overrides.__token_issuer) ||\\n\\t    'https://' + this.baseOptions.domain + '/';\\n\\t\\n\\t  this.transactionManager = new TransactionManager(this.baseOptions.transaction);\\n\\t\\n\\t  this.client = new Authentication(this.baseOptions);\\n\\t  this.redirect = new Redirect(this.client, this.baseOptions);\\n\\t  this.popup = new Popup(this, this.baseOptions);\\n\\t  this.crossOriginAuthentication = new CrossOriginAuthentication(this, this.baseOptions);\\n\\t}\\n\\t\\n\\t/**\\n\\t * Parse the url hash and extract the Auth response from a Auth flow started with {@link authorize}\\n\\t *\\n\\t * Only validates id_tokens signed by Auth0 using the RS256 algorithm using the public key exposed\\n\\t * by the `/.well-known/jwks.json` endpoint of your account.\\n\\t * Tokens signed with other algorithms, e.g. HS256 will not be accepted.\\n\\t *\\n\\t * @method parseHash\\n\\t * @param {Object} options\\n\\t * @param {String} options.hash the url hash. If not provided it will extract from window.location.hash\\n\\t * @param {String} [options.state] value originally sent in `state` parameter to {@link authorize} to mitigate XSRF\\n\\t * @param {String} [options.nonce] value originally sent in `nonce` parameter to {@link authorize} to prevent replay attacks\\n\\t * @param {String} [options._idTokenVerification] makes parseHash perform or skip `id_token` verification. We **strongly** recommend validating the `id_token` yourself if you disable the verification.\\n\\t * @param {authorizeCallback} cb\\n\\t */\\n\\tWebAuth.prototype.parseHash = function(options, cb) {\\n\\t  var parsedQs;\\n\\t  var err;\\n\\t  var state;\\n\\t  var transaction;\\n\\t  var transactionNonce;\\n\\t\\n\\t  if (!cb && typeof options === 'function') {\\n\\t    cb = options;\\n\\t    options = {};\\n\\t  } else {\\n\\t    options = options || {};\\n\\t  }\\n\\t\\n\\t  options._idTokenVerification = !(options._idTokenVerification === false);\\n\\t\\n\\t  var _window = windowHelper.getWindow();\\n\\t\\n\\t  var hashStr = options.hash === undefined ? _window.location.hash : options.hash;\\n\\t  hashStr = hashStr.replace(/^#?\\\\/?/, '');\\n\\t\\n\\t  parsedQs = qs.parse(hashStr);\\n\\t\\n\\t  if (parsedQs.hasOwnProperty('error')) {\\n\\t    err = error.buildResponse(parsedQs.error, parsedQs.error_description);\\n\\t\\n\\t    if (parsedQs.state) {\\n\\t      err.state = parsedQs.state;\\n\\t    }\\n\\t\\n\\t    return cb(err);\\n\\t  }\\n\\t\\n\\t  if (\\n\\t    !parsedQs.hasOwnProperty('access_token') &&\\n\\t    !parsedQs.hasOwnProperty('id_token') &&\\n\\t    !parsedQs.hasOwnProperty('refresh_token')\\n\\t  ) {\\n\\t    return cb(null, null);\\n\\t  }\\n\\t\\n\\t  state = parsedQs.state || options.state;\\n\\t\\n\\t  transaction = this.transactionManager.getStoredTransaction(state);\\n\\t  transactionNonce = options.nonce || (transaction && transaction.nonce) || null;\\n\\t\\n\\t  var applicationStatus = (transaction && transaction.appStatus) || null;\\n\\t  if (parsedQs.id_token && options._idTokenVerification) {\\n\\t    return this.validateToken(parsedQs.id_token, transactionNonce, function(\\n\\t      validationError,\\n\\t      payload\\n\\t    ) {\\n\\t      if (validationError) {\\n\\t        return cb(validationError);\\n\\t      }\\n\\t      return cb(null, buildParseHashResponse(parsedQs, applicationStatus, payload));\\n\\t    });\\n\\t  }\\n\\t\\n\\t  if (parsedQs.id_token) {\\n\\t    var verifier = new IdTokenVerifier({\\n\\t      issuer: this.baseOptions.token_issuer,\\n\\t      audience: this.baseOptions.clientID,\\n\\t      leeway: this.baseOptions.leeway || 0,\\n\\t      __disableExpirationCheck: this.baseOptions.__disableExpirationCheck\\n\\t    });\\n\\t\\n\\t    var decodedToken = verifier.decode(parsedQs.id_token);\\n\\t    cb(null, buildParseHashResponse(parsedQs, applicationStatus, decodedToken.payload));\\n\\t  } else {\\n\\t    cb(null, buildParseHashResponse(parsedQs, applicationStatus, null));\\n\\t  }\\n\\t};\\n\\t\\n\\tfunction buildParseHashResponse(qsParams, appStatus, token) {\\n\\t  return {\\n\\t    accessToken: qsParams.access_token || null,\\n\\t    idToken: qsParams.id_token || null,\\n\\t    idTokenPayload: token || null,\\n\\t    appStatus: appStatus || null,\\n\\t    refreshToken: qsParams.refresh_token || null,\\n\\t    state: qsParams.state || null,\\n\\t    expiresIn: qsParams.expires_in ? parseInt(qsParams.expires_in, 10) : null,\\n\\t    tokenType: qsParams.token_type || null,\\n\\t    scope: qsParams.scope || null\\n\\t  };\\n\\t}\\n\\t\\n\\t/**\\n\\t * @callback validateTokenCallback\\n\\t * @param {Error} [err] error returned by while validating the token\\n\\t * @param {Object} [payload] claims stored in the token\\n\\t */\\n\\t\\n\\t/**\\n\\t * Decodes the a JWT and verifies its nonce value\\n\\t *\\n\\t * @method validateToken\\n\\t * @private\\n\\t * @param {String} token\\n\\t * @param {String} nonce\\n\\t * @param {validateTokenCallback} cb\\n\\t */\\n\\tWebAuth.prototype.validateToken = function(token, nonce, cb) {\\n\\t  var verifier = new IdTokenVerifier({\\n\\t    issuer: this.baseOptions.token_issuer,\\n\\t    audience: this.baseOptions.clientID,\\n\\t    leeway: this.baseOptions.leeway || 0,\\n\\t    __disableExpirationCheck: this.baseOptions.__disableExpirationCheck\\n\\t  });\\n\\t\\n\\t  verifier.verify(token, nonce, function(err, payload) {\\n\\t    if (err) {\\n\\t      return cb(error.invalidJwt(err.message));\\n\\t    }\\n\\t\\n\\t    cb(null, payload);\\n\\t  });\\n\\t};\\n\\t\\n\\t/**\\n\\t * Executes a silent authentication transaction under the hood in order to fetch a new tokens for the current session.\\n\\t * This method requires that all Auth is performed with {@link authorize}\\n\\t * Watch out! If you're not using the hosted login page to do social logins, you have to use your own [social connection keys](https://manage.auth0.com/#/connections/social). If you use Auth0's dev keys, you'll always get `login_required` as an error when calling this method.\\n\\t *\\n\\t * @method renewAuth\\n\\t * @param {Object} options\\n\\t * @param {String} [options.domain] your Auth0 domain\\n\\t * @param {String} [options.clientID] your Auth0 client identifier obtained when creating the client in the Auth0 Dashboard\\n\\t * @param {String} [options.redirectUri] url that the Auth0 will redirect after Auth with the Authorization Response\\n\\t * @param {String} [options.responseType] type of the response used by OAuth 2.0 flow. It can be any space separated list of the values `code`, `token`, `id_token`. {@link https://openid.net/specs/oauth-v2-multiple-response-types-1_0}\\n\\t * @param {String} [options.responseMode] how the Auth response is encoded and redirected back to the client. Supported values are `query`, `fragment` and `form_post`. {@link https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#ResponseModes}\\n\\t * @param {String} [options.state] value used to mitigate XSRF attacks. {@link https://auth0.com/docs/protocols/oauth2/oauth-state}\\n\\t * @param {String} [options.nonce] value used to mitigate replay attacks when using Implicit Grant. {@link https://auth0.com/docs/api-auth/tutorials/nonce}\\n\\t * @param {String} [options.scope] scopes to be requested during Auth. e.g. `openid email`\\n\\t * @param {String} [options.audience] identifier of the resource server who will consume the access token issued after Auth\\n\\t * @param {String} [options.postMessageDataType] identifier data type to look for in postMessage event data, where events are initiated from silent callback urls, before accepting a message event is the event expected. A value of false means any postMessage event will trigger a callback.\\n\\t * @see {@link https://auth0.com/docs/api/authentication#authorize-client}\\n\\t */\\n\\tWebAuth.prototype.renewAuth = function(options, cb) {\\n\\t  var handler;\\n\\t  var usePostMessage = !!options.usePostMessage;\\n\\t  var postMessageDataType = options.postMessageDataType || false;\\n\\t  var _this = this;\\n\\t\\n\\t  var params = objectHelper\\n\\t    .merge(this.baseOptions, [\\n\\t      'clientID',\\n\\t      'redirectUri',\\n\\t      'responseType',\\n\\t      'scope',\\n\\t      'audience',\\n\\t      '_csrf',\\n\\t      'state',\\n\\t      '_intstate',\\n\\t      'nonce'\\n\\t    ])\\n\\t    .with(options);\\n\\t\\n\\t  params.responseType = params.responseType || 'token';\\n\\t  params.responseMode = params.responseMode || 'fragment';\\n\\t  if (!options.nonce) {\\n\\t    params = this.transactionManager.process(params);\\n\\t  }\\n\\t\\n\\t  assert.check(params, { type: 'object', message: 'options parameter is not valid' });\\n\\t  assert.check(cb, { type: 'function', message: 'cb parameter is not valid' });\\n\\t\\n\\t  params.prompt = 'none';\\n\\t\\n\\t  params = objectHelper.blacklist(params, ['usePostMessage', 'tenant', 'postMessageDataType']);\\n\\t\\n\\t  handler = SilentAuthenticationHandler.create({\\n\\t    authenticationUrl: this.client.buildAuthorizeUrl(params),\\n\\t    postMessageDataType: postMessageDataType\\n\\t  });\\n\\t\\n\\t  handler.login(usePostMessage, function(err, hash) {\\n\\t    if (typeof hash === 'object') {\\n\\t      // hash was already parsed, so we just return it.\\n\\t      // it's here to be backwards compatible and should be removed in the next major version.\\n\\t      return cb(err, hash);\\n\\t    }\\n\\t    var transaction = _this.transactionManager.getStoredTransaction(params.state);\\n\\t    var transactionNonce = options.nonce || (transaction && transaction.nonce) || null;\\n\\t    var transactionState = options.state || (transaction && transaction.state) || null;\\n\\t    _this.parseHash({ hash: hash, nonce: transactionNonce, state: transactionState }, cb);\\n\\t  });\\n\\t};\\n\\t\\n\\t/**\\n\\t * Request an email with instruction to change a user's password\\n\\t *\\n\\t * @method changePassword\\n\\t * @param {Object} options\\n\\t * @param {String} options.email address where the user will recieve the change password email. It should match the user's email in Auth0\\n\\t * @param {String} options.connection name of the connection where the user was created\\n\\t * @param {changePasswordCallback} cb\\n\\t * @see   {@link https://auth0.com/docs/api/authentication#change-password}\\n\\t */\\n\\tWebAuth.prototype.changePassword = function(options, cb) {\\n\\t  return this.client.dbConnection.changePassword(options, cb);\\n\\t};\\n\\t\\n\\t/**\\n\\t * Starts a passwordless authentication transaction.\\n\\t *\\n\\t * @method passwordlessStart\\n\\t * @param {Object} options\\n\\t * @param {String} options.send what will be sent via email which could be `link` or `code`. For SMS `code` is the only one valud\\n\\t * @param {String} [options.phoneNumber] phone number where to send the `code`. This parameter is mutually exclusive with `email`\\n\\t * @param {String} [options.email] email where to send the `code` or `link`. This parameter is mutually exclusive with `phoneNumber`\\n\\t * @param {String} options.connection name of the passwordless connection\\n\\t * @param {Object} [options.authParams] additional Auth parameters when using `link`\\n\\t * @param {Function} cb\\n\\t * @see   {@link https://auth0.com/docs/api/authentication#passwordless}\\n\\t */\\n\\tWebAuth.prototype.passwordlessStart = function(options, cb) {\\n\\t  var authParams = objectHelper\\n\\t    .merge(this.baseOptions, [\\n\\t      'responseType',\\n\\t      'responseMode',\\n\\t      'redirectUri',\\n\\t      'scope',\\n\\t      'audience',\\n\\t      '_csrf',\\n\\t      'state',\\n\\t      '_intstate',\\n\\t      'nonce'\\n\\t    ])\\n\\t    .with(options.authParams);\\n\\t\\n\\t  options.authParams = this.transactionManager.process(authParams);\\n\\t  return this.client.passwordless.start(options, cb);\\n\\t};\\n\\t\\n\\t/**\\n\\t * Creates a new user in a Auth0 Database connection\\n\\t *\\n\\t * @method signup\\n\\t * @param {Object} options\\n\\t * @param {String} options.email user email address\\n\\t * @param {String} options.password user password\\n\\t * @param {String} options.connection name of the connection where the user will be created\\n\\t * @param {signUpCallback} cb\\n\\t * @see   {@link https://auth0.com/docs/api/authentication#signup}\\n\\t */\\n\\tWebAuth.prototype.signup = function(options, cb) {\\n\\t  return this.client.dbConnection.signup(options, cb);\\n\\t};\\n\\t\\n\\t/**\\n\\t * Redirects to the hosted login page (`/authorize`) in order to start a new authN/authZ transaction.\\n\\t * After that, you'll have to use the {@link parseHash} function at the specified `redirectUri`.\\n\\t *\\n\\t * @method authorize\\n\\t * @param {Object} options\\n\\t * @param {String} [options.domain] your Auth0 domain\\n\\t * @param {String} [options.clientID] your Auth0 client identifier obtained when creating the client in the Auth0 Dashboard\\n\\t * @param {String} options.redirectUri url that the Auth0 will redirect after Auth with the Authorization Response\\n\\t * @param {String} options.responseType type of the response used by OAuth 2.0 flow. It can be any space separated list of the values `code`, `token`, `id_token`. {@link https://openid.net/specs/oauth-v2-multiple-response-types-1_0}\\n\\t * @param {String} [options.responseMode] how the Auth response is encoded and redirected back to the client. Supported values are `query`, `fragment` and `form_post`. {@link https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#ResponseModes}\\n\\t * @param {String} [options.state] value used to mitigate XSRF attacks. {@link https://auth0.com/docs/protocols/oauth2/oauth-state}\\n\\t * @param {String} [options.nonce] value used to mitigate replay attacks when using Implicit Grant. {@link https://auth0.com/docs/api-auth/tutorials/nonce}\\n\\t * @param {String} [options.scope] scopes to be requested during Auth. e.g. `openid email`\\n\\t * @param {String} [options.audience] identifier of the resource server who will consume the access token issued after Auth\\n\\t * @see {@link https://auth0.com/docs/api/authentication#authorize-client}\\n\\t */\\n\\tWebAuth.prototype.authorize = function(options) {\\n\\t  var params = objectHelper\\n\\t    .merge(this.baseOptions, [\\n\\t      'clientID',\\n\\t      'responseType',\\n\\t      'responseMode',\\n\\t      'redirectUri',\\n\\t      'scope',\\n\\t      'audience',\\n\\t      '_csrf',\\n\\t      'state',\\n\\t      '_intstate',\\n\\t      'nonce'\\n\\t    ])\\n\\t    .with(options);\\n\\t\\n\\t  assert.check(\\n\\t    params,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      responseType: { type: 'string', message: 'responseType option is required' }\\n\\t    }\\n\\t  );\\n\\t\\n\\t  params = this.transactionManager.process(params);\\n\\t\\n\\t  windowHelper.redirect(this.client.buildAuthorizeUrl(params));\\n\\t};\\n\\t\\n\\t/**\\n\\t * Signs up a new user, automatically logs the user in after the signup and returns the user token.\\n\\t * The login will be done using /oauth/token with password-realm grant type.\\n\\t *\\n\\t * @method signupAndAuthorize\\n\\t * @param {Object} options\\n\\t * @param {String} options.email user email address\\n\\t * @param {String} options.password user password\\n\\t * @param {String} options.connection name of the connection where the user will be created\\n\\t * @param {tokenCallback} cb\\n\\t * @see   {@link https://auth0.com/docs/api/authentication#signup}\\n\\t * @see   {@link https://auth0.com/docs/api-auth/grant/password}\\n\\t */\\n\\tWebAuth.prototype.signupAndAuthorize = function(options, cb) {\\n\\t  var _this = this;\\n\\t\\n\\t  return this.client.dbConnection.signup(\\n\\t    objectHelper.blacklist(options, ['popupHandler']),\\n\\t    function(err) {\\n\\t      if (err) {\\n\\t        return cb(err);\\n\\t      }\\n\\t      options.realm = options.connection;\\n\\t      if (!options.username) {\\n\\t        options.username = options.email;\\n\\t      }\\n\\t      _this.client.login(options, cb);\\n\\t    }\\n\\t  );\\n\\t};\\n\\t\\n\\t/**\\n\\t * @callback crossOriginLoginCallback\\n\\t * @param {Error} [err] Authentication error returned by Auth0 with the reason why the request failed\\n\\t */\\n\\t\\n\\t/**\\n\\t * Logs in the user with username and password using the cross origin authentication (/co/authenticate) flow. You can use either `username` or `email` to identify the user, but `username` will take precedence over `email`.\\n\\t * This only works when 3rd party cookies are enabled in the browser. After the /co/authenticate call, you'll have to use the {@link parseHash} function at the `redirectUri` specified in the constructor.\\n\\t *\\n\\t * @method login\\n\\t * @param {Object} options options used in the {@link authorize} call after the login_ticket is acquired\\n\\t * @param {String} [options.username] Username (mutually exclusive with email)\\n\\t * @param {String} [options.email] Email (mutually exclusive with username)\\n\\t * @param {String} options.password Password\\n\\t * @param {String} [options.realm] Realm used to authenticate the user, it can be a realm name or a database connection name\\n\\t * @param {crossOriginLoginCallback} cb Callback function called only when an authentication error, like invalid username or password, occurs. For other types of errors, there will be a redirect to the `redirectUri`.\\n\\t */\\n\\tWebAuth.prototype.login = function(options, cb) {\\n\\t  this.crossOriginAuthentication.login(options, cb);\\n\\t};\\n\\t\\n\\t/**\\n\\t * Logs in the user by verifying the verification code (OTP) using the cross origin authentication (/co/authenticate) flow. You can use either `phoneNumber` or `email` to identify the user.\\n\\t * This only works when 3rd party cookies are enabled in the browser. After the /co/authenticate call, you'll have to use the {@link parseHash} function at the `redirectUri` specified in the constructor.\\n\\t *\\n\\t * @method login\\n\\t * @param {Object} options options used in the {@link authorize} call after the login_ticket is acquired\\n\\t * @param {String} [options.phoneNumber] Phone Number (mutually exclusive with email)\\n\\t * @param {String} [options.email] Email (mutually exclusive with username)\\n\\t * @param {String} options.verificationCode Verification Code (OTP)\\n\\t * @param {String} options.connection Passwordless connection to use. It can either be 'sms' or 'email'.\\n\\t * @param {crossOriginLoginCallback} cb Callback function called only when an authentication error, like invalid username or password, occurs. For other types of errors, there will be a redirect to the `redirectUri`.\\n\\t */\\n\\tWebAuth.prototype.passwordlessLogin = function(options, cb) {\\n\\t  var loginOptions = objectHelper.extend(\\n\\t    {\\n\\t      credentialType: 'http://auth0.com/oauth/grant-type/passwordless/otp',\\n\\t      realm: options.connection,\\n\\t      username: options.email || options.phoneNumber,\\n\\t      otp: options.verificationCode\\n\\t    },\\n\\t    objectHelper.blacklist(options, ['connection', 'email', 'phoneNumber', 'verificationCode'])\\n\\t  );\\n\\t  this.crossOriginAuthentication.login(loginOptions, cb);\\n\\t};\\n\\t\\n\\t/**\\n\\t * Runs the callback code for the cross origin authentication call. This method is meant to be called by the cross origin authentication callback url.\\n\\t *\\n\\t * @method crossOriginAuthenticationCallback\\n\\t */\\n\\tWebAuth.prototype.crossOriginAuthenticationCallback = function() {\\n\\t  this.crossOriginAuthentication.callback();\\n\\t};\\n\\t\\n\\t/**\\n\\t * Redirects to the auth0 logout endpoint\\n\\t *\\n\\t * If you want to navigate the user to a specific URL after the logout, set that URL at the returnTo parameter. The URL should be included in any the appropriate Allowed Logout URLs list:\\n\\t *\\n\\t * - If the client_id parameter is included, the returnTo URL must be listed in the Allowed Logout URLs set at the client level (see Setting Allowed Logout URLs at the App Level).\\n\\t * - If the client_id parameter is NOT included, the returnTo URL must be listed in the Allowed Logout URLs set at the account level (see Setting Allowed Logout URLs at the Account Level).\\n\\t *\\n\\t * @method logout\\n\\t * @param {Object} options\\n\\t * @param {String} [options.clientID] identifier of your client\\n\\t * @param {String} [options.returnTo] URL to be redirected after the logout\\n\\t * @param {Boolean} [options.federated] tells Auth0 if it should logout the user also from the IdP.\\n\\t * @see   {@link https://auth0.com/docs/api/authentication#logout}\\n\\t */\\n\\tWebAuth.prototype.logout = function(options) {\\n\\t  windowHelper.redirect(this.client.buildLogoutUrl(options));\\n\\t};\\n\\t\\n\\t/**\\n\\t * Verifies the passwordless TOTP and redirects to finish the passwordless transaction\\n\\t *\\n\\t * @method passwordlessVerify\\n\\t * @param {Object} options\\n\\t * @param {String} options.type `sms` or `email`\\n\\t * @param {String} options.phoneNumber only if type = sms\\n\\t * @param {String} options.email only if type = email\\n\\t * @param {String} options.connection the connection name\\n\\t * @param {String} options.verificationCode the TOTP code\\n\\t * @param {Function} cb\\n\\t */\\n\\tWebAuth.prototype.passwordlessVerify = function(options, cb) {\\n\\t  var _this = this;\\n\\t  var params = objectHelper\\n\\t    .merge(this.baseOptions, [\\n\\t      'clientID',\\n\\t      'responseType',\\n\\t      'responseMode',\\n\\t      'redirectUri',\\n\\t      'scope',\\n\\t      'audience',\\n\\t      '_csrf',\\n\\t      'state',\\n\\t      '_intstate',\\n\\t      'nonce'\\n\\t    ])\\n\\t    .with(options);\\n\\t\\n\\t  assert.check(\\n\\t    params,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      responseType: { type: 'string', message: 'responseType option is required' }\\n\\t    }\\n\\t  );\\n\\t\\n\\t  params = this.transactionManager.process(params);\\n\\t  return this.client.passwordless.verify(params, function(err) {\\n\\t    if (err) {\\n\\t      return cb(err);\\n\\t    }\\n\\t    return windowHelper.redirect(_this.client.passwordless.buildVerifyUrl(params));\\n\\t  });\\n\\t};\\n\\t\\n\\tmodule.exports = WebAuth;\\n\\n\\n/***/ },\\n/* 58 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar urljoin = __webpack_require__(1);\\n\\tvar WinChan = __webpack_require__(18);\\n\\t\\n\\tvar urlHelper = __webpack_require__(53);\\n\\tvar assert = __webpack_require__(4);\\n\\tvar responseHandler = __webpack_require__(6);\\n\\tvar PopupHandler = __webpack_require__(47);\\n\\tvar objectHelper = __webpack_require__(2);\\n\\tvar Warn = __webpack_require__(11);\\n\\tvar TransactionManager = __webpack_require__(22);\\n\\t\\n\\tfunction Popup(webAuth, options) {\\n\\t  this.baseOptions = options;\\n\\t  this.client = webAuth.client;\\n\\t  this.webAuth = webAuth;\\n\\t\\n\\t  this.transactionManager = new TransactionManager(this.baseOptions.transaction);\\n\\t  this.warn = new Warn({\\n\\t    disableWarnings: !!options._disableDeprecationWarnings\\n\\t  });\\n\\t}\\n\\t\\n\\t/**\\n\\t * Returns a new instance of the popup handler\\n\\t *\\n\\t * @method buildPopupHandler\\n\\t * @private\\n\\t */\\n\\tPopup.prototype.buildPopupHandler = function() {\\n\\t  var pluginHandler = this.baseOptions.plugins.get('popup.getPopupHandler');\\n\\t\\n\\t  if (pluginHandler) {\\n\\t    return pluginHandler.getPopupHandler();\\n\\t  }\\n\\t\\n\\t  return new PopupHandler();\\n\\t};\\n\\t\\n\\t/**\\n\\t * Initializes the popup window and returns the instance to be used later in order to avoid being blocked by the browser.\\n\\t *\\n\\t * @method preload\\n\\t * @param {Object} options receives the window height and width and any other window feature to be sent to window.open\\n\\t */\\n\\tPopup.prototype.preload = function(options) {\\n\\t  options = options || {};\\n\\t\\n\\t  var popup = this.buildPopupHandler();\\n\\t\\n\\t  popup.preload(options);\\n\\t  return popup;\\n\\t};\\n\\t\\n\\t/**\\n\\t * Internal use.\\n\\t *\\n\\t * @method getPopupHandler\\n\\t * @private\\n\\t */\\n\\tPopup.prototype.getPopupHandler = function(options, preload) {\\n\\t  if (options.popupHandler) {\\n\\t    return options.popupHandler;\\n\\t  }\\n\\t\\n\\t  if (preload) {\\n\\t    return this.preload(options);\\n\\t  }\\n\\t\\n\\t  return this.buildPopupHandler();\\n\\t};\\n\\t\\n\\t/**\\n\\t * Handles the popup logic for the callback page.\\n\\t *\\n\\t * @method callback\\n\\t * @param {Object} options\\n\\t * @param {String} options.hash the url hash. If not provided it will extract from window.location.hash\\n\\t * @param {String} [options.state] value originally sent in `state` parameter to {@link authorize} to mitigate XSRF\\n\\t * @param {String} [options.nonce] value originally sent in `nonce` parameter to {@link authorize} to prevent replay attacks\\n\\t * @param {String} [options._idTokenVerification] makes parseHash perform or skip `id_token` verification. We **strongly** recommend validating the `id_token` yourself if you disable the verification.\\n\\t * @see   {@link parseHash}\\n\\t */\\n\\tPopup.prototype.callback = function(options) {\\n\\t  var _this = this;\\n\\t  WinChan.onOpen(function(popupOrigin, r, cb) {\\n\\t    _this.webAuth.parseHash(options || {}, function(err, data) {\\n\\t      return cb(err || data);\\n\\t    });\\n\\t  });\\n\\t};\\n\\t\\n\\t/**\\n\\t * Shows inside a new window the hosted login page (`/authorize`) in order to start a new authN/authZ transaction and post its result using `postMessage`.\\n\\t *\\n\\t * @method authorize\\n\\t * @param {Object} options\\n\\t * @param {String} [options.domain] your Auth0 domain\\n\\t * @param {String} [options.clientID] your Auth0 client identifier obtained when creating the client in the Auth0 Dashboard\\n\\t * @param {String} options.redirectUri url that the Auth0 will redirect after Auth with the Authorization Response\\n\\t * @param {String} options.responseType type of the response used by OAuth 2.0 flow. It can be any space separated list of the values `code`, `token`, `id_token`. {@link https://openid.net/specs/oauth-v2-multiple-response-types-1_0}\\n\\t * @param {String} [options.responseMode] how the Auth response is encoded and redirected back to the client. Supported values are `query`, `fragment` and `form_post`. {@link https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#ResponseModes}\\n\\t * @param {String} [options.state] value used to mitigate XSRF attacks. {@link https://auth0.com/docs/protocols/oauth2/oauth-state}\\n\\t * @param {String} [options.nonce] value used to mitigate replay attacks when using Implicit Grant. {@link https://auth0.com/docs/api-auth/tutorials/nonce}\\n\\t * @param {String} [options.scope] scopes to be requested during Auth. e.g. `openid email`\\n\\t * @param {String} [options.audience] identifier of the resource server who will consume the access token issued after Auth\\n\\t * @param {Boolean} [options.owp] determines if Auth0 should render the relay page or not and the caller is responsible of handling the response.\\n\\t * @param {authorizeCallback} cb\\n\\t * @see {@link https://auth0.com/docs/api/authentication#authorize-client}\\n\\t */\\n\\tPopup.prototype.authorize = function(options, cb) {\\n\\t  var popup;\\n\\t  var url;\\n\\t  var relayUrl;\\n\\t  var popOpts = {};\\n\\t\\n\\t  var pluginHandler = this.baseOptions.plugins.get('popup.authorize');\\n\\t\\n\\t  var params = objectHelper\\n\\t    .merge(this.baseOptions, [\\n\\t      'clientID',\\n\\t      'scope',\\n\\t      'domain',\\n\\t      'audience',\\n\\t      'responseType',\\n\\t      'redirectUri',\\n\\t      '_csrf',\\n\\t      'state',\\n\\t      '_intstate',\\n\\t      'nonce'\\n\\t    ])\\n\\t    .with(objectHelper.blacklist(options, ['popupHandler']));\\n\\t\\n\\t  assert.check(\\n\\t    params,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      responseType: { type: 'string', message: 'responseType option is required' }\\n\\t    }\\n\\t  );\\n\\t\\n\\t  // the relay page should not be necesary as long it happens in the same domain\\n\\t  // (a redirectUri shoul be provided). It is necesary when using OWP\\n\\t  relayUrl = urljoin(this.baseOptions.rootUrl, 'relay.html');\\n\\t\\n\\t  // if a owp is enabled, it should use the owp flag\\n\\t  if (options.owp) {\\n\\t    // used by server to render the relay page instead of sending the chunk in the\\n\\t    // url to the callback\\n\\t    params.owp = true;\\n\\t  } else {\\n\\t    popOpts.origin = urlHelper.extractOrigin(params.redirectUri);\\n\\t    relayUrl = params.redirectUri;\\n\\t  }\\n\\t\\n\\t  if (options.popupOptions) {\\n\\t    popOpts.popupOptions = objectHelper.pick(options.popupOptions, ['width', 'height']);\\n\\t  }\\n\\t\\n\\t  if (pluginHandler) {\\n\\t    params = pluginHandler.processParams(params);\\n\\t  }\\n\\t\\n\\t  params = this.transactionManager.process(params);\\n\\t\\n\\t  delete params.domain;\\n\\t\\n\\t  url = this.client.buildAuthorizeUrl(params);\\n\\t\\n\\t  popup = this.getPopupHandler(options);\\n\\t\\n\\t  return popup.load(url, relayUrl, popOpts, responseHandler(cb));\\n\\t};\\n\\t\\n\\t/**\\n\\t * Performs authentication with username/email and password with a database connection inside a new window\\n\\t *\\n\\t * This method is not compatible with API Auth so if you need to fetch API tokens with audience\\n\\t * you should use {@link authorize} or {@link login}.\\n\\t *\\n\\t * @method loginWithCredentials\\n\\t * @param {Object} options\\n\\t * @param {String} [options.redirectUri] url that the Auth0 will redirect after Auth with the Authorization Response\\n\\t * @param {String} [options.responseType] type of the response used. It can be any of the values `code` and `token`\\n\\t * @param {String} [options.responseMode] how the AuthN response is encoded and redirected back to the client. Supported values are `query` and `fragment`\\n\\t * @param {String} [options.scope] scopes to be requested during AuthN. e.g. `openid email`\\n\\t * @param {credentialsCallback} cb\\n\\t */\\n\\tPopup.prototype.loginWithCredentials = function(options, cb) {\\n\\t  var params;\\n\\t  var popup;\\n\\t  var url;\\n\\t  var relayUrl;\\n\\t\\n\\t  /* eslint-disable */\\n\\t  assert.check(\\n\\t    options,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      clientID: { optional: true, type: 'string', message: 'clientID option is required' },\\n\\t      redirectUri: { optional: true, type: 'string', message: 'redirectUri option is required' },\\n\\t      responseType: { optional: true, type: 'string', message: 'responseType option is required' },\\n\\t      scope: { optional: true, type: 'string', message: 'scope option is required' },\\n\\t      audience: { optional: true, type: 'string', message: 'audience option is required' }\\n\\t    }\\n\\t  );\\n\\t  /* eslint-enable */\\n\\t\\n\\t  popup = this.getPopupHandler(options);\\n\\t\\n\\t  options = objectHelper\\n\\t    .merge(this.baseOptions, [\\n\\t      'clientID',\\n\\t      'scope',\\n\\t      'domain',\\n\\t      'audience',\\n\\t      '_csrf',\\n\\t      'state',\\n\\t      '_intstate',\\n\\t      'nonce'\\n\\t    ])\\n\\t    .with(objectHelper.blacklist(options, ['popupHandler']));\\n\\t\\n\\t  params = objectHelper.pick(options, ['clientID', 'domain']);\\n\\t  params.options = objectHelper.toSnakeCase(\\n\\t    objectHelper.pick(options, ['password', 'connection', 'state', 'scope', '_csrf', 'device'])\\n\\t  );\\n\\t  params.options.username = options.username || options.email;\\n\\t\\n\\t  url = urljoin(this.baseOptions.rootUrl, 'sso_dbconnection_popup', options.clientID);\\n\\t  relayUrl = urljoin(this.baseOptions.rootUrl, 'relay.html');\\n\\t\\n\\t  return popup.load(url, relayUrl, { params: params }, responseHandler(cb));\\n\\t};\\n\\t\\n\\t/**\\n\\t * Verifies the passwordless TOTP and redirects to finish the passwordless transaction\\n\\t *\\n\\t * @method passwordlessVerify\\n\\t * @param {Object} options\\n\\t * @param {String} options.type `sms` or `email`\\n\\t * @param {String} options.phoneNumber only if type = sms\\n\\t * @param {String} options.email only if type = email\\n\\t * @param {String} options.connection the connection name\\n\\t * @param {String} options.verificationCode the TOTP code\\n\\t * @param {Function} cb\\n\\t */\\n\\tPopup.prototype.passwordlessVerify = function(options, cb) {\\n\\t  var _this = this;\\n\\t  return this.client.passwordless.verify(\\n\\t    objectHelper.blacklist(options, ['popupHandler']),\\n\\t    function(err) {\\n\\t      if (err) {\\n\\t        return cb(err);\\n\\t      }\\n\\t\\n\\t      options.username = options.phoneNumber || options.email;\\n\\t      options.password = options.verificationCode;\\n\\t\\n\\t      delete options.email;\\n\\t      delete options.phoneNumber;\\n\\t      delete options.verificationCode;\\n\\t      delete options.type;\\n\\t\\n\\t      _this.client.loginWithResourceOwner(options, cb);\\n\\t    }\\n\\t  );\\n\\t};\\n\\t\\n\\t/**\\n\\t * Signs up a new user and automatically logs the user in after the signup.\\n\\t *\\n\\t * This method is not compatible with API Auth so if you need to fetch API tokens with audience\\n\\t * you should use {@link authorize} or {@link signupAndAuthorize}.\\n\\t *\\n\\t * @method signupAndLogin\\n\\t * @param {Object} options\\n\\t * @param {String} options.email user email address\\n\\t * @param {String} options.password user password\\n\\t * @param {String} options.connection name of the connection where the user will be created\\n\\t * @param {credentialsCallback} cb\\n\\t */\\n\\tPopup.prototype.signupAndLogin = function(options, cb) {\\n\\t  var _this = this;\\n\\t\\n\\t  // Preload popup to avoid the browser to block it since the login happens later\\n\\t  var popupHandler = this.getPopupHandler(options, true);\\n\\t  options.popupHandler = popupHandler;\\n\\t\\n\\t  return this.client.dbConnection.signup(\\n\\t    objectHelper.blacklist(options, ['popupHandler']),\\n\\t    function(err) {\\n\\t      if (err) {\\n\\t        if (popupHandler._current_popup) {\\n\\t          popupHandler._current_popup.kill();\\n\\t        }\\n\\t        return cb(err);\\n\\t      }\\n\\t      _this.loginWithCredentials(options, cb);\\n\\t    }\\n\\t  );\\n\\t};\\n\\t\\n\\tmodule.exports = Popup;\\n\\n\\n/***/ },\\n/* 59 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar UsernamePassword = __webpack_require__(61);\\n\\tvar objectHelper = __webpack_require__(2);\\n\\tvar Warn = __webpack_require__(11);\\n\\tvar assert = __webpack_require__(4);\\n\\t\\n\\tfunction Redirect(client, options) {\\n\\t  this.baseOptions = options;\\n\\t  this.client = client;\\n\\t\\n\\t  this.warn = new Warn({\\n\\t    disableWarnings: !!options._disableDeprecationWarnings\\n\\t  });\\n\\t}\\n\\t\\n\\t/**\\n\\t * @callback credentialsCallback\\n\\t * @param {Error} [err] error returned by Auth0 with the reason of the Auth failure\\n\\t * @param {Object} [result] result of the AuthN request\\n\\t * @param {String} result.accessToken token that can be used with {@link userinfo}\\n\\t * @param {String} [result.idToken] token that identifies the user\\n\\t * @param {String} [result.refreshToken] token that can be used to get new access tokens from Auth0. Note that not all clients can request them or the resource server might not allow them.\\n\\t */\\n\\t\\n\\t/**\\n\\t * Performs authentication with username/email and password with a database connection\\n\\t *\\n\\t * This method is not compatible with API Auth so if you need to fetch API tokens with audience\\n\\t * you should use {@link authorize} or {@link login}.\\n\\t *\\n\\t * @method loginWithCredentials\\n\\t * @param {Object} options\\n\\t * @param {String} [options.redirectUri] url that the Auth0 will redirect after Auth with the Authorization Response\\n\\t * @param {String} [options.responseType] type of the response used. It can be any of the values `code` and `token`\\n\\t * @param {String} [options.responseMode] how the AuthN response is encoded and redirected back to the client. Supported values are `query` and `fragment`\\n\\t * @param {String} [options.scope] scopes to be requested during AuthN. e.g. `openid email`\\n\\t * @param {credentialsCallback} cb\\n\\t */\\n\\tRedirect.prototype.loginWithCredentials = function(options, cb) {\\n\\t  var usernamePassword;\\n\\t\\n\\t  var params = objectHelper\\n\\t    .merge(this.baseOptions, [\\n\\t      'clientID',\\n\\t      'redirectUri',\\n\\t      'tenant',\\n\\t      'responseType',\\n\\t      'responseMode',\\n\\t      'scope',\\n\\t      'audience',\\n\\t      '_csrf',\\n\\t      'state',\\n\\t      '_intstate',\\n\\t      'nonce'\\n\\t    ])\\n\\t    .with(options);\\n\\t\\n\\t  assert.check(\\n\\t    params,\\n\\t    { type: 'object', message: 'options parameter is not valid' },\\n\\t    {\\n\\t      responseType: { type: 'string', message: 'responseType option is required' }\\n\\t    }\\n\\t  );\\n\\t\\n\\t  usernamePassword = new UsernamePassword(this.baseOptions);\\n\\t  return usernamePassword.login(params, function(err, data) {\\n\\t    if (err) {\\n\\t      return cb(err);\\n\\t    }\\n\\t    return usernamePassword.callback(data);\\n\\t  });\\n\\t};\\n\\t\\n\\t/**\\n\\t * Signs up a new user and automatically logs the user in after the signup.\\n\\t *\\n\\t * @method signupAndLogin\\n\\t * @param {Object} options\\n\\t * @param {String} options.email user email address\\n\\t * @param {String} options.password user password\\n\\t * @param {String} options.connection name of the connection where the user will be created\\n\\t * @param {credentialsCallback} cb\\n\\t */\\n\\tRedirect.prototype.signupAndLogin = function(options, cb) {\\n\\t  var _this = this;\\n\\t  return this.client.dbConnection.signup(options, function(err) {\\n\\t    if (err) {\\n\\t      return cb(err);\\n\\t    }\\n\\t    return _this.loginWithCredentials(options, cb);\\n\\t  });\\n\\t};\\n\\t\\n\\tmodule.exports = Redirect;\\n\\n\\n/***/ },\\n/* 60 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar IframeHandler = __webpack_require__(43);\\n\\t\\n\\tfunction SilentAuthenticationHandler(options) {\\n\\t  this.authenticationUrl = options.authenticationUrl;\\n\\t  this.timeout = options.timeout || 60 * 1000;\\n\\t  this.handler = null;\\n\\t  this.postMessageDataType = options.postMessageDataType || false;\\n\\t}\\n\\t\\n\\tSilentAuthenticationHandler.create = function(options) {\\n\\t  return new SilentAuthenticationHandler(options);\\n\\t};\\n\\t\\n\\tSilentAuthenticationHandler.prototype.login = function(usePostMessage, callback) {\\n\\t  this.handler = new IframeHandler({\\n\\t    auth0: this.auth0,\\n\\t    url: this.authenticationUrl,\\n\\t    eventListenerType: usePostMessage ? 'message' : 'load',\\n\\t    callback: this.getCallbackHandler(callback, usePostMessage),\\n\\t    timeout: this.timeout,\\n\\t    eventValidator: this.getEventValidator(),\\n\\t    timeoutCallback: function() {\\n\\t      callback(null, '#error=timeout&error_description=Timeout+during+authentication+renew.');\\n\\t    },\\n\\t    usePostMessage: usePostMessage || false\\n\\t  });\\n\\t\\n\\t  this.handler.init();\\n\\t};\\n\\t\\n\\tSilentAuthenticationHandler.prototype.getEventValidator = function() {\\n\\t  var _this = this;\\n\\t  return {\\n\\t    isValid: function(eventData) {\\n\\t      switch (eventData.event.type) {\\n\\t        case 'message':\\n\\t          // Default behaviour, return all message events.\\n\\t          if (_this.postMessageDataType === false) {\\n\\t            return true;\\n\\t          }\\n\\t\\n\\t          return (\\n\\t            eventData.event.data.type && eventData.event.data.type === _this.postMessageDataType\\n\\t          );\\n\\t\\n\\t        case 'load': // Fall through to default\\n\\t        default:\\n\\t          return true;\\n\\t      }\\n\\t    }\\n\\t  };\\n\\t};\\n\\t\\n\\tSilentAuthenticationHandler.prototype.getCallbackHandler = function(callback, usePostMessage) {\\n\\t  return function(eventData) {\\n\\t    var callbackValue;\\n\\t    if (!usePostMessage) {\\n\\t      callbackValue = eventData.sourceObject.contentWindow.location.hash;\\n\\t    } else if (typeof eventData.event.data === 'object' && eventData.event.data.hash) {\\n\\t      callbackValue = eventData.event.data.hash;\\n\\t    } else {\\n\\t      callbackValue = eventData.event.data;\\n\\t    }\\n\\t    callback(null, callbackValue);\\n\\t  };\\n\\t};\\n\\t\\n\\tmodule.exports = SilentAuthenticationHandler;\\n\\n\\n/***/ },\\n/* 61 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n\\tvar urljoin = __webpack_require__(1);\\n\\t\\n\\tvar objectHelper = __webpack_require__(2);\\n\\tvar RequestBuilder = __webpack_require__(10);\\n\\tvar responseHandler = __webpack_require__(6);\\n\\tvar windowHelper = __webpack_require__(3);\\n\\t\\n\\tfunction UsernamePassword(options) {\\n\\t  this.baseOptions = options;\\n\\t  this.request = new RequestBuilder(options);\\n\\t}\\n\\t\\n\\tUsernamePassword.prototype.login = function(options, cb) {\\n\\t  var url;\\n\\t  var body;\\n\\t\\n\\t  url = urljoin(this.baseOptions.rootUrl, 'usernamepassword', 'login');\\n\\t\\n\\t  options.username = options.username || options.email; // eslint-disable-line\\n\\t\\n\\t  options = objectHelper.blacklist(options, ['email']); // eslint-disable-line\\n\\t\\n\\t  body = objectHelper\\n\\t    .merge(this.baseOptions, [\\n\\t      'clientID',\\n\\t      'redirectUri',\\n\\t      'tenant',\\n\\t      'responseType',\\n\\t      'responseMode',\\n\\t      'scope',\\n\\t      'audience'\\n\\t    ])\\n\\t    .with(options);\\n\\t\\n\\t  body = objectHelper.toSnakeCase(body, ['auth0Client']);\\n\\t\\n\\t  return this.request.post(url).send(body).end(responseHandler(cb));\\n\\t};\\n\\t\\n\\tUsernamePassword.prototype.callback = function(formHtml) {\\n\\t  var div;\\n\\t  var form;\\n\\t  var _document = windowHelper.getDocument();\\n\\t\\n\\t  div = _document.createElement('div');\\n\\t  div.innerHTML = formHtml;\\n\\t  form = _document.body.appendChild(div).children[0];\\n\\t\\n\\t  form.submit();\\n\\t};\\n\\t\\n\\tmodule.exports = UsernamePassword;\\n\\n\\n/***/ }\\n/******/ ])\\n});\\n;\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/devon/Desktop/frontEnd/frontEnd/node_modules/raw-loader!/home/devon/Desktop/frontEnd/frontEnd/node_modules/auth0-js/build/auth0.js\n// module id = ../../../../raw-loader/index.js!../../../../auth0-js/build/auth0.js\n// module chunks = scripts","module.exports = \"/*!\\n * Chart.js\\n * http://chartjs.org/\\n * Version: 2.5.0\\n *\\n * Copyright 2017 Nick Downie\\n * Released under the MIT license\\n * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md\\n */\\n(function(f){if(typeof exports===\\\"object\\\"&&typeof module!==\\\"undefined\\\"){module.exports=f()}else if(typeof define===\\\"function\\\"&&define.amd){define([],f)}else{var g;if(typeof window!==\\\"undefined\\\"){g=window}else if(typeof global!==\\\"undefined\\\"){g=global}else if(typeof self!==\\\"undefined\\\"){g=self}else{g=this}g.Chart = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\\"function\\\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\\\"Cannot find module '\\\"+o+\\\"'\\\");throw f.code=\\\"MODULE_NOT_FOUND\\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\\"function\\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\\n\\n},{}],2:[function(require,module,exports){\\n/* MIT license */\\r\\nvar colorNames = require(6);\\r\\n\\r\\nmodule.exports = {\\r\\n   getRgba: getRgba,\\r\\n   getHsla: getHsla,\\r\\n   getRgb: getRgb,\\r\\n   getHsl: getHsl,\\r\\n   getHwb: getHwb,\\r\\n   getAlpha: getAlpha,\\r\\n\\r\\n   hexString: hexString,\\r\\n   rgbString: rgbString,\\r\\n   rgbaString: rgbaString,\\r\\n   percentString: percentString,\\r\\n   percentaString: percentaString,\\r\\n   hslString: hslString,\\r\\n   hslaString: hslaString,\\r\\n   hwbString: hwbString,\\r\\n   keyword: keyword\\r\\n}\\r\\n\\r\\nfunction getRgba(string) {\\r\\n   if (!string) {\\r\\n      return;\\r\\n   }\\r\\n   var abbr =  /^#([a-fA-F0-9]{3})$/,\\r\\n       hex =  /^#([a-fA-F0-9]{6})$/,\\r\\n       rgba = /^rgba?\\\\(\\\\s*([+-]?\\\\d+)\\\\s*,\\\\s*([+-]?\\\\d+)\\\\s*,\\\\s*([+-]?\\\\d+)\\\\s*(?:,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\s*)?\\\\)$/,\\r\\n       per = /^rgba?\\\\(\\\\s*([+-]?[\\\\d\\\\.]+)\\\\%\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\%\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\%\\\\s*(?:,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\s*)?\\\\)$/,\\r\\n       keyword = /(\\\\w+)/;\\r\\n\\r\\n   var rgb = [0, 0, 0],\\r\\n       a = 1,\\r\\n       match = string.match(abbr);\\r\\n   if (match) {\\r\\n      match = match[1];\\r\\n      for (var i = 0; i < rgb.length; i++) {\\r\\n         rgb[i] = parseInt(match[i] + match[i], 16);\\r\\n      }\\r\\n   }\\r\\n   else if (match = string.match(hex)) {\\r\\n      match = match[1];\\r\\n      for (var i = 0; i < rgb.length; i++) {\\r\\n         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\\r\\n      }\\r\\n   }\\r\\n   else if (match = string.match(rgba)) {\\r\\n      for (var i = 0; i < rgb.length; i++) {\\r\\n         rgb[i] = parseInt(match[i + 1]);\\r\\n      }\\r\\n      a = parseFloat(match[4]);\\r\\n   }\\r\\n   else if (match = string.match(per)) {\\r\\n      for (var i = 0; i < rgb.length; i++) {\\r\\n         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\\r\\n      }\\r\\n      a = parseFloat(match[4]);\\r\\n   }\\r\\n   else if (match = string.match(keyword)) {\\r\\n      if (match[1] == \\\"transparent\\\") {\\r\\n         return [0, 0, 0, 0];\\r\\n      }\\r\\n      rgb = colorNames[match[1]];\\r\\n      if (!rgb) {\\r\\n         return;\\r\\n      }\\r\\n   }\\r\\n\\r\\n   for (var i = 0; i < rgb.length; i++) {\\r\\n      rgb[i] = scale(rgb[i], 0, 255);\\r\\n   }\\r\\n   if (!a && a != 0) {\\r\\n      a = 1;\\r\\n   }\\r\\n   else {\\r\\n      a = scale(a, 0, 1);\\r\\n   }\\r\\n   rgb[3] = a;\\r\\n   return rgb;\\r\\n}\\r\\n\\r\\nfunction getHsla(string) {\\r\\n   if (!string) {\\r\\n      return;\\r\\n   }\\r\\n   var hsl = /^hsla?\\\\(\\\\s*([+-]?\\\\d+)(?:deg)?\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)%\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)%\\\\s*(?:,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\s*)?\\\\)/;\\r\\n   var match = string.match(hsl);\\r\\n   if (match) {\\r\\n      var alpha = parseFloat(match[4]);\\r\\n      var h = scale(parseInt(match[1]), 0, 360),\\r\\n          s = scale(parseFloat(match[2]), 0, 100),\\r\\n          l = scale(parseFloat(match[3]), 0, 100),\\r\\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\\r\\n      return [h, s, l, a];\\r\\n   }\\r\\n}\\r\\n\\r\\nfunction getHwb(string) {\\r\\n   if (!string) {\\r\\n      return;\\r\\n   }\\r\\n   var hwb = /^hwb\\\\(\\\\s*([+-]?\\\\d+)(?:deg)?\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)%\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)%\\\\s*(?:,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\s*)?\\\\)/;\\r\\n   var match = string.match(hwb);\\r\\n   if (match) {\\r\\n    var alpha = parseFloat(match[4]);\\r\\n      var h = scale(parseInt(match[1]), 0, 360),\\r\\n          w = scale(parseFloat(match[2]), 0, 100),\\r\\n          b = scale(parseFloat(match[3]), 0, 100),\\r\\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\\r\\n      return [h, w, b, a];\\r\\n   }\\r\\n}\\r\\n\\r\\nfunction getRgb(string) {\\r\\n   var rgba = getRgba(string);\\r\\n   return rgba && rgba.slice(0, 3);\\r\\n}\\r\\n\\r\\nfunction getHsl(string) {\\r\\n  var hsla = getHsla(string);\\r\\n  return hsla && hsla.slice(0, 3);\\r\\n}\\r\\n\\r\\nfunction getAlpha(string) {\\r\\n   var vals = getRgba(string);\\r\\n   if (vals) {\\r\\n      return vals[3];\\r\\n   }\\r\\n   else if (vals = getHsla(string)) {\\r\\n      return vals[3];\\r\\n   }\\r\\n   else if (vals = getHwb(string)) {\\r\\n      return vals[3];\\r\\n   }\\r\\n}\\r\\n\\r\\n// generators\\r\\nfunction hexString(rgb) {\\r\\n   return \\\"#\\\" + hexDouble(rgb[0]) + hexDouble(rgb[1])\\r\\n              + hexDouble(rgb[2]);\\r\\n}\\r\\n\\r\\nfunction rgbString(rgba, alpha) {\\r\\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\\r\\n      return rgbaString(rgba, alpha);\\r\\n   }\\r\\n   return \\\"rgb(\\\" + rgba[0] + \\\", \\\" + rgba[1] + \\\", \\\" + rgba[2] + \\\")\\\";\\r\\n}\\r\\n\\r\\nfunction rgbaString(rgba, alpha) {\\r\\n   if (alpha === undefined) {\\r\\n      alpha = (rgba[3] !== undefined ? rgba[3] : 1);\\r\\n   }\\r\\n   return \\\"rgba(\\\" + rgba[0] + \\\", \\\" + rgba[1] + \\\", \\\" + rgba[2]\\r\\n           + \\\", \\\" + alpha + \\\")\\\";\\r\\n}\\r\\n\\r\\nfunction percentString(rgba, alpha) {\\r\\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\\r\\n      return percentaString(rgba, alpha);\\r\\n   }\\r\\n   var r = Math.round(rgba[0]/255 * 100),\\r\\n       g = Math.round(rgba[1]/255 * 100),\\r\\n       b = Math.round(rgba[2]/255 * 100);\\r\\n\\r\\n   return \\\"rgb(\\\" + r + \\\"%, \\\" + g + \\\"%, \\\" + b + \\\"%)\\\";\\r\\n}\\r\\n\\r\\nfunction percentaString(rgba, alpha) {\\r\\n   var r = Math.round(rgba[0]/255 * 100),\\r\\n       g = Math.round(rgba[1]/255 * 100),\\r\\n       b = Math.round(rgba[2]/255 * 100);\\r\\n   return \\\"rgba(\\\" + r + \\\"%, \\\" + g + \\\"%, \\\" + b + \\\"%, \\\" + (alpha || rgba[3] || 1) + \\\")\\\";\\r\\n}\\r\\n\\r\\nfunction hslString(hsla, alpha) {\\r\\n   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\\r\\n      return hslaString(hsla, alpha);\\r\\n   }\\r\\n   return \\\"hsl(\\\" + hsla[0] + \\\", \\\" + hsla[1] + \\\"%, \\\" + hsla[2] + \\\"%)\\\";\\r\\n}\\r\\n\\r\\nfunction hslaString(hsla, alpha) {\\r\\n   if (alpha === undefined) {\\r\\n      alpha = (hsla[3] !== undefined ? hsla[3] : 1);\\r\\n   }\\r\\n   return \\\"hsla(\\\" + hsla[0] + \\\", \\\" + hsla[1] + \\\"%, \\\" + hsla[2] + \\\"%, \\\"\\r\\n           + alpha + \\\")\\\";\\r\\n}\\r\\n\\r\\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\\r\\n// (hwb have alpha optional & 1 is default value)\\r\\nfunction hwbString(hwb, alpha) {\\r\\n   if (alpha === undefined) {\\r\\n      alpha = (hwb[3] !== undefined ? hwb[3] : 1);\\r\\n   }\\r\\n   return \\\"hwb(\\\" + hwb[0] + \\\", \\\" + hwb[1] + \\\"%, \\\" + hwb[2] + \\\"%\\\"\\r\\n           + (alpha !== undefined && alpha !== 1 ? \\\", \\\" + alpha : \\\"\\\") + \\\")\\\";\\r\\n}\\r\\n\\r\\nfunction keyword(rgb) {\\r\\n  return reverseNames[rgb.slice(0, 3)];\\r\\n}\\r\\n\\r\\n// helpers\\r\\nfunction scale(num, min, max) {\\r\\n   return Math.min(Math.max(min, num), max);\\r\\n}\\r\\n\\r\\nfunction hexDouble(num) {\\r\\n  var str = num.toString(16).toUpperCase();\\r\\n  return (str.length < 2) ? \\\"0\\\" + str : str;\\r\\n}\\r\\n\\r\\n\\r\\n//create a list of reverse color names\\r\\nvar reverseNames = {};\\r\\nfor (var name in colorNames) {\\r\\n   reverseNames[colorNames[name]] = name;\\r\\n}\\r\\n\\n},{\\\"6\\\":6}],3:[function(require,module,exports){\\n/* MIT license */\\r\\nvar convert = require(5);\\r\\nvar string = require(2);\\r\\n\\r\\nvar Color = function (obj) {\\r\\n\\tif (obj instanceof Color) {\\r\\n\\t\\treturn obj;\\r\\n\\t}\\r\\n\\tif (!(this instanceof Color)) {\\r\\n\\t\\treturn new Color(obj);\\r\\n\\t}\\r\\n\\r\\n\\tthis.values = {\\r\\n\\t\\trgb: [0, 0, 0],\\r\\n\\t\\thsl: [0, 0, 0],\\r\\n\\t\\thsv: [0, 0, 0],\\r\\n\\t\\thwb: [0, 0, 0],\\r\\n\\t\\tcmyk: [0, 0, 0, 0],\\r\\n\\t\\talpha: 1\\r\\n\\t};\\r\\n\\r\\n\\t// parse Color() argument\\r\\n\\tvar vals;\\r\\n\\tif (typeof obj === 'string') {\\r\\n\\t\\tvals = string.getRgba(obj);\\r\\n\\t\\tif (vals) {\\r\\n\\t\\t\\tthis.setValues('rgb', vals);\\r\\n\\t\\t} else if (vals = string.getHsla(obj)) {\\r\\n\\t\\t\\tthis.setValues('hsl', vals);\\r\\n\\t\\t} else if (vals = string.getHwb(obj)) {\\r\\n\\t\\t\\tthis.setValues('hwb', vals);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthrow new Error('Unable to parse color from string \\\"' + obj + '\\\"');\\r\\n\\t\\t}\\r\\n\\t} else if (typeof obj === 'object') {\\r\\n\\t\\tvals = obj;\\r\\n\\t\\tif (vals.r !== undefined || vals.red !== undefined) {\\r\\n\\t\\t\\tthis.setValues('rgb', vals);\\r\\n\\t\\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\\r\\n\\t\\t\\tthis.setValues('hsl', vals);\\r\\n\\t\\t} else if (vals.v !== undefined || vals.value !== undefined) {\\r\\n\\t\\t\\tthis.setValues('hsv', vals);\\r\\n\\t\\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\\r\\n\\t\\t\\tthis.setValues('hwb', vals);\\r\\n\\t\\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\\r\\n\\t\\t\\tthis.setValues('cmyk', vals);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthrow new Error('Unable to parse color from object ' + JSON.stringify(obj));\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\nColor.prototype = {\\r\\n\\trgb: function () {\\r\\n\\t\\treturn this.setSpace('rgb', arguments);\\r\\n\\t},\\r\\n\\thsl: function () {\\r\\n\\t\\treturn this.setSpace('hsl', arguments);\\r\\n\\t},\\r\\n\\thsv: function () {\\r\\n\\t\\treturn this.setSpace('hsv', arguments);\\r\\n\\t},\\r\\n\\thwb: function () {\\r\\n\\t\\treturn this.setSpace('hwb', arguments);\\r\\n\\t},\\r\\n\\tcmyk: function () {\\r\\n\\t\\treturn this.setSpace('cmyk', arguments);\\r\\n\\t},\\r\\n\\r\\n\\trgbArray: function () {\\r\\n\\t\\treturn this.values.rgb;\\r\\n\\t},\\r\\n\\thslArray: function () {\\r\\n\\t\\treturn this.values.hsl;\\r\\n\\t},\\r\\n\\thsvArray: function () {\\r\\n\\t\\treturn this.values.hsv;\\r\\n\\t},\\r\\n\\thwbArray: function () {\\r\\n\\t\\tvar values = this.values;\\r\\n\\t\\tif (values.alpha !== 1) {\\r\\n\\t\\t\\treturn values.hwb.concat([values.alpha]);\\r\\n\\t\\t}\\r\\n\\t\\treturn values.hwb;\\r\\n\\t},\\r\\n\\tcmykArray: function () {\\r\\n\\t\\treturn this.values.cmyk;\\r\\n\\t},\\r\\n\\trgbaArray: function () {\\r\\n\\t\\tvar values = this.values;\\r\\n\\t\\treturn values.rgb.concat([values.alpha]);\\r\\n\\t},\\r\\n\\thslaArray: function () {\\r\\n\\t\\tvar values = this.values;\\r\\n\\t\\treturn values.hsl.concat([values.alpha]);\\r\\n\\t},\\r\\n\\talpha: function (val) {\\r\\n\\t\\tif (val === undefined) {\\r\\n\\t\\t\\treturn this.values.alpha;\\r\\n\\t\\t}\\r\\n\\t\\tthis.setValues('alpha', val);\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\tred: function (val) {\\r\\n\\t\\treturn this.setChannel('rgb', 0, val);\\r\\n\\t},\\r\\n\\tgreen: function (val) {\\r\\n\\t\\treturn this.setChannel('rgb', 1, val);\\r\\n\\t},\\r\\n\\tblue: function (val) {\\r\\n\\t\\treturn this.setChannel('rgb', 2, val);\\r\\n\\t},\\r\\n\\thue: function (val) {\\r\\n\\t\\tif (val) {\\r\\n\\t\\t\\tval %= 360;\\r\\n\\t\\t\\tval = val < 0 ? 360 + val : val;\\r\\n\\t\\t}\\r\\n\\t\\treturn this.setChannel('hsl', 0, val);\\r\\n\\t},\\r\\n\\tsaturation: function (val) {\\r\\n\\t\\treturn this.setChannel('hsl', 1, val);\\r\\n\\t},\\r\\n\\tlightness: function (val) {\\r\\n\\t\\treturn this.setChannel('hsl', 2, val);\\r\\n\\t},\\r\\n\\tsaturationv: function (val) {\\r\\n\\t\\treturn this.setChannel('hsv', 1, val);\\r\\n\\t},\\r\\n\\twhiteness: function (val) {\\r\\n\\t\\treturn this.setChannel('hwb', 1, val);\\r\\n\\t},\\r\\n\\tblackness: function (val) {\\r\\n\\t\\treturn this.setChannel('hwb', 2, val);\\r\\n\\t},\\r\\n\\tvalue: function (val) {\\r\\n\\t\\treturn this.setChannel('hsv', 2, val);\\r\\n\\t},\\r\\n\\tcyan: function (val) {\\r\\n\\t\\treturn this.setChannel('cmyk', 0, val);\\r\\n\\t},\\r\\n\\tmagenta: function (val) {\\r\\n\\t\\treturn this.setChannel('cmyk', 1, val);\\r\\n\\t},\\r\\n\\tyellow: function (val) {\\r\\n\\t\\treturn this.setChannel('cmyk', 2, val);\\r\\n\\t},\\r\\n\\tblack: function (val) {\\r\\n\\t\\treturn this.setChannel('cmyk', 3, val);\\r\\n\\t},\\r\\n\\r\\n\\thexString: function () {\\r\\n\\t\\treturn string.hexString(this.values.rgb);\\r\\n\\t},\\r\\n\\trgbString: function () {\\r\\n\\t\\treturn string.rgbString(this.values.rgb, this.values.alpha);\\r\\n\\t},\\r\\n\\trgbaString: function () {\\r\\n\\t\\treturn string.rgbaString(this.values.rgb, this.values.alpha);\\r\\n\\t},\\r\\n\\tpercentString: function () {\\r\\n\\t\\treturn string.percentString(this.values.rgb, this.values.alpha);\\r\\n\\t},\\r\\n\\thslString: function () {\\r\\n\\t\\treturn string.hslString(this.values.hsl, this.values.alpha);\\r\\n\\t},\\r\\n\\thslaString: function () {\\r\\n\\t\\treturn string.hslaString(this.values.hsl, this.values.alpha);\\r\\n\\t},\\r\\n\\thwbString: function () {\\r\\n\\t\\treturn string.hwbString(this.values.hwb, this.values.alpha);\\r\\n\\t},\\r\\n\\tkeyword: function () {\\r\\n\\t\\treturn string.keyword(this.values.rgb, this.values.alpha);\\r\\n\\t},\\r\\n\\r\\n\\trgbNumber: function () {\\r\\n\\t\\tvar rgb = this.values.rgb;\\r\\n\\t\\treturn (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\\r\\n\\t},\\r\\n\\r\\n\\tluminosity: function () {\\r\\n\\t\\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\\r\\n\\t\\tvar rgb = this.values.rgb;\\r\\n\\t\\tvar lum = [];\\r\\n\\t\\tfor (var i = 0; i < rgb.length; i++) {\\r\\n\\t\\t\\tvar chan = rgb[i] / 255;\\r\\n\\t\\t\\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\\r\\n\\t\\t}\\r\\n\\t\\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\\r\\n\\t},\\r\\n\\r\\n\\tcontrast: function (color2) {\\r\\n\\t\\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\\r\\n\\t\\tvar lum1 = this.luminosity();\\r\\n\\t\\tvar lum2 = color2.luminosity();\\r\\n\\t\\tif (lum1 > lum2) {\\r\\n\\t\\t\\treturn (lum1 + 0.05) / (lum2 + 0.05);\\r\\n\\t\\t}\\r\\n\\t\\treturn (lum2 + 0.05) / (lum1 + 0.05);\\r\\n\\t},\\r\\n\\r\\n\\tlevel: function (color2) {\\r\\n\\t\\tvar contrastRatio = this.contrast(color2);\\r\\n\\t\\tif (contrastRatio >= 7.1) {\\r\\n\\t\\t\\treturn 'AAA';\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn (contrastRatio >= 4.5) ? 'AA' : '';\\r\\n\\t},\\r\\n\\r\\n\\tdark: function () {\\r\\n\\t\\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\\r\\n\\t\\tvar rgb = this.values.rgb;\\r\\n\\t\\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\\r\\n\\t\\treturn yiq < 128;\\r\\n\\t},\\r\\n\\r\\n\\tlight: function () {\\r\\n\\t\\treturn !this.dark();\\r\\n\\t},\\r\\n\\r\\n\\tnegate: function () {\\r\\n\\t\\tvar rgb = [];\\r\\n\\t\\tfor (var i = 0; i < 3; i++) {\\r\\n\\t\\t\\trgb[i] = 255 - this.values.rgb[i];\\r\\n\\t\\t}\\r\\n\\t\\tthis.setValues('rgb', rgb);\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\tlighten: function (ratio) {\\r\\n\\t\\tvar hsl = this.values.hsl;\\r\\n\\t\\thsl[2] += hsl[2] * ratio;\\r\\n\\t\\tthis.setValues('hsl', hsl);\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\tdarken: function (ratio) {\\r\\n\\t\\tvar hsl = this.values.hsl;\\r\\n\\t\\thsl[2] -= hsl[2] * ratio;\\r\\n\\t\\tthis.setValues('hsl', hsl);\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\tsaturate: function (ratio) {\\r\\n\\t\\tvar hsl = this.values.hsl;\\r\\n\\t\\thsl[1] += hsl[1] * ratio;\\r\\n\\t\\tthis.setValues('hsl', hsl);\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\tdesaturate: function (ratio) {\\r\\n\\t\\tvar hsl = this.values.hsl;\\r\\n\\t\\thsl[1] -= hsl[1] * ratio;\\r\\n\\t\\tthis.setValues('hsl', hsl);\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\twhiten: function (ratio) {\\r\\n\\t\\tvar hwb = this.values.hwb;\\r\\n\\t\\thwb[1] += hwb[1] * ratio;\\r\\n\\t\\tthis.setValues('hwb', hwb);\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\tblacken: function (ratio) {\\r\\n\\t\\tvar hwb = this.values.hwb;\\r\\n\\t\\thwb[2] += hwb[2] * ratio;\\r\\n\\t\\tthis.setValues('hwb', hwb);\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\tgreyscale: function () {\\r\\n\\t\\tvar rgb = this.values.rgb;\\r\\n\\t\\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\\r\\n\\t\\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\\r\\n\\t\\tthis.setValues('rgb', [val, val, val]);\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\tclearer: function (ratio) {\\r\\n\\t\\tvar alpha = this.values.alpha;\\r\\n\\t\\tthis.setValues('alpha', alpha - (alpha * ratio));\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\topaquer: function (ratio) {\\r\\n\\t\\tvar alpha = this.values.alpha;\\r\\n\\t\\tthis.setValues('alpha', alpha + (alpha * ratio));\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\trotate: function (degrees) {\\r\\n\\t\\tvar hsl = this.values.hsl;\\r\\n\\t\\tvar hue = (hsl[0] + degrees) % 360;\\r\\n\\t\\thsl[0] = hue < 0 ? 360 + hue : hue;\\r\\n\\t\\tthis.setValues('hsl', hsl);\\r\\n\\t\\treturn this;\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t * Ported from sass implementation in C\\r\\n\\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\\r\\n\\t */\\r\\n\\tmix: function (mixinColor, weight) {\\r\\n\\t\\tvar color1 = this;\\r\\n\\t\\tvar color2 = mixinColor;\\r\\n\\t\\tvar p = weight === undefined ? 0.5 : weight;\\r\\n\\r\\n\\t\\tvar w = 2 * p - 1;\\r\\n\\t\\tvar a = color1.alpha() - color2.alpha();\\r\\n\\r\\n\\t\\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\\r\\n\\t\\tvar w2 = 1 - w1;\\r\\n\\r\\n\\t\\treturn this\\r\\n\\t\\t\\t.rgb(\\r\\n\\t\\t\\t\\tw1 * color1.red() + w2 * color2.red(),\\r\\n\\t\\t\\t\\tw1 * color1.green() + w2 * color2.green(),\\r\\n\\t\\t\\t\\tw1 * color1.blue() + w2 * color2.blue()\\r\\n\\t\\t\\t)\\r\\n\\t\\t\\t.alpha(color1.alpha() * p + color2.alpha() * (1 - p));\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function () {\\r\\n\\t\\treturn this.rgb();\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\t\\t// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\\r\\n\\t\\t// making the final build way to big to embed in Chart.js. So let's do it manually,\\r\\n\\t\\t// assuming that values to clone are 1 dimension arrays containing only numbers,\\r\\n\\t\\t// except 'alpha' which is a number.\\r\\n\\t\\tvar result = new Color();\\r\\n\\t\\tvar source = this.values;\\r\\n\\t\\tvar target = result.values;\\r\\n\\t\\tvar value, type;\\r\\n\\r\\n\\t\\tfor (var prop in source) {\\r\\n\\t\\t\\tif (source.hasOwnProperty(prop)) {\\r\\n\\t\\t\\t\\tvalue = source[prop];\\r\\n\\t\\t\\t\\ttype = ({}).toString.call(value);\\r\\n\\t\\t\\t\\tif (type === '[object Array]') {\\r\\n\\t\\t\\t\\t\\ttarget[prop] = value.slice(0);\\r\\n\\t\\t\\t\\t} else if (type === '[object Number]') {\\r\\n\\t\\t\\t\\t\\ttarget[prop] = value;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tconsole.error('unexpected color value:', value);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n};\\r\\n\\r\\nColor.prototype.spaces = {\\r\\n\\trgb: ['red', 'green', 'blue'],\\r\\n\\thsl: ['hue', 'saturation', 'lightness'],\\r\\n\\thsv: ['hue', 'saturation', 'value'],\\r\\n\\thwb: ['hue', 'whiteness', 'blackness'],\\r\\n\\tcmyk: ['cyan', 'magenta', 'yellow', 'black']\\r\\n};\\r\\n\\r\\nColor.prototype.maxes = {\\r\\n\\trgb: [255, 255, 255],\\r\\n\\thsl: [360, 100, 100],\\r\\n\\thsv: [360, 100, 100],\\r\\n\\thwb: [360, 100, 100],\\r\\n\\tcmyk: [100, 100, 100, 100]\\r\\n};\\r\\n\\r\\nColor.prototype.getValues = function (space) {\\r\\n\\tvar values = this.values;\\r\\n\\tvar vals = {};\\r\\n\\r\\n\\tfor (var i = 0; i < space.length; i++) {\\r\\n\\t\\tvals[space.charAt(i)] = values[space][i];\\r\\n\\t}\\r\\n\\r\\n\\tif (values.alpha !== 1) {\\r\\n\\t\\tvals.a = values.alpha;\\r\\n\\t}\\r\\n\\r\\n\\t// {r: 255, g: 255, b: 255, a: 0.4}\\r\\n\\treturn vals;\\r\\n};\\r\\n\\r\\nColor.prototype.setValues = function (space, vals) {\\r\\n\\tvar values = this.values;\\r\\n\\tvar spaces = this.spaces;\\r\\n\\tvar maxes = this.maxes;\\r\\n\\tvar alpha = 1;\\r\\n\\tvar i;\\r\\n\\r\\n\\tif (space === 'alpha') {\\r\\n\\t\\talpha = vals;\\r\\n\\t} else if (vals.length) {\\r\\n\\t\\t// [10, 10, 10]\\r\\n\\t\\tvalues[space] = vals.slice(0, space.length);\\r\\n\\t\\talpha = vals[space.length];\\r\\n\\t} else if (vals[space.charAt(0)] !== undefined) {\\r\\n\\t\\t// {r: 10, g: 10, b: 10}\\r\\n\\t\\tfor (i = 0; i < space.length; i++) {\\r\\n\\t\\t\\tvalues[space][i] = vals[space.charAt(i)];\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\talpha = vals.a;\\r\\n\\t} else if (vals[spaces[space][0]] !== undefined) {\\r\\n\\t\\t// {red: 10, green: 10, blue: 10}\\r\\n\\t\\tvar chans = spaces[space];\\r\\n\\r\\n\\t\\tfor (i = 0; i < space.length; i++) {\\r\\n\\t\\t\\tvalues[space][i] = vals[chans[i]];\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\talpha = vals.alpha;\\r\\n\\t}\\r\\n\\r\\n\\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));\\r\\n\\r\\n\\tif (space === 'alpha') {\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n\\r\\n\\tvar capped;\\r\\n\\r\\n\\t// cap values of the space prior converting all values\\r\\n\\tfor (i = 0; i < space.length; i++) {\\r\\n\\t\\tcapped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\\r\\n\\t\\tvalues[space][i] = Math.round(capped);\\r\\n\\t}\\r\\n\\r\\n\\t// convert to all the other color spaces\\r\\n\\tfor (var sname in spaces) {\\r\\n\\t\\tif (sname !== space) {\\r\\n\\t\\t\\tvalues[sname] = convert[space][sname](values[space]);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\treturn true;\\r\\n};\\r\\n\\r\\nColor.prototype.setSpace = function (space, args) {\\r\\n\\tvar vals = args[0];\\r\\n\\r\\n\\tif (vals === undefined) {\\r\\n\\t\\t// color.rgb()\\r\\n\\t\\treturn this.getValues(space);\\r\\n\\t}\\r\\n\\r\\n\\t// color.rgb(10, 10, 10)\\r\\n\\tif (typeof vals === 'number') {\\r\\n\\t\\tvals = Array.prototype.slice.call(args);\\r\\n\\t}\\r\\n\\r\\n\\tthis.setValues(space, vals);\\r\\n\\treturn this;\\r\\n};\\r\\n\\r\\nColor.prototype.setChannel = function (space, index, val) {\\r\\n\\tvar svalues = this.values[space];\\r\\n\\tif (val === undefined) {\\r\\n\\t\\t// color.red()\\r\\n\\t\\treturn svalues[index];\\r\\n\\t} else if (val === svalues[index]) {\\r\\n\\t\\t// color.red(color.red())\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\t// color.red(100)\\r\\n\\tsvalues[index] = val;\\r\\n\\tthis.setValues(space, svalues);\\r\\n\\r\\n\\treturn this;\\r\\n};\\r\\n\\r\\nif (typeof window !== 'undefined') {\\r\\n\\twindow.Color = Color;\\r\\n}\\r\\n\\r\\nmodule.exports = Color;\\r\\n\\n},{\\\"2\\\":2,\\\"5\\\":5}],4:[function(require,module,exports){\\n/* MIT license */\\n\\nmodule.exports = {\\n  rgb2hsl: rgb2hsl,\\n  rgb2hsv: rgb2hsv,\\n  rgb2hwb: rgb2hwb,\\n  rgb2cmyk: rgb2cmyk,\\n  rgb2keyword: rgb2keyword,\\n  rgb2xyz: rgb2xyz,\\n  rgb2lab: rgb2lab,\\n  rgb2lch: rgb2lch,\\n\\n  hsl2rgb: hsl2rgb,\\n  hsl2hsv: hsl2hsv,\\n  hsl2hwb: hsl2hwb,\\n  hsl2cmyk: hsl2cmyk,\\n  hsl2keyword: hsl2keyword,\\n\\n  hsv2rgb: hsv2rgb,\\n  hsv2hsl: hsv2hsl,\\n  hsv2hwb: hsv2hwb,\\n  hsv2cmyk: hsv2cmyk,\\n  hsv2keyword: hsv2keyword,\\n\\n  hwb2rgb: hwb2rgb,\\n  hwb2hsl: hwb2hsl,\\n  hwb2hsv: hwb2hsv,\\n  hwb2cmyk: hwb2cmyk,\\n  hwb2keyword: hwb2keyword,\\n\\n  cmyk2rgb: cmyk2rgb,\\n  cmyk2hsl: cmyk2hsl,\\n  cmyk2hsv: cmyk2hsv,\\n  cmyk2hwb: cmyk2hwb,\\n  cmyk2keyword: cmyk2keyword,\\n\\n  keyword2rgb: keyword2rgb,\\n  keyword2hsl: keyword2hsl,\\n  keyword2hsv: keyword2hsv,\\n  keyword2hwb: keyword2hwb,\\n  keyword2cmyk: keyword2cmyk,\\n  keyword2lab: keyword2lab,\\n  keyword2xyz: keyword2xyz,\\n\\n  xyz2rgb: xyz2rgb,\\n  xyz2lab: xyz2lab,\\n  xyz2lch: xyz2lch,\\n\\n  lab2xyz: lab2xyz,\\n  lab2rgb: lab2rgb,\\n  lab2lch: lab2lch,\\n\\n  lch2lab: lch2lab,\\n  lch2xyz: lch2xyz,\\n  lch2rgb: lch2rgb\\n}\\n\\n\\nfunction rgb2hsl(rgb) {\\n  var r = rgb[0]/255,\\n      g = rgb[1]/255,\\n      b = rgb[2]/255,\\n      min = Math.min(r, g, b),\\n      max = Math.max(r, g, b),\\n      delta = max - min,\\n      h, s, l;\\n\\n  if (max == min)\\n    h = 0;\\n  else if (r == max)\\n    h = (g - b) / delta;\\n  else if (g == max)\\n    h = 2 + (b - r) / delta;\\n  else if (b == max)\\n    h = 4 + (r - g)/ delta;\\n\\n  h = Math.min(h * 60, 360);\\n\\n  if (h < 0)\\n    h += 360;\\n\\n  l = (min + max) / 2;\\n\\n  if (max == min)\\n    s = 0;\\n  else if (l <= 0.5)\\n    s = delta / (max + min);\\n  else\\n    s = delta / (2 - max - min);\\n\\n  return [h, s * 100, l * 100];\\n}\\n\\nfunction rgb2hsv(rgb) {\\n  var r = rgb[0],\\n      g = rgb[1],\\n      b = rgb[2],\\n      min = Math.min(r, g, b),\\n      max = Math.max(r, g, b),\\n      delta = max - min,\\n      h, s, v;\\n\\n  if (max == 0)\\n    s = 0;\\n  else\\n    s = (delta/max * 1000)/10;\\n\\n  if (max == min)\\n    h = 0;\\n  else if (r == max)\\n    h = (g - b) / delta;\\n  else if (g == max)\\n    h = 2 + (b - r) / delta;\\n  else if (b == max)\\n    h = 4 + (r - g) / delta;\\n\\n  h = Math.min(h * 60, 360);\\n\\n  if (h < 0)\\n    h += 360;\\n\\n  v = ((max / 255) * 1000) / 10;\\n\\n  return [h, s, v];\\n}\\n\\nfunction rgb2hwb(rgb) {\\n  var r = rgb[0],\\n      g = rgb[1],\\n      b = rgb[2],\\n      h = rgb2hsl(rgb)[0],\\n      w = 1/255 * Math.min(r, Math.min(g, b)),\\n      b = 1 - 1/255 * Math.max(r, Math.max(g, b));\\n\\n  return [h, w * 100, b * 100];\\n}\\n\\nfunction rgb2cmyk(rgb) {\\n  var r = rgb[0] / 255,\\n      g = rgb[1] / 255,\\n      b = rgb[2] / 255,\\n      c, m, y, k;\\n\\n  k = Math.min(1 - r, 1 - g, 1 - b);\\n  c = (1 - r - k) / (1 - k) || 0;\\n  m = (1 - g - k) / (1 - k) || 0;\\n  y = (1 - b - k) / (1 - k) || 0;\\n  return [c * 100, m * 100, y * 100, k * 100];\\n}\\n\\nfunction rgb2keyword(rgb) {\\n  return reverseKeywords[JSON.stringify(rgb)];\\n}\\n\\nfunction rgb2xyz(rgb) {\\n  var r = rgb[0] / 255,\\n      g = rgb[1] / 255,\\n      b = rgb[2] / 255;\\n\\n  // assume sRGB\\n  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\\n  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\\n  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\\n\\n  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\\n  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\\n  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\\n\\n  return [x * 100, y *100, z * 100];\\n}\\n\\nfunction rgb2lab(rgb) {\\n  var xyz = rgb2xyz(rgb),\\n        x = xyz[0],\\n        y = xyz[1],\\n        z = xyz[2],\\n        l, a, b;\\n\\n  x /= 95.047;\\n  y /= 100;\\n  z /= 108.883;\\n\\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\\n\\n  l = (116 * y) - 16;\\n  a = 500 * (x - y);\\n  b = 200 * (y - z);\\n\\n  return [l, a, b];\\n}\\n\\nfunction rgb2lch(args) {\\n  return lab2lch(rgb2lab(args));\\n}\\n\\nfunction hsl2rgb(hsl) {\\n  var h = hsl[0] / 360,\\n      s = hsl[1] / 100,\\n      l = hsl[2] / 100,\\n      t1, t2, t3, rgb, val;\\n\\n  if (s == 0) {\\n    val = l * 255;\\n    return [val, val, val];\\n  }\\n\\n  if (l < 0.5)\\n    t2 = l * (1 + s);\\n  else\\n    t2 = l + s - l * s;\\n  t1 = 2 * l - t2;\\n\\n  rgb = [0, 0, 0];\\n  for (var i = 0; i < 3; i++) {\\n    t3 = h + 1 / 3 * - (i - 1);\\n    t3 < 0 && t3++;\\n    t3 > 1 && t3--;\\n\\n    if (6 * t3 < 1)\\n      val = t1 + (t2 - t1) * 6 * t3;\\n    else if (2 * t3 < 1)\\n      val = t2;\\n    else if (3 * t3 < 2)\\n      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\\n    else\\n      val = t1;\\n\\n    rgb[i] = val * 255;\\n  }\\n\\n  return rgb;\\n}\\n\\nfunction hsl2hsv(hsl) {\\n  var h = hsl[0],\\n      s = hsl[1] / 100,\\n      l = hsl[2] / 100,\\n      sv, v;\\n\\n  if(l === 0) {\\n      // no need to do calc on black\\n      // also avoids divide by 0 error\\n      return [0, 0, 0];\\n  }\\n\\n  l *= 2;\\n  s *= (l <= 1) ? l : 2 - l;\\n  v = (l + s) / 2;\\n  sv = (2 * s) / (l + s);\\n  return [h, sv * 100, v * 100];\\n}\\n\\nfunction hsl2hwb(args) {\\n  return rgb2hwb(hsl2rgb(args));\\n}\\n\\nfunction hsl2cmyk(args) {\\n  return rgb2cmyk(hsl2rgb(args));\\n}\\n\\nfunction hsl2keyword(args) {\\n  return rgb2keyword(hsl2rgb(args));\\n}\\n\\n\\nfunction hsv2rgb(hsv) {\\n  var h = hsv[0] / 60,\\n      s = hsv[1] / 100,\\n      v = hsv[2] / 100,\\n      hi = Math.floor(h) % 6;\\n\\n  var f = h - Math.floor(h),\\n      p = 255 * v * (1 - s),\\n      q = 255 * v * (1 - (s * f)),\\n      t = 255 * v * (1 - (s * (1 - f))),\\n      v = 255 * v;\\n\\n  switch(hi) {\\n    case 0:\\n      return [v, t, p];\\n    case 1:\\n      return [q, v, p];\\n    case 2:\\n      return [p, v, t];\\n    case 3:\\n      return [p, q, v];\\n    case 4:\\n      return [t, p, v];\\n    case 5:\\n      return [v, p, q];\\n  }\\n}\\n\\nfunction hsv2hsl(hsv) {\\n  var h = hsv[0],\\n      s = hsv[1] / 100,\\n      v = hsv[2] / 100,\\n      sl, l;\\n\\n  l = (2 - s) * v;\\n  sl = s * v;\\n  sl /= (l <= 1) ? l : 2 - l;\\n  sl = sl || 0;\\n  l /= 2;\\n  return [h, sl * 100, l * 100];\\n}\\n\\nfunction hsv2hwb(args) {\\n  return rgb2hwb(hsv2rgb(args))\\n}\\n\\nfunction hsv2cmyk(args) {\\n  return rgb2cmyk(hsv2rgb(args));\\n}\\n\\nfunction hsv2keyword(args) {\\n  return rgb2keyword(hsv2rgb(args));\\n}\\n\\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\\nfunction hwb2rgb(hwb) {\\n  var h = hwb[0] / 360,\\n      wh = hwb[1] / 100,\\n      bl = hwb[2] / 100,\\n      ratio = wh + bl,\\n      i, v, f, n;\\n\\n  // wh + bl cant be > 1\\n  if (ratio > 1) {\\n    wh /= ratio;\\n    bl /= ratio;\\n  }\\n\\n  i = Math.floor(6 * h);\\n  v = 1 - bl;\\n  f = 6 * h - i;\\n  if ((i & 0x01) != 0) {\\n    f = 1 - f;\\n  }\\n  n = wh + f * (v - wh);  // linear interpolation\\n\\n  switch (i) {\\n    default:\\n    case 6:\\n    case 0: r = v; g = n; b = wh; break;\\n    case 1: r = n; g = v; b = wh; break;\\n    case 2: r = wh; g = v; b = n; break;\\n    case 3: r = wh; g = n; b = v; break;\\n    case 4: r = n; g = wh; b = v; break;\\n    case 5: r = v; g = wh; b = n; break;\\n  }\\n\\n  return [r * 255, g * 255, b * 255];\\n}\\n\\nfunction hwb2hsl(args) {\\n  return rgb2hsl(hwb2rgb(args));\\n}\\n\\nfunction hwb2hsv(args) {\\n  return rgb2hsv(hwb2rgb(args));\\n}\\n\\nfunction hwb2cmyk(args) {\\n  return rgb2cmyk(hwb2rgb(args));\\n}\\n\\nfunction hwb2keyword(args) {\\n  return rgb2keyword(hwb2rgb(args));\\n}\\n\\nfunction cmyk2rgb(cmyk) {\\n  var c = cmyk[0] / 100,\\n      m = cmyk[1] / 100,\\n      y = cmyk[2] / 100,\\n      k = cmyk[3] / 100,\\n      r, g, b;\\n\\n  r = 1 - Math.min(1, c * (1 - k) + k);\\n  g = 1 - Math.min(1, m * (1 - k) + k);\\n  b = 1 - Math.min(1, y * (1 - k) + k);\\n  return [r * 255, g * 255, b * 255];\\n}\\n\\nfunction cmyk2hsl(args) {\\n  return rgb2hsl(cmyk2rgb(args));\\n}\\n\\nfunction cmyk2hsv(args) {\\n  return rgb2hsv(cmyk2rgb(args));\\n}\\n\\nfunction cmyk2hwb(args) {\\n  return rgb2hwb(cmyk2rgb(args));\\n}\\n\\nfunction cmyk2keyword(args) {\\n  return rgb2keyword(cmyk2rgb(args));\\n}\\n\\n\\nfunction xyz2rgb(xyz) {\\n  var x = xyz[0] / 100,\\n      y = xyz[1] / 100,\\n      z = xyz[2] / 100,\\n      r, g, b;\\n\\n  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\\n  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\\n  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\\n\\n  // assume sRGB\\n  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\\n    : r = (r * 12.92);\\n\\n  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\\n    : g = (g * 12.92);\\n\\n  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\\n    : b = (b * 12.92);\\n\\n  r = Math.min(Math.max(0, r), 1);\\n  g = Math.min(Math.max(0, g), 1);\\n  b = Math.min(Math.max(0, b), 1);\\n\\n  return [r * 255, g * 255, b * 255];\\n}\\n\\nfunction xyz2lab(xyz) {\\n  var x = xyz[0],\\n      y = xyz[1],\\n      z = xyz[2],\\n      l, a, b;\\n\\n  x /= 95.047;\\n  y /= 100;\\n  z /= 108.883;\\n\\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\\n\\n  l = (116 * y) - 16;\\n  a = 500 * (x - y);\\n  b = 200 * (y - z);\\n\\n  return [l, a, b];\\n}\\n\\nfunction xyz2lch(args) {\\n  return lab2lch(xyz2lab(args));\\n}\\n\\nfunction lab2xyz(lab) {\\n  var l = lab[0],\\n      a = lab[1],\\n      b = lab[2],\\n      x, y, z, y2;\\n\\n  if (l <= 8) {\\n    y = (l * 100) / 903.3;\\n    y2 = (7.787 * (y / 100)) + (16 / 116);\\n  } else {\\n    y = 100 * Math.pow((l + 16) / 116, 3);\\n    y2 = Math.pow(y / 100, 1/3);\\n  }\\n\\n  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\\n\\n  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\\n\\n  return [x, y, z];\\n}\\n\\nfunction lab2lch(lab) {\\n  var l = lab[0],\\n      a = lab[1],\\n      b = lab[2],\\n      hr, h, c;\\n\\n  hr = Math.atan2(b, a);\\n  h = hr * 360 / 2 / Math.PI;\\n  if (h < 0) {\\n    h += 360;\\n  }\\n  c = Math.sqrt(a * a + b * b);\\n  return [l, c, h];\\n}\\n\\nfunction lab2rgb(args) {\\n  return xyz2rgb(lab2xyz(args));\\n}\\n\\nfunction lch2lab(lch) {\\n  var l = lch[0],\\n      c = lch[1],\\n      h = lch[2],\\n      a, b, hr;\\n\\n  hr = h / 360 * 2 * Math.PI;\\n  a = c * Math.cos(hr);\\n  b = c * Math.sin(hr);\\n  return [l, a, b];\\n}\\n\\nfunction lch2xyz(args) {\\n  return lab2xyz(lch2lab(args));\\n}\\n\\nfunction lch2rgb(args) {\\n  return lab2rgb(lch2lab(args));\\n}\\n\\nfunction keyword2rgb(keyword) {\\n  return cssKeywords[keyword];\\n}\\n\\nfunction keyword2hsl(args) {\\n  return rgb2hsl(keyword2rgb(args));\\n}\\n\\nfunction keyword2hsv(args) {\\n  return rgb2hsv(keyword2rgb(args));\\n}\\n\\nfunction keyword2hwb(args) {\\n  return rgb2hwb(keyword2rgb(args));\\n}\\n\\nfunction keyword2cmyk(args) {\\n  return rgb2cmyk(keyword2rgb(args));\\n}\\n\\nfunction keyword2lab(args) {\\n  return rgb2lab(keyword2rgb(args));\\n}\\n\\nfunction keyword2xyz(args) {\\n  return rgb2xyz(keyword2rgb(args));\\n}\\n\\nvar cssKeywords = {\\n  aliceblue:  [240,248,255],\\n  antiquewhite: [250,235,215],\\n  aqua: [0,255,255],\\n  aquamarine: [127,255,212],\\n  azure:  [240,255,255],\\n  beige:  [245,245,220],\\n  bisque: [255,228,196],\\n  black:  [0,0,0],\\n  blanchedalmond: [255,235,205],\\n  blue: [0,0,255],\\n  blueviolet: [138,43,226],\\n  brown:  [165,42,42],\\n  burlywood:  [222,184,135],\\n  cadetblue:  [95,158,160],\\n  chartreuse: [127,255,0],\\n  chocolate:  [210,105,30],\\n  coral:  [255,127,80],\\n  cornflowerblue: [100,149,237],\\n  cornsilk: [255,248,220],\\n  crimson:  [220,20,60],\\n  cyan: [0,255,255],\\n  darkblue: [0,0,139],\\n  darkcyan: [0,139,139],\\n  darkgoldenrod:  [184,134,11],\\n  darkgray: [169,169,169],\\n  darkgreen:  [0,100,0],\\n  darkgrey: [169,169,169],\\n  darkkhaki:  [189,183,107],\\n  darkmagenta:  [139,0,139],\\n  darkolivegreen: [85,107,47],\\n  darkorange: [255,140,0],\\n  darkorchid: [153,50,204],\\n  darkred:  [139,0,0],\\n  darksalmon: [233,150,122],\\n  darkseagreen: [143,188,143],\\n  darkslateblue:  [72,61,139],\\n  darkslategray:  [47,79,79],\\n  darkslategrey:  [47,79,79],\\n  darkturquoise:  [0,206,209],\\n  darkviolet: [148,0,211],\\n  deeppink: [255,20,147],\\n  deepskyblue:  [0,191,255],\\n  dimgray:  [105,105,105],\\n  dimgrey:  [105,105,105],\\n  dodgerblue: [30,144,255],\\n  firebrick:  [178,34,34],\\n  floralwhite:  [255,250,240],\\n  forestgreen:  [34,139,34],\\n  fuchsia:  [255,0,255],\\n  gainsboro:  [220,220,220],\\n  ghostwhite: [248,248,255],\\n  gold: [255,215,0],\\n  goldenrod:  [218,165,32],\\n  gray: [128,128,128],\\n  green:  [0,128,0],\\n  greenyellow:  [173,255,47],\\n  grey: [128,128,128],\\n  honeydew: [240,255,240],\\n  hotpink:  [255,105,180],\\n  indianred:  [205,92,92],\\n  indigo: [75,0,130],\\n  ivory:  [255,255,240],\\n  khaki:  [240,230,140],\\n  lavender: [230,230,250],\\n  lavenderblush:  [255,240,245],\\n  lawngreen:  [124,252,0],\\n  lemonchiffon: [255,250,205],\\n  lightblue:  [173,216,230],\\n  lightcoral: [240,128,128],\\n  lightcyan:  [224,255,255],\\n  lightgoldenrodyellow: [250,250,210],\\n  lightgray:  [211,211,211],\\n  lightgreen: [144,238,144],\\n  lightgrey:  [211,211,211],\\n  lightpink:  [255,182,193],\\n  lightsalmon:  [255,160,122],\\n  lightseagreen:  [32,178,170],\\n  lightskyblue: [135,206,250],\\n  lightslategray: [119,136,153],\\n  lightslategrey: [119,136,153],\\n  lightsteelblue: [176,196,222],\\n  lightyellow:  [255,255,224],\\n  lime: [0,255,0],\\n  limegreen:  [50,205,50],\\n  linen:  [250,240,230],\\n  magenta:  [255,0,255],\\n  maroon: [128,0,0],\\n  mediumaquamarine: [102,205,170],\\n  mediumblue: [0,0,205],\\n  mediumorchid: [186,85,211],\\n  mediumpurple: [147,112,219],\\n  mediumseagreen: [60,179,113],\\n  mediumslateblue:  [123,104,238],\\n  mediumspringgreen:  [0,250,154],\\n  mediumturquoise:  [72,209,204],\\n  mediumvioletred:  [199,21,133],\\n  midnightblue: [25,25,112],\\n  mintcream:  [245,255,250],\\n  mistyrose:  [255,228,225],\\n  moccasin: [255,228,181],\\n  navajowhite:  [255,222,173],\\n  navy: [0,0,128],\\n  oldlace:  [253,245,230],\\n  olive:  [128,128,0],\\n  olivedrab:  [107,142,35],\\n  orange: [255,165,0],\\n  orangered:  [255,69,0],\\n  orchid: [218,112,214],\\n  palegoldenrod:  [238,232,170],\\n  palegreen:  [152,251,152],\\n  paleturquoise:  [175,238,238],\\n  palevioletred:  [219,112,147],\\n  papayawhip: [255,239,213],\\n  peachpuff:  [255,218,185],\\n  peru: [205,133,63],\\n  pink: [255,192,203],\\n  plum: [221,160,221],\\n  powderblue: [176,224,230],\\n  purple: [128,0,128],\\n  rebeccapurple: [102, 51, 153],\\n  red:  [255,0,0],\\n  rosybrown:  [188,143,143],\\n  royalblue:  [65,105,225],\\n  saddlebrown:  [139,69,19],\\n  salmon: [250,128,114],\\n  sandybrown: [244,164,96],\\n  seagreen: [46,139,87],\\n  seashell: [255,245,238],\\n  sienna: [160,82,45],\\n  silver: [192,192,192],\\n  skyblue:  [135,206,235],\\n  slateblue:  [106,90,205],\\n  slategray:  [112,128,144],\\n  slategrey:  [112,128,144],\\n  snow: [255,250,250],\\n  springgreen:  [0,255,127],\\n  steelblue:  [70,130,180],\\n  tan:  [210,180,140],\\n  teal: [0,128,128],\\n  thistle:  [216,191,216],\\n  tomato: [255,99,71],\\n  turquoise:  [64,224,208],\\n  violet: [238,130,238],\\n  wheat:  [245,222,179],\\n  white:  [255,255,255],\\n  whitesmoke: [245,245,245],\\n  yellow: [255,255,0],\\n  yellowgreen:  [154,205,50]\\n};\\n\\nvar reverseKeywords = {};\\nfor (var key in cssKeywords) {\\n  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;\\n}\\n\\n},{}],5:[function(require,module,exports){\\nvar conversions = require(4);\\n\\nvar convert = function() {\\n   return new Converter();\\n}\\n\\nfor (var func in conversions) {\\n  // export Raw versions\\n  convert[func + \\\"Raw\\\"] =  (function(func) {\\n    // accept array or plain args\\n    return function(arg) {\\n      if (typeof arg == \\\"number\\\")\\n        arg = Array.prototype.slice.call(arguments);\\n      return conversions[func](arg);\\n    }\\n  })(func);\\n\\n  var pair = /(\\\\w+)2(\\\\w+)/.exec(func),\\n      from = pair[1],\\n      to = pair[2];\\n\\n  // export rgb2hsl and [\\\"rgb\\\"][\\\"hsl\\\"]\\n  convert[from] = convert[from] || {};\\n\\n  convert[from][to] = convert[func] = (function(func) { \\n    return function(arg) {\\n      if (typeof arg == \\\"number\\\")\\n        arg = Array.prototype.slice.call(arguments);\\n      \\n      var val = conversions[func](arg);\\n      if (typeof val == \\\"string\\\" || val === undefined)\\n        return val; // keyword\\n\\n      for (var i = 0; i < val.length; i++)\\n        val[i] = Math.round(val[i]);\\n      return val;\\n    }\\n  })(func);\\n}\\n\\n\\n/* Converter does lazy conversion and caching */\\nvar Converter = function() {\\n   this.convs = {};\\n};\\n\\n/* Either get the values for a space or\\n  set the values for a space, depending on args */\\nConverter.prototype.routeSpace = function(space, args) {\\n   var values = args[0];\\n   if (values === undefined) {\\n      // color.rgb()\\n      return this.getValues(space);\\n   }\\n   // color.rgb(10, 10, 10)\\n   if (typeof values == \\\"number\\\") {\\n      values = Array.prototype.slice.call(args);        \\n   }\\n\\n   return this.setValues(space, values);\\n};\\n  \\n/* Set the values for a space, invalidating cache */\\nConverter.prototype.setValues = function(space, values) {\\n   this.space = space;\\n   this.convs = {};\\n   this.convs[space] = values;\\n   return this;\\n};\\n\\n/* Get the values for a space. If there's already\\n  a conversion for the space, fetch it, otherwise\\n  compute it */\\nConverter.prototype.getValues = function(space) {\\n   var vals = this.convs[space];\\n   if (!vals) {\\n      var fspace = this.space,\\n          from = this.convs[fspace];\\n      vals = convert[fspace][space](from);\\n\\n      this.convs[space] = vals;\\n   }\\n  return vals;\\n};\\n\\n[\\\"rgb\\\", \\\"hsl\\\", \\\"hsv\\\", \\\"cmyk\\\", \\\"keyword\\\"].forEach(function(space) {\\n   Converter.prototype[space] = function(vals) {\\n      return this.routeSpace(space, arguments);\\n   }\\n});\\n\\nmodule.exports = convert;\\n},{\\\"4\\\":4}],6:[function(require,module,exports){\\nmodule.exports = {\\r\\n\\t\\\"aliceblue\\\": [240, 248, 255],\\r\\n\\t\\\"antiquewhite\\\": [250, 235, 215],\\r\\n\\t\\\"aqua\\\": [0, 255, 255],\\r\\n\\t\\\"aquamarine\\\": [127, 255, 212],\\r\\n\\t\\\"azure\\\": [240, 255, 255],\\r\\n\\t\\\"beige\\\": [245, 245, 220],\\r\\n\\t\\\"bisque\\\": [255, 228, 196],\\r\\n\\t\\\"black\\\": [0, 0, 0],\\r\\n\\t\\\"blanchedalmond\\\": [255, 235, 205],\\r\\n\\t\\\"blue\\\": [0, 0, 255],\\r\\n\\t\\\"blueviolet\\\": [138, 43, 226],\\r\\n\\t\\\"brown\\\": [165, 42, 42],\\r\\n\\t\\\"burlywood\\\": [222, 184, 135],\\r\\n\\t\\\"cadetblue\\\": [95, 158, 160],\\r\\n\\t\\\"chartreuse\\\": [127, 255, 0],\\r\\n\\t\\\"chocolate\\\": [210, 105, 30],\\r\\n\\t\\\"coral\\\": [255, 127, 80],\\r\\n\\t\\\"cornflowerblue\\\": [100, 149, 237],\\r\\n\\t\\\"cornsilk\\\": [255, 248, 220],\\r\\n\\t\\\"crimson\\\": [220, 20, 60],\\r\\n\\t\\\"cyan\\\": [0, 255, 255],\\r\\n\\t\\\"darkblue\\\": [0, 0, 139],\\r\\n\\t\\\"darkcyan\\\": [0, 139, 139],\\r\\n\\t\\\"darkgoldenrod\\\": [184, 134, 11],\\r\\n\\t\\\"darkgray\\\": [169, 169, 169],\\r\\n\\t\\\"darkgreen\\\": [0, 100, 0],\\r\\n\\t\\\"darkgrey\\\": [169, 169, 169],\\r\\n\\t\\\"darkkhaki\\\": [189, 183, 107],\\r\\n\\t\\\"darkmagenta\\\": [139, 0, 139],\\r\\n\\t\\\"darkolivegreen\\\": [85, 107, 47],\\r\\n\\t\\\"darkorange\\\": [255, 140, 0],\\r\\n\\t\\\"darkorchid\\\": [153, 50, 204],\\r\\n\\t\\\"darkred\\\": [139, 0, 0],\\r\\n\\t\\\"darksalmon\\\": [233, 150, 122],\\r\\n\\t\\\"darkseagreen\\\": [143, 188, 143],\\r\\n\\t\\\"darkslateblue\\\": [72, 61, 139],\\r\\n\\t\\\"darkslategray\\\": [47, 79, 79],\\r\\n\\t\\\"darkslategrey\\\": [47, 79, 79],\\r\\n\\t\\\"darkturquoise\\\": [0, 206, 209],\\r\\n\\t\\\"darkviolet\\\": [148, 0, 211],\\r\\n\\t\\\"deeppink\\\": [255, 20, 147],\\r\\n\\t\\\"deepskyblue\\\": [0, 191, 255],\\r\\n\\t\\\"dimgray\\\": [105, 105, 105],\\r\\n\\t\\\"dimgrey\\\": [105, 105, 105],\\r\\n\\t\\\"dodgerblue\\\": [30, 144, 255],\\r\\n\\t\\\"firebrick\\\": [178, 34, 34],\\r\\n\\t\\\"floralwhite\\\": [255, 250, 240],\\r\\n\\t\\\"forestgreen\\\": [34, 139, 34],\\r\\n\\t\\\"fuchsia\\\": [255, 0, 255],\\r\\n\\t\\\"gainsboro\\\": [220, 220, 220],\\r\\n\\t\\\"ghostwhite\\\": [248, 248, 255],\\r\\n\\t\\\"gold\\\": [255, 215, 0],\\r\\n\\t\\\"goldenrod\\\": [218, 165, 32],\\r\\n\\t\\\"gray\\\": [128, 128, 128],\\r\\n\\t\\\"green\\\": [0, 128, 0],\\r\\n\\t\\\"greenyellow\\\": [173, 255, 47],\\r\\n\\t\\\"grey\\\": [128, 128, 128],\\r\\n\\t\\\"honeydew\\\": [240, 255, 240],\\r\\n\\t\\\"hotpink\\\": [255, 105, 180],\\r\\n\\t\\\"indianred\\\": [205, 92, 92],\\r\\n\\t\\\"indigo\\\": [75, 0, 130],\\r\\n\\t\\\"ivory\\\": [255, 255, 240],\\r\\n\\t\\\"khaki\\\": [240, 230, 140],\\r\\n\\t\\\"lavender\\\": [230, 230, 250],\\r\\n\\t\\\"lavenderblush\\\": [255, 240, 245],\\r\\n\\t\\\"lawngreen\\\": [124, 252, 0],\\r\\n\\t\\\"lemonchiffon\\\": [255, 250, 205],\\r\\n\\t\\\"lightblue\\\": [173, 216, 230],\\r\\n\\t\\\"lightcoral\\\": [240, 128, 128],\\r\\n\\t\\\"lightcyan\\\": [224, 255, 255],\\r\\n\\t\\\"lightgoldenrodyellow\\\": [250, 250, 210],\\r\\n\\t\\\"lightgray\\\": [211, 211, 211],\\r\\n\\t\\\"lightgreen\\\": [144, 238, 144],\\r\\n\\t\\\"lightgrey\\\": [211, 211, 211],\\r\\n\\t\\\"lightpink\\\": [255, 182, 193],\\r\\n\\t\\\"lightsalmon\\\": [255, 160, 122],\\r\\n\\t\\\"lightseagreen\\\": [32, 178, 170],\\r\\n\\t\\\"lightskyblue\\\": [135, 206, 250],\\r\\n\\t\\\"lightslategray\\\": [119, 136, 153],\\r\\n\\t\\\"lightslategrey\\\": [119, 136, 153],\\r\\n\\t\\\"lightsteelblue\\\": [176, 196, 222],\\r\\n\\t\\\"lightyellow\\\": [255, 255, 224],\\r\\n\\t\\\"lime\\\": [0, 255, 0],\\r\\n\\t\\\"limegreen\\\": [50, 205, 50],\\r\\n\\t\\\"linen\\\": [250, 240, 230],\\r\\n\\t\\\"magenta\\\": [255, 0, 255],\\r\\n\\t\\\"maroon\\\": [128, 0, 0],\\r\\n\\t\\\"mediumaquamarine\\\": [102, 205, 170],\\r\\n\\t\\\"mediumblue\\\": [0, 0, 205],\\r\\n\\t\\\"mediumorchid\\\": [186, 85, 211],\\r\\n\\t\\\"mediumpurple\\\": [147, 112, 219],\\r\\n\\t\\\"mediumseagreen\\\": [60, 179, 113],\\r\\n\\t\\\"mediumslateblue\\\": [123, 104, 238],\\r\\n\\t\\\"mediumspringgreen\\\": [0, 250, 154],\\r\\n\\t\\\"mediumturquoise\\\": [72, 209, 204],\\r\\n\\t\\\"mediumvioletred\\\": [199, 21, 133],\\r\\n\\t\\\"midnightblue\\\": [25, 25, 112],\\r\\n\\t\\\"mintcream\\\": [245, 255, 250],\\r\\n\\t\\\"mistyrose\\\": [255, 228, 225],\\r\\n\\t\\\"moccasin\\\": [255, 228, 181],\\r\\n\\t\\\"navajowhite\\\": [255, 222, 173],\\r\\n\\t\\\"navy\\\": [0, 0, 128],\\r\\n\\t\\\"oldlace\\\": [253, 245, 230],\\r\\n\\t\\\"olive\\\": [128, 128, 0],\\r\\n\\t\\\"olivedrab\\\": [107, 142, 35],\\r\\n\\t\\\"orange\\\": [255, 165, 0],\\r\\n\\t\\\"orangered\\\": [255, 69, 0],\\r\\n\\t\\\"orchid\\\": [218, 112, 214],\\r\\n\\t\\\"palegoldenrod\\\": [238, 232, 170],\\r\\n\\t\\\"palegreen\\\": [152, 251, 152],\\r\\n\\t\\\"paleturquoise\\\": [175, 238, 238],\\r\\n\\t\\\"palevioletred\\\": [219, 112, 147],\\r\\n\\t\\\"papayawhip\\\": [255, 239, 213],\\r\\n\\t\\\"peachpuff\\\": [255, 218, 185],\\r\\n\\t\\\"peru\\\": [205, 133, 63],\\r\\n\\t\\\"pink\\\": [255, 192, 203],\\r\\n\\t\\\"plum\\\": [221, 160, 221],\\r\\n\\t\\\"powderblue\\\": [176, 224, 230],\\r\\n\\t\\\"purple\\\": [128, 0, 128],\\r\\n\\t\\\"rebeccapurple\\\": [102, 51, 153],\\r\\n\\t\\\"red\\\": [255, 0, 0],\\r\\n\\t\\\"rosybrown\\\": [188, 143, 143],\\r\\n\\t\\\"royalblue\\\": [65, 105, 225],\\r\\n\\t\\\"saddlebrown\\\": [139, 69, 19],\\r\\n\\t\\\"salmon\\\": [250, 128, 114],\\r\\n\\t\\\"sandybrown\\\": [244, 164, 96],\\r\\n\\t\\\"seagreen\\\": [46, 139, 87],\\r\\n\\t\\\"seashell\\\": [255, 245, 238],\\r\\n\\t\\\"sienna\\\": [160, 82, 45],\\r\\n\\t\\\"silver\\\": [192, 192, 192],\\r\\n\\t\\\"skyblue\\\": [135, 206, 235],\\r\\n\\t\\\"slateblue\\\": [106, 90, 205],\\r\\n\\t\\\"slategray\\\": [112, 128, 144],\\r\\n\\t\\\"slategrey\\\": [112, 128, 144],\\r\\n\\t\\\"snow\\\": [255, 250, 250],\\r\\n\\t\\\"springgreen\\\": [0, 255, 127],\\r\\n\\t\\\"steelblue\\\": [70, 130, 180],\\r\\n\\t\\\"tan\\\": [210, 180, 140],\\r\\n\\t\\\"teal\\\": [0, 128, 128],\\r\\n\\t\\\"thistle\\\": [216, 191, 216],\\r\\n\\t\\\"tomato\\\": [255, 99, 71],\\r\\n\\t\\\"turquoise\\\": [64, 224, 208],\\r\\n\\t\\\"violet\\\": [238, 130, 238],\\r\\n\\t\\\"wheat\\\": [245, 222, 179],\\r\\n\\t\\\"white\\\": [255, 255, 255],\\r\\n\\t\\\"whitesmoke\\\": [245, 245, 245],\\r\\n\\t\\\"yellow\\\": [255, 255, 0],\\r\\n\\t\\\"yellowgreen\\\": [154, 205, 50]\\r\\n};\\n},{}],7:[function(require,module,exports){\\n/**\\n * @namespace Chart\\n */\\nvar Chart = require(28)();\\n\\nrequire(26)(Chart);\\nrequire(42)(Chart);\\nrequire(22)(Chart);\\nrequire(31)(Chart);\\nrequire(25)(Chart);\\nrequire(21)(Chart);\\nrequire(23)(Chart);\\nrequire(24)(Chart);\\nrequire(29)(Chart);\\nrequire(33)(Chart);\\nrequire(34)(Chart);\\nrequire(32)(Chart);\\nrequire(35)(Chart);\\nrequire(30)(Chart);\\nrequire(27)(Chart);\\nrequire(36)(Chart);\\n\\nrequire(37)(Chart);\\nrequire(38)(Chart);\\nrequire(39)(Chart);\\nrequire(40)(Chart);\\n\\nrequire(45)(Chart);\\nrequire(43)(Chart);\\nrequire(44)(Chart);\\nrequire(46)(Chart);\\nrequire(47)(Chart);\\nrequire(48)(Chart);\\n\\n// Controllers must be loaded after elements\\n// See Chart.core.datasetController.dataElementType\\nrequire(15)(Chart);\\nrequire(16)(Chart);\\nrequire(17)(Chart);\\nrequire(18)(Chart);\\nrequire(19)(Chart);\\nrequire(20)(Chart);\\n\\nrequire(8)(Chart);\\nrequire(9)(Chart);\\nrequire(10)(Chart);\\nrequire(11)(Chart);\\nrequire(12)(Chart);\\nrequire(13)(Chart);\\nrequire(14)(Chart);\\n\\nwindow.Chart = module.exports = Chart;\\n\\n},{\\\"10\\\":10,\\\"11\\\":11,\\\"12\\\":12,\\\"13\\\":13,\\\"14\\\":14,\\\"15\\\":15,\\\"16\\\":16,\\\"17\\\":17,\\\"18\\\":18,\\\"19\\\":19,\\\"20\\\":20,\\\"21\\\":21,\\\"22\\\":22,\\\"23\\\":23,\\\"24\\\":24,\\\"25\\\":25,\\\"26\\\":26,\\\"27\\\":27,\\\"28\\\":28,\\\"29\\\":29,\\\"30\\\":30,\\\"31\\\":31,\\\"32\\\":32,\\\"33\\\":33,\\\"34\\\":34,\\\"35\\\":35,\\\"36\\\":36,\\\"37\\\":37,\\\"38\\\":38,\\\"39\\\":39,\\\"40\\\":40,\\\"42\\\":42,\\\"43\\\":43,\\\"44\\\":44,\\\"45\\\":45,\\\"46\\\":46,\\\"47\\\":47,\\\"48\\\":48,\\\"8\\\":8,\\\"9\\\":9}],8:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.Bar = function(context, config) {\\n\\t\\tconfig.type = 'bar';\\n\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n\\n},{}],9:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.Bubble = function(context, config) {\\n\\t\\tconfig.type = 'bubble';\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n\\n},{}],10:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.Doughnut = function(context, config) {\\n\\t\\tconfig.type = 'doughnut';\\n\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n\\n},{}],11:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.Line = function(context, config) {\\n\\t\\tconfig.type = 'line';\\n\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n\\n},{}],12:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.PolarArea = function(context, config) {\\n\\t\\tconfig.type = 'polarArea';\\n\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n\\n},{}],13:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.Radar = function(context, config) {\\n\\t\\tconfig.type = 'radar';\\n\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n\\n},{}],14:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar defaultConfig = {\\n\\t\\thover: {\\n\\t\\t\\tmode: 'single'\\n\\t\\t},\\n\\n\\t\\tscales: {\\n\\t\\t\\txAxes: [{\\n\\t\\t\\t\\ttype: 'linear', // scatter should not use a category axis\\n\\t\\t\\t\\tposition: 'bottom',\\n\\t\\t\\t\\tid: 'x-axis-1' // need an ID so datasets can reference the scale\\n\\t\\t\\t}],\\n\\t\\t\\tyAxes: [{\\n\\t\\t\\t\\ttype: 'linear',\\n\\t\\t\\t\\tposition: 'left',\\n\\t\\t\\t\\tid: 'y-axis-1'\\n\\t\\t\\t}]\\n\\t\\t},\\n\\n\\t\\ttooltips: {\\n\\t\\t\\tcallbacks: {\\n\\t\\t\\t\\ttitle: function() {\\n\\t\\t\\t\\t\\t// Title doesn't make sense for scatter since we format the data as a point\\n\\t\\t\\t\\t\\treturn '';\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlabel: function(tooltipItem) {\\n\\t\\t\\t\\t\\treturn '(' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ')';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\t// Register the default config for this type\\n\\tChart.defaults.scatter = defaultConfig;\\n\\n\\t// Scatter charts use line controllers\\n\\tChart.controllers.scatter = Chart.controllers.line;\\n\\n\\tChart.Scatter = function(context, config) {\\n\\t\\tconfig.type = 'scatter';\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n\\n},{}],15:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.bar = {\\n\\t\\thover: {\\n\\t\\t\\tmode: 'label'\\n\\t\\t},\\n\\n\\t\\tscales: {\\n\\t\\t\\txAxes: [{\\n\\t\\t\\t\\ttype: 'category',\\n\\n\\t\\t\\t\\t// Specific to Bar Controller\\n\\t\\t\\t\\tcategoryPercentage: 0.8,\\n\\t\\t\\t\\tbarPercentage: 0.9,\\n\\n\\t\\t\\t\\t// grid line settings\\n\\t\\t\\t\\tgridLines: {\\n\\t\\t\\t\\t\\toffsetGridLines: true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}],\\n\\t\\t\\tyAxes: [{\\n\\t\\t\\t\\ttype: 'linear'\\n\\t\\t\\t}]\\n\\t\\t}\\n\\t};\\n\\n\\tChart.controllers.bar = Chart.DatasetController.extend({\\n\\n\\t\\tdataElementType: Chart.elements.Rectangle,\\n\\n\\t\\tinitialize: function(chart, datasetIndex) {\\n\\t\\t\\tChart.DatasetController.prototype.initialize.call(this, chart, datasetIndex);\\n\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\n\\t\\t\\tmeta.stack = dataset.stack;\\n\\t\\t\\t// Use this to indicate that this is a bar dataset.\\n\\t\\t\\tmeta.bar = true;\\n\\t\\t},\\n\\n\\t\\t// Correctly calculate the bar width accounting for stacks and the fact that not all bars are visible\\n\\t\\tgetStackCount: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\n\\t\\t\\tvar stacks = [];\\n\\t\\t\\thelpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tvar dsMeta = me.chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\tif (dsMeta.bar && me.chart.isDatasetVisible(datasetIndex) &&\\n\\t\\t\\t\\t\\t(yScale.options.stacked === false ||\\n\\t\\t\\t\\t\\t(yScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1) ||\\n\\t\\t\\t\\t\\t(yScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1)))) {\\n\\t\\t\\t\\t\\tstacks.push(dsMeta.stack);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, me);\\n\\n\\t\\t\\treturn stacks.length;\\n\\t\\t},\\n\\n\\t\\tupdate: function(reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\thelpers.each(me.getMeta().data, function(rectangle, index) {\\n\\t\\t\\t\\tme.updateElement(rectangle, index, reset);\\n\\t\\t\\t}, me);\\n\\t\\t},\\n\\n\\t\\tupdateElement: function(rectangle, index, reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar scaleBase = yScale.getBasePixel();\\n\\t\\t\\tvar rectangleElementOptions = me.chart.options.elements.rectangle;\\n\\t\\t\\tvar custom = rectangle.custom || {};\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\n\\t\\t\\trectangle._xScale = xScale;\\n\\t\\t\\trectangle._yScale = yScale;\\n\\t\\t\\trectangle._datasetIndex = me.index;\\n\\t\\t\\trectangle._index = index;\\n\\n\\t\\t\\tvar ruler = me.getRuler(index); // The index argument for compatible\\n\\t\\t\\trectangle._model = {\\n\\t\\t\\t\\tx: me.calculateBarX(index, me.index, ruler),\\n\\t\\t\\t\\ty: reset ? scaleBase : me.calculateBarY(index, me.index),\\n\\n\\t\\t\\t\\t// Tooltip\\n\\t\\t\\t\\tlabel: me.chart.data.labels[index],\\n\\t\\t\\t\\tdatasetLabel: dataset.label,\\n\\n\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\thorizontal: false,\\n\\t\\t\\t\\tbase: reset ? scaleBase : me.calculateBarBase(me.index, index),\\n\\t\\t\\t\\twidth: me.calculateBarWidth(ruler),\\n\\t\\t\\t\\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),\\n\\t\\t\\t\\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,\\n\\t\\t\\t\\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),\\n\\t\\t\\t\\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)\\n\\t\\t\\t};\\n\\n\\t\\t\\trectangle.pivot();\\n\\t\\t},\\n\\n\\t\\tcalculateBarBase: function(datasetIndex, index) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar base = yScale.getBaseValue();\\n\\t\\t\\tvar original = base;\\n\\n\\t\\t\\tif ((yScale.options.stacked === true) ||\\n\\t\\t\\t\\t(yScale.options.stacked === undefined && meta.stack !== undefined)) {\\n\\t\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\t\\tvar datasets = chart.data.datasets;\\n\\t\\t\\t\\tvar value = Number(datasets[datasetIndex].data[index]);\\n\\n\\t\\t\\t\\tfor (var i = 0; i < datasetIndex; i++) {\\n\\t\\t\\t\\t\\tvar currentDs = datasets[i];\\n\\t\\t\\t\\t\\tvar currentDsMeta = chart.getDatasetMeta(i);\\n\\t\\t\\t\\t\\tif (currentDsMeta.bar && currentDsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i) &&\\n\\t\\t\\t\\t\\t\\tmeta.stack === currentDsMeta.stack) {\\n\\t\\t\\t\\t\\t\\tvar currentVal = Number(currentDs.data[index]);\\n\\t\\t\\t\\t\\t\\tbase += value < 0 ? Math.min(currentVal, original) : Math.max(currentVal, original);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn yScale.getPixelForValue(base);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn yScale.getBasePixel();\\n\\t\\t},\\n\\n\\t\\tgetRuler: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar stackCount = me.getStackCount();\\n\\n\\t\\t\\tvar tickWidth = xScale.width / xScale.ticks.length;\\r\\n\\t\\t\\tvar categoryWidth = tickWidth * xScale.options.categoryPercentage;\\n\\t\\t\\tvar categorySpacing = (tickWidth - (tickWidth * xScale.options.categoryPercentage)) / 2;\\n\\t\\t\\tvar fullBarWidth = categoryWidth / stackCount;\\n\\n\\t\\t\\tvar barWidth = fullBarWidth * xScale.options.barPercentage;\\n\\t\\t\\tvar barSpacing = fullBarWidth - (fullBarWidth * xScale.options.barPercentage);\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tstackCount: stackCount,\\n\\t\\t\\t\\ttickWidth: tickWidth,\\n\\t\\t\\t\\tcategoryWidth: categoryWidth,\\n\\t\\t\\t\\tcategorySpacing: categorySpacing,\\n\\t\\t\\t\\tfullBarWidth: fullBarWidth,\\n\\t\\t\\t\\tbarWidth: barWidth,\\n\\t\\t\\t\\tbarSpacing: barSpacing\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\tcalculateBarWidth: function(ruler) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tif (xScale.options.barThickness) {\\n\\t\\t\\t\\treturn xScale.options.barThickness;\\n\\t\\t\\t}\\n\\t\\t\\treturn ruler.barWidth;\\r\\n\\t\\t},\\n\\n\\t\\t// Get stack index from the given dataset index accounting for stacks and the fact that not all bars are visible\\n\\t\\tgetStackIndex: function(datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar dsMeta, j;\\n\\t\\t\\tvar stacks = [meta.stack];\\n\\n\\t\\t\\tfor (j = 0; j < datasetIndex; ++j) {\\n\\t\\t\\t\\tdsMeta = this.chart.getDatasetMeta(j);\\n\\t\\t\\t\\tif (dsMeta.bar && this.chart.isDatasetVisible(j) &&\\n\\t\\t\\t\\t\\t(yScale.options.stacked === false ||\\n\\t\\t\\t\\t\\t(yScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1) ||\\n\\t\\t\\t\\t\\t(yScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1)))) {\\n\\t\\t\\t\\t\\tstacks.push(dsMeta.stack);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn stacks.length - 1;\\n\\t\\t},\\n\\n\\t\\tcalculateBarX: function(index, datasetIndex, ruler) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar stackIndex = me.getStackIndex(datasetIndex);\\n\\t\\t\\tvar leftTick = xScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);\\n\\t\\t\\tleftTick -= me.chart.isCombo ? (ruler.tickWidth / 2) : 0;\\n\\n\\t\\t\\treturn leftTick +\\n\\t\\t\\t\\t(ruler.barWidth / 2) +\\n\\t\\t\\t\\truler.categorySpacing +\\n\\t\\t\\t\\t(ruler.barWidth * stackIndex) +\\n\\t\\t\\t\\t(ruler.barSpacing / 2) +\\n\\t\\t\\t\\t(ruler.barSpacing * stackIndex);\\n\\t\\t},\\n\\n\\t\\tcalculateBarY: function(index, datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar value = Number(me.getDataset().data[index]);\\n\\n\\t\\t\\tif (yScale.options.stacked ||\\n\\t\\t\\t\\t(yScale.options.stacked === undefined && meta.stack !== undefined)) {\\n\\t\\t\\t\\tvar base = yScale.getBaseValue();\\n\\t\\t\\t\\tvar sumPos = base,\\n\\t\\t\\t\\t\\tsumNeg = base;\\r\\n\\n\\t\\t\\t\\tfor (var i = 0; i < datasetIndex; i++) {\\n\\t\\t\\t\\t\\tvar ds = me.chart.data.datasets[i];\\n\\t\\t\\t\\t\\tvar dsMeta = me.chart.getDatasetMeta(i);\\n\\t\\t\\t\\t\\tif (dsMeta.bar && dsMeta.yAxisID === yScale.id && me.chart.isDatasetVisible(i) &&\\n\\t\\t\\t\\t\\t\\tmeta.stack === dsMeta.stack) {\\n\\t\\t\\t\\t\\t\\tvar stackedVal = Number(ds.data[index]);\\n\\t\\t\\t\\t\\t\\tif (stackedVal < 0) {\\n\\t\\t\\t\\t\\t\\t\\tsumNeg += stackedVal || 0;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tsumPos += stackedVal || 0;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (value < 0) {\\n\\t\\t\\t\\t\\treturn yScale.getPixelForValue(sumNeg + value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn yScale.getPixelForValue(sumPos + value);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn yScale.getPixelForValue(value);\\n\\t\\t},\\n\\n\\t\\tdraw: function(ease) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar easingDecimal = ease || 1;\\n\\t\\t\\tvar metaData = me.getMeta().data;\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar i, len;\\n\\n\\t\\t\\tChart.canvasHelpers.clipArea(me.chart.chart.ctx, me.chart.chartArea);\\n\\t\\t\\tfor (i = 0, len = metaData.length; i < len; ++i) {\\n\\t\\t\\t\\tvar d = dataset.data[i];\\n\\t\\t\\t\\tif (d !== null && d !== undefined && !isNaN(d)) {\\n\\t\\t\\t\\t\\tmetaData[i].transition(easingDecimal).draw();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tChart.canvasHelpers.unclipArea(me.chart.chart.ctx);\\n\\t\\t},\\n\\n\\t\\tsetHoverStyle: function(rectangle) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\\n\\t\\t\\tvar index = rectangle._index;\\n\\n\\t\\t\\tvar custom = rectangle.custom || {};\\n\\t\\t\\tvar model = rectangle._model;\\n\\t\\t\\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\\n\\t\\t\\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));\\n\\t\\t\\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(rectangle) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\\n\\t\\t\\tvar index = rectangle._index;\\n\\t\\t\\tvar custom = rectangle.custom || {};\\n\\t\\t\\tvar model = rectangle._model;\\n\\t\\t\\tvar rectangleElementOptions = this.chart.options.elements.rectangle;\\n\\n\\t\\t\\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);\\n\\t\\t\\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);\\n\\t\\t\\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);\\n\\t\\t}\\n\\n\\t});\\n\\n\\n\\t// including horizontalBar in the bar file, instead of a file of its own\\n\\t// it extends bar (like pie extends doughnut)\\n\\tChart.defaults.horizontalBar = {\\n\\t\\thover: {\\n\\t\\t\\tmode: 'label'\\n\\t\\t},\\n\\n\\t\\tscales: {\\n\\t\\t\\txAxes: [{\\n\\t\\t\\t\\ttype: 'linear',\\n\\t\\t\\t\\tposition: 'bottom'\\n\\t\\t\\t}],\\n\\t\\t\\tyAxes: [{\\n\\t\\t\\t\\tposition: 'left',\\n\\t\\t\\t\\ttype: 'category',\\n\\n\\t\\t\\t\\t// Specific to Horizontal Bar Controller\\n\\t\\t\\t\\tcategoryPercentage: 0.8,\\n\\t\\t\\t\\tbarPercentage: 0.9,\\n\\n\\t\\t\\t\\t// grid line settings\\n\\t\\t\\t\\tgridLines: {\\n\\t\\t\\t\\t\\toffsetGridLines: true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}]\\n\\t\\t},\\n\\t\\telements: {\\n\\t\\t\\trectangle: {\\n\\t\\t\\t\\tborderSkipped: 'left'\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\ttooltips: {\\n\\t\\t\\tcallbacks: {\\n\\t\\t\\t\\ttitle: function(tooltipItems, data) {\\n\\t\\t\\t\\t\\t// Pick first xLabel for now\\n\\t\\t\\t\\t\\tvar title = '';\\n\\n\\t\\t\\t\\t\\tif (tooltipItems.length > 0) {\\n\\t\\t\\t\\t\\t\\tif (tooltipItems[0].yLabel) {\\n\\t\\t\\t\\t\\t\\t\\ttitle = tooltipItems[0].yLabel;\\n\\t\\t\\t\\t\\t\\t} else if (data.labels.length > 0 && tooltipItems[0].index < data.labels.length) {\\n\\t\\t\\t\\t\\t\\t\\ttitle = data.labels[tooltipItems[0].index];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn title;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlabel: function(tooltipItem, data) {\\n\\t\\t\\t\\t\\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\\n\\t\\t\\t\\t\\treturn datasetLabel + ': ' + tooltipItem.xLabel;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tChart.controllers.horizontalBar = Chart.controllers.bar.extend({\\n\\n\\t\\t// Correctly calculate the bar width accounting for stacks and the fact that not all bars are visible\\n\\t\\tgetStackCount: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\n\\t\\t\\tvar stacks = [];\\n\\t\\t\\thelpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tvar dsMeta = me.chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\tif (dsMeta.bar && me.chart.isDatasetVisible(datasetIndex) &&\\n\\t\\t\\t\\t\\t(xScale.options.stacked === false ||\\n\\t\\t\\t\\t\\t(xScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1) ||\\n\\t\\t\\t\\t\\t(xScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1)))) {\\n\\t\\t\\t\\t\\tstacks.push(dsMeta.stack);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, me);\\n\\n\\t\\t\\treturn stacks.length;\\n\\t\\t},\\n\\n\\t\\tupdateElement: function(rectangle, index, reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar scaleBase = xScale.getBasePixel();\\n\\t\\t\\tvar custom = rectangle.custom || {};\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar rectangleElementOptions = me.chart.options.elements.rectangle;\\n\\n\\t\\t\\trectangle._xScale = xScale;\\n\\t\\t\\trectangle._yScale = yScale;\\n\\t\\t\\trectangle._datasetIndex = me.index;\\n\\t\\t\\trectangle._index = index;\\n\\n\\t\\t\\tvar ruler = me.getRuler(index); // The index argument for compatible\\n\\t\\t\\trectangle._model = {\\n\\t\\t\\t\\tx: reset ? scaleBase : me.calculateBarX(index, me.index),\\n\\t\\t\\t\\ty: me.calculateBarY(index, me.index, ruler),\\n\\n\\t\\t\\t\\t// Tooltip\\n\\t\\t\\t\\tlabel: me.chart.data.labels[index],\\n\\t\\t\\t\\tdatasetLabel: dataset.label,\\n\\n\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\thorizontal: true,\\n\\t\\t\\t\\tbase: reset ? scaleBase : me.calculateBarBase(me.index, index),\\n\\t\\t\\t\\theight: me.calculateBarHeight(ruler),\\n\\t\\t\\t\\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),\\n\\t\\t\\t\\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,\\n\\t\\t\\t\\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),\\n\\t\\t\\t\\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)\\n\\t\\t\\t};\\n\\n\\t\\t\\trectangle.pivot();\\n\\t\\t},\\n\\n\\t\\tcalculateBarBase: function(datasetIndex, index) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar base = xScale.getBaseValue();\\n\\t\\t\\tvar originalBase = base;\\n\\n\\t\\t\\tif (xScale.options.stacked ||\\n\\t\\t\\t\\t(xScale.options.stacked === undefined && meta.stack !== undefined)) {\\n\\t\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\t\\tvar datasets = chart.data.datasets;\\n\\t\\t\\t\\tvar value = Number(datasets[datasetIndex].data[index]);\\n\\n\\t\\t\\t\\tfor (var i = 0; i < datasetIndex; i++) {\\n\\t\\t\\t\\t\\tvar currentDs = datasets[i];\\n\\t\\t\\t\\t\\tvar currentDsMeta = chart.getDatasetMeta(i);\\n\\t\\t\\t\\t\\tif (currentDsMeta.bar && currentDsMeta.xAxisID === xScale.id && chart.isDatasetVisible(i) &&\\n\\t\\t\\t\\t\\t\\tmeta.stack === currentDsMeta.stack) {\\n\\t\\t\\t\\t\\t\\tvar currentVal = Number(currentDs.data[index]);\\n\\t\\t\\t\\t\\t\\tbase += value < 0 ? Math.min(currentVal, originalBase) : Math.max(currentVal, originalBase);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn xScale.getPixelForValue(base);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn xScale.getBasePixel();\\n\\t\\t},\\n\\n\\t\\tgetRuler: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar stackCount = me.getStackCount();\\n\\n\\t\\t\\tvar tickHeight = yScale.height / yScale.ticks.length;\\n\\t\\t\\tvar categoryHeight = tickHeight * yScale.options.categoryPercentage;\\n\\t\\t\\tvar categorySpacing = (tickHeight - (tickHeight * yScale.options.categoryPercentage)) / 2;\\n\\t\\t\\tvar fullBarHeight = categoryHeight / stackCount;\\n\\n\\t\\t\\tvar barHeight = fullBarHeight * yScale.options.barPercentage;\\n\\t\\t\\tvar barSpacing = fullBarHeight - (fullBarHeight * yScale.options.barPercentage);\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tstackCount: stackCount,\\n\\t\\t\\t\\ttickHeight: tickHeight,\\n\\t\\t\\t\\tcategoryHeight: categoryHeight,\\n\\t\\t\\t\\tcategorySpacing: categorySpacing,\\n\\t\\t\\t\\tfullBarHeight: fullBarHeight,\\n\\t\\t\\t\\tbarHeight: barHeight,\\n\\t\\t\\t\\tbarSpacing: barSpacing\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\tcalculateBarHeight: function(ruler) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tif (yScale.options.barThickness) {\\n\\t\\t\\t\\treturn yScale.options.barThickness;\\n\\t\\t\\t}\\n\\t\\t\\treturn ruler.barHeight;\\n\\t\\t},\\n\\n\\t\\t// Get stack index from the given dataset index accounting for stacks and the fact that not all bars are visible\\n\\t\\tgetStackIndex: function(datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar dsMeta, j;\\n\\t\\t\\tvar stacks = [meta.stack];\\n\\n\\t\\t\\tfor (j = 0; j < datasetIndex; ++j) {\\n\\t\\t\\t\\tdsMeta = this.chart.getDatasetMeta(j);\\n\\t\\t\\t\\tif (dsMeta.bar && this.chart.isDatasetVisible(j) &&\\n\\t\\t\\t\\t\\t(xScale.options.stacked === false ||\\n\\t\\t\\t\\t\\t(xScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1) ||\\n\\t\\t\\t\\t\\t(xScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1)))) {\\n\\t\\t\\t\\t\\tstacks.push(dsMeta.stack);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn stacks.length - 1;\\r\\n\\t\\t},\\n\\n\\t\\tcalculateBarX: function(index, datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar value = Number(me.getDataset().data[index]);\\n\\n\\t\\t\\tif (xScale.options.stacked ||\\n\\t\\t\\t\\t(xScale.options.stacked === undefined && meta.stack !== undefined)) {\\n\\t\\t\\t\\tvar base = xScale.getBaseValue();\\n\\t\\t\\t\\tvar sumPos = base,\\n\\t\\t\\t\\t\\tsumNeg = base;\\r\\n\\n\\t\\t\\t\\tfor (var i = 0; i < datasetIndex; i++) {\\n\\t\\t\\t\\t\\tvar ds = me.chart.data.datasets[i];\\n\\t\\t\\t\\t\\tvar dsMeta = me.chart.getDatasetMeta(i);\\n\\t\\t\\t\\t\\tif (dsMeta.bar && dsMeta.xAxisID === xScale.id && me.chart.isDatasetVisible(i) &&\\n\\t\\t\\t\\t\\t\\tmeta.stack === dsMeta.stack) {\\n\\t\\t\\t\\t\\t\\tvar stackedVal = Number(ds.data[index]);\\n\\t\\t\\t\\t\\t\\tif (stackedVal < 0) {\\n\\t\\t\\t\\t\\t\\t\\tsumNeg += stackedVal || 0;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tsumPos += stackedVal || 0;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (value < 0) {\\n\\t\\t\\t\\t\\treturn xScale.getPixelForValue(sumNeg + value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn xScale.getPixelForValue(sumPos + value);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn xScale.getPixelForValue(value);\\n\\t\\t},\\n\\n\\t\\tcalculateBarY: function(index, datasetIndex, ruler) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar stackIndex = me.getStackIndex(datasetIndex);\\n\\t\\t\\tvar topTick = yScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);\\n\\t\\t\\ttopTick -= me.chart.isCombo ? (ruler.tickHeight / 2) : 0;\\n\\n\\t\\t\\treturn topTick +\\n\\t\\t\\t\\t(ruler.barHeight / 2) +\\n\\t\\t\\t\\truler.categorySpacing +\\n\\t\\t\\t\\t(ruler.barHeight * stackIndex) +\\n\\t\\t\\t\\t(ruler.barSpacing / 2) +\\n\\t\\t\\t\\t(ruler.barSpacing * stackIndex);\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],16:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.bubble = {\\n\\t\\thover: {\\n\\t\\t\\tmode: 'single'\\n\\t\\t},\\n\\n\\t\\tscales: {\\n\\t\\t\\txAxes: [{\\n\\t\\t\\t\\ttype: 'linear', // bubble should probably use a linear scale by default\\n\\t\\t\\t\\tposition: 'bottom',\\n\\t\\t\\t\\tid: 'x-axis-0' // need an ID so datasets can reference the scale\\n\\t\\t\\t}],\\n\\t\\t\\tyAxes: [{\\n\\t\\t\\t\\ttype: 'linear',\\n\\t\\t\\t\\tposition: 'left',\\n\\t\\t\\t\\tid: 'y-axis-0'\\n\\t\\t\\t}]\\n\\t\\t},\\n\\n\\t\\ttooltips: {\\n\\t\\t\\tcallbacks: {\\n\\t\\t\\t\\ttitle: function() {\\n\\t\\t\\t\\t\\t// Title doesn't make sense for scatter since we format the data as a point\\n\\t\\t\\t\\t\\treturn '';\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlabel: function(tooltipItem, data) {\\n\\t\\t\\t\\t\\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\\n\\t\\t\\t\\t\\tvar dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\\n\\t\\t\\t\\t\\treturn datasetLabel + ': (' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ', ' + dataPoint.r + ')';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tChart.controllers.bubble = Chart.DatasetController.extend({\\n\\n\\t\\tdataElementType: Chart.elements.Point,\\n\\n\\t\\tupdate: function(reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar points = meta.data;\\n\\n\\t\\t\\t// Update Points\\n\\t\\t\\thelpers.each(points, function(point, index) {\\n\\t\\t\\t\\tme.updateElement(point, index, reset);\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tupdateElement: function(point, index, reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar data = dataset.data[index];\\n\\t\\t\\tvar pointElementOptions = me.chart.options.elements.point;\\n\\t\\t\\tvar dsIndex = me.index;\\n\\n\\t\\t\\thelpers.extend(point, {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\t_xScale: xScale,\\n\\t\\t\\t\\t_yScale: yScale,\\n\\t\\t\\t\\t_datasetIndex: dsIndex,\\n\\t\\t\\t\\t_index: index,\\n\\n\\t\\t\\t\\t// Desired view properties\\n\\t\\t\\t\\t_model: {\\n\\t\\t\\t\\t\\tx: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex, me.chart.isCombo),\\n\\t\\t\\t\\t\\ty: reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex),\\n\\t\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\t\\tradius: reset ? 0 : custom.radius ? custom.radius : me.getRadius(data),\\n\\n\\t\\t\\t\\t\\t// Tooltip\\n\\t\\t\\t\\t\\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Trick to reset the styles of the point\\n\\t\\t\\tChart.DatasetController.prototype.removeHoverStyle.call(me, point, pointElementOptions);\\n\\n\\t\\t\\tvar model = point._model;\\n\\t\\t\\tmodel.skip = custom.skip ? custom.skip : (isNaN(model.x) || isNaN(model.y));\\n\\n\\t\\t\\tpoint.pivot();\\n\\t\\t},\\n\\n\\t\\tgetRadius: function(value) {\\n\\t\\t\\treturn value.r || this.chart.options.elements.point.radius;\\n\\t\\t},\\n\\n\\t\\tsetHoverStyle: function(point) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tChart.DatasetController.prototype.setHoverStyle.call(me, point);\\n\\n\\t\\t\\t// Radius\\n\\t\\t\\tvar dataset = me.chart.data.datasets[point._datasetIndex];\\n\\t\\t\\tvar index = point._index;\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar model = point._model;\\n\\t\\t\\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : (helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, me.chart.options.elements.point.hoverRadius)) + me.getRadius(dataset.data[index]);\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(point) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tChart.DatasetController.prototype.removeHoverStyle.call(me, point, me.chart.options.elements.point);\\n\\n\\t\\t\\tvar dataVal = me.chart.data.datasets[point._datasetIndex].data[point._index];\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar model = point._model;\\n\\n\\t\\t\\tmodel.radius = custom.radius ? custom.radius : me.getRadius(dataVal);\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],17:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers,\\n\\t\\tdefaults = Chart.defaults;\\n\\n\\tdefaults.doughnut = {\\n\\t\\tanimation: {\\n\\t\\t\\t// Boolean - Whether we animate the rotation of the Doughnut\\n\\t\\t\\tanimateRotate: true,\\n\\t\\t\\t// Boolean - Whether we animate scaling the Doughnut from the centre\\n\\t\\t\\tanimateScale: false\\n\\t\\t},\\n\\t\\taspectRatio: 1,\\n\\t\\thover: {\\n\\t\\t\\tmode: 'single'\\n\\t\\t},\\n\\t\\tlegendCallback: function(chart) {\\n\\t\\t\\tvar text = [];\\n\\t\\t\\ttext.push('<ul class=\\\"' + chart.id + '-legend\\\">');\\n\\n\\t\\t\\tvar data = chart.data;\\n\\t\\t\\tvar datasets = data.datasets;\\n\\t\\t\\tvar labels = data.labels;\\n\\n\\t\\t\\tif (datasets.length) {\\n\\t\\t\\t\\tfor (var i = 0; i < datasets[0].data.length; ++i) {\\n\\t\\t\\t\\t\\ttext.push('<li><span style=\\\"background-color:' + datasets[0].backgroundColor[i] + '\\\"></span>');\\n\\t\\t\\t\\t\\tif (labels[i]) {\\n\\t\\t\\t\\t\\t\\ttext.push(labels[i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttext.push('</li>');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\ttext.push('</ul>');\\n\\t\\t\\treturn text.join('');\\n\\t\\t},\\n\\t\\tlegend: {\\n\\t\\t\\tlabels: {\\n\\t\\t\\t\\tgenerateLabels: function(chart) {\\n\\t\\t\\t\\t\\tvar data = chart.data;\\n\\t\\t\\t\\t\\tif (data.labels.length && data.datasets.length) {\\n\\t\\t\\t\\t\\t\\treturn data.labels.map(function(label, i) {\\n\\t\\t\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(0);\\n\\t\\t\\t\\t\\t\\t\\tvar ds = data.datasets[0];\\n\\t\\t\\t\\t\\t\\t\\tvar arc = meta.data[i];\\n\\t\\t\\t\\t\\t\\t\\tvar custom = arc && arc.custom || {};\\n\\t\\t\\t\\t\\t\\t\\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\\n\\t\\t\\t\\t\\t\\t\\tvar arcOpts = chart.options.elements.arc;\\n\\t\\t\\t\\t\\t\\t\\tvar fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\\n\\t\\t\\t\\t\\t\\t\\tvar stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\\n\\t\\t\\t\\t\\t\\t\\tvar bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\\n\\n\\t\\t\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\t\\t\\ttext: label,\\n\\t\\t\\t\\t\\t\\t\\t\\tfillStyle: fill,\\n\\t\\t\\t\\t\\t\\t\\t\\tstrokeStyle: stroke,\\n\\t\\t\\t\\t\\t\\t\\t\\tlineWidth: bw,\\n\\t\\t\\t\\t\\t\\t\\t\\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Extra data used for toggling the correct item\\n\\t\\t\\t\\t\\t\\t\\t\\tindex: i\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tonClick: function(e, legendItem) {\\n\\t\\t\\t\\tvar index = legendItem.index;\\n\\t\\t\\t\\tvar chart = this.chart;\\n\\t\\t\\t\\tvar i, ilen, meta;\\n\\n\\t\\t\\t\\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\\n\\t\\t\\t\\t\\tmeta = chart.getDatasetMeta(i);\\n\\t\\t\\t\\t\\t// toggle visibility of index if exists\\n\\t\\t\\t\\t\\tif (meta.data[index]) {\\n\\t\\t\\t\\t\\t\\tmeta.data[index].hidden = !meta.data[index].hidden;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tchart.update();\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t// The percentage of the chart that we cut out of the middle.\\n\\t\\tcutoutPercentage: 50,\\n\\n\\t\\t// The rotation of the chart, where the first data arc begins.\\n\\t\\trotation: Math.PI * -0.5,\\n\\n\\t\\t// The total circumference of the chart.\\n\\t\\tcircumference: Math.PI * 2.0,\\n\\n\\t\\t// Need to override these to give a nice default\\n\\t\\ttooltips: {\\n\\t\\t\\tcallbacks: {\\n\\t\\t\\t\\ttitle: function() {\\n\\t\\t\\t\\t\\treturn '';\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlabel: function(tooltipItem, data) {\\n\\t\\t\\t\\t\\tvar dataLabel = data.labels[tooltipItem.index];\\n\\t\\t\\t\\t\\tvar value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\\n\\n\\t\\t\\t\\t\\tif (helpers.isArray(dataLabel)) {\\n\\t\\t\\t\\t\\t\\t// show value on first line of multiline label\\n\\t\\t\\t\\t\\t\\t// need to clone because we are changing the value\\n\\t\\t\\t\\t\\t\\tdataLabel = dataLabel.slice();\\n\\t\\t\\t\\t\\t\\tdataLabel[0] += value;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tdataLabel += value;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn dataLabel;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tdefaults.pie = helpers.clone(defaults.doughnut);\\n\\thelpers.extend(defaults.pie, {\\n\\t\\tcutoutPercentage: 0\\n\\t});\\n\\n\\n\\tChart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({\\n\\n\\t\\tdataElementType: Chart.elements.Arc,\\n\\n\\t\\tlinkScales: helpers.noop,\\n\\n\\t\\t// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\\n\\t\\tgetRingIndex: function(datasetIndex) {\\n\\t\\t\\tvar ringIndex = 0;\\n\\n\\t\\t\\tfor (var j = 0; j < datasetIndex; ++j) {\\n\\t\\t\\t\\tif (this.chart.isDatasetVisible(j)) {\\n\\t\\t\\t\\t\\t++ringIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ringIndex;\\n\\t\\t},\\n\\n\\t\\tupdate: function(reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar chart = me.chart,\\n\\t\\t\\t\\tchartArea = chart.chartArea,\\n\\t\\t\\t\\topts = chart.options,\\n\\t\\t\\t\\tarcOpts = opts.elements.arc,\\n\\t\\t\\t\\tavailableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth,\\n\\t\\t\\t\\tavailableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth,\\n\\t\\t\\t\\tminSize = Math.min(availableWidth, availableHeight),\\n\\t\\t\\t\\toffset = {\\n\\t\\t\\t\\t\\tx: 0,\\n\\t\\t\\t\\t\\ty: 0\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tmeta = me.getMeta(),\\n\\t\\t\\t\\tcutoutPercentage = opts.cutoutPercentage,\\n\\t\\t\\t\\tcircumference = opts.circumference;\\n\\n\\t\\t\\t// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc\\n\\t\\t\\tif (circumference < Math.PI * 2.0) {\\n\\t\\t\\t\\tvar startAngle = opts.rotation % (Math.PI * 2.0);\\n\\t\\t\\t\\tstartAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);\\n\\t\\t\\t\\tvar endAngle = startAngle + circumference;\\n\\t\\t\\t\\tvar start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};\\n\\t\\t\\t\\tvar end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};\\n\\t\\t\\t\\tvar contains0 = (startAngle <= 0 && 0 <= endAngle) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);\\n\\t\\t\\t\\tvar contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);\\n\\t\\t\\t\\tvar contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);\\n\\t\\t\\t\\tvar contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);\\n\\t\\t\\t\\tvar cutout = cutoutPercentage / 100.0;\\n\\t\\t\\t\\tvar min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};\\n\\t\\t\\t\\tvar max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};\\n\\t\\t\\t\\tvar size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};\\n\\t\\t\\t\\tminSize = Math.min(availableWidth / size.width, availableHeight / size.height);\\n\\t\\t\\t\\toffset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};\\n\\t\\t\\t}\\n\\n\\t\\t\\tchart.borderWidth = me.getMaxBorderWidth(meta.data);\\n\\t\\t\\tchart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);\\n\\t\\t\\tchart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);\\n\\t\\t\\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\\n\\t\\t\\tchart.offsetX = offset.x * chart.outerRadius;\\n\\t\\t\\tchart.offsetY = offset.y * chart.outerRadius;\\n\\n\\t\\t\\tmeta.total = me.calculateTotal();\\n\\n\\t\\t\\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));\\n\\t\\t\\tme.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);\\n\\n\\t\\t\\thelpers.each(meta.data, function(arc, index) {\\n\\t\\t\\t\\tme.updateElement(arc, index, reset);\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tupdateElement: function(arc, index, reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar chart = me.chart,\\n\\t\\t\\t\\tchartArea = chart.chartArea,\\n\\t\\t\\t\\topts = chart.options,\\n\\t\\t\\t\\tanimationOpts = opts.animation,\\n\\t\\t\\t\\tcenterX = (chartArea.left + chartArea.right) / 2,\\n\\t\\t\\t\\tcenterY = (chartArea.top + chartArea.bottom) / 2,\\n\\t\\t\\t\\tstartAngle = opts.rotation, // non reset case handled later\\n\\t\\t\\t\\tendAngle = opts.rotation, // non reset case handled later\\n\\t\\t\\t\\tdataset = me.getDataset(),\\n\\t\\t\\t\\tcircumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),\\n\\t\\t\\t\\tinnerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius,\\n\\t\\t\\t\\touterRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius,\\n\\t\\t\\t\\tvalueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\\n\\n\\t\\t\\thelpers.extend(arc, {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\t_datasetIndex: me.index,\\n\\t\\t\\t\\t_index: index,\\n\\n\\t\\t\\t\\t// Desired view properties\\n\\t\\t\\t\\t_model: {\\n\\t\\t\\t\\t\\tx: centerX + chart.offsetX,\\n\\t\\t\\t\\t\\ty: centerY + chart.offsetY,\\n\\t\\t\\t\\t\\tstartAngle: startAngle,\\n\\t\\t\\t\\t\\tendAngle: endAngle,\\n\\t\\t\\t\\t\\tcircumference: circumference,\\n\\t\\t\\t\\t\\touterRadius: outerRadius,\\n\\t\\t\\t\\t\\tinnerRadius: innerRadius,\\n\\t\\t\\t\\t\\tlabel: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tvar model = arc._model;\\n\\t\\t\\t// Resets the visual styles\\n\\t\\t\\tthis.removeHoverStyle(arc);\\n\\n\\t\\t\\t// Set correct angles if not resetting\\n\\t\\t\\tif (!reset || !animationOpts.animateRotate) {\\n\\t\\t\\t\\tif (index === 0) {\\n\\t\\t\\t\\t\\tmodel.startAngle = opts.rotation;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmodel.startAngle = me.getMeta().data[index - 1]._model.endAngle;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tmodel.endAngle = model.startAngle + model.circumference;\\n\\t\\t\\t}\\n\\n\\t\\t\\tarc.pivot();\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(arc) {\\n\\t\\t\\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\\n\\t\\t},\\n\\n\\t\\tcalculateTotal: function() {\\n\\t\\t\\tvar dataset = this.getDataset();\\n\\t\\t\\tvar meta = this.getMeta();\\n\\t\\t\\tvar total = 0;\\n\\t\\t\\tvar value;\\n\\n\\t\\t\\thelpers.each(meta.data, function(element, index) {\\n\\t\\t\\t\\tvalue = dataset.data[index];\\n\\t\\t\\t\\tif (!isNaN(value) && !element.hidden) {\\n\\t\\t\\t\\t\\ttotal += Math.abs(value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\t/* if (total === 0) {\\n\\t\\t\\t\\ttotal = NaN;\\n\\t\\t\\t}*/\\n\\n\\t\\t\\treturn total;\\n\\t\\t},\\n\\n\\t\\tcalculateCircumference: function(value) {\\n\\t\\t\\tvar total = this.getMeta().total;\\n\\t\\t\\tif (total > 0 && !isNaN(value)) {\\n\\t\\t\\t\\treturn (Math.PI * 2.0) * (value / total);\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t},\\n\\n\\t\\t// gets the max border or hover width to properly scale pie charts\\n\\t\\tgetMaxBorderWidth: function(elements) {\\n\\t\\t\\tvar max = 0,\\n\\t\\t\\t\\tindex = this.index,\\n\\t\\t\\t\\tlength = elements.length,\\n\\t\\t\\t\\tborderWidth,\\n\\t\\t\\t\\thoverWidth;\\n\\n\\t\\t\\tfor (var i = 0; i < length; i++) {\\n\\t\\t\\t\\tborderWidth = elements[i]._model ? elements[i]._model.borderWidth : 0;\\n\\t\\t\\t\\thoverWidth = elements[i]._chart ? elements[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;\\n\\n\\t\\t\\t\\tmax = borderWidth > max ? borderWidth : max;\\n\\t\\t\\t\\tmax = hoverWidth > max ? hoverWidth : max;\\n\\t\\t\\t}\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],18:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.line = {\\n\\t\\tshowLines: true,\\n\\t\\tspanGaps: false,\\n\\n\\t\\thover: {\\n\\t\\t\\tmode: 'label'\\n\\t\\t},\\n\\n\\t\\tscales: {\\n\\t\\t\\txAxes: [{\\n\\t\\t\\t\\ttype: 'category',\\n\\t\\t\\t\\tid: 'x-axis-0'\\n\\t\\t\\t}],\\n\\t\\t\\tyAxes: [{\\n\\t\\t\\t\\ttype: 'linear',\\n\\t\\t\\t\\tid: 'y-axis-0'\\n\\t\\t\\t}]\\n\\t\\t}\\n\\t};\\n\\n\\tfunction lineEnabled(dataset, options) {\\n\\t\\treturn helpers.getValueOrDefault(dataset.showLine, options.showLines);\\n\\t}\\n\\n\\tChart.controllers.line = Chart.DatasetController.extend({\\n\\n\\t\\tdatasetElementType: Chart.elements.Line,\\n\\n\\t\\tdataElementType: Chart.elements.Point,\\n\\n\\t\\tupdate: function(reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar line = meta.dataset;\\n\\t\\t\\tvar points = meta.data || [];\\n\\t\\t\\tvar options = me.chart.options;\\n\\t\\t\\tvar lineElementOptions = options.elements.line;\\n\\t\\t\\tvar scale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar i, ilen, custom;\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar showLine = lineEnabled(dataset, options);\\n\\n\\t\\t\\t// Update Line\\n\\t\\t\\tif (showLine) {\\n\\t\\t\\t\\tcustom = line.custom || {};\\n\\n\\t\\t\\t\\t// Compatibility: If the properties are defined with only the old name, use those values\\n\\t\\t\\t\\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\\n\\t\\t\\t\\t\\tdataset.lineTension = dataset.tension;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\tline._scale = scale;\\n\\t\\t\\t\\tline._datasetIndex = me.index;\\n\\t\\t\\t\\t// Data\\n\\t\\t\\t\\tline._children = points;\\n\\t\\t\\t\\t// Model\\n\\t\\t\\t\\tline._model = {\\n\\t\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\t\\t// The default behavior of lines is to break at null values, according\\n\\t\\t\\t\\t\\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\\n\\t\\t\\t\\t\\t// This option gives lines the ability to span gaps\\n\\t\\t\\t\\t\\tspanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,\\n\\t\\t\\t\\t\\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\\n\\t\\t\\t\\t\\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\\n\\t\\t\\t\\t\\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\\n\\t\\t\\t\\t\\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\\n\\t\\t\\t\\t\\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\\n\\t\\t\\t\\t\\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\\n\\t\\t\\t\\t\\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\\n\\t\\t\\t\\t\\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\\n\\t\\t\\t\\t\\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\\n\\t\\t\\t\\t\\tsteppedLine: custom.steppedLine ? custom.steppedLine : helpers.getValueOrDefault(dataset.steppedLine, lineElementOptions.stepped),\\n\\t\\t\\t\\t\\tcubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.getValueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),\\n\\t\\t\\t\\t\\t// Scale\\n\\t\\t\\t\\t\\tscaleTop: scale.top,\\n\\t\\t\\t\\t\\tscaleBottom: scale.bottom,\\n\\t\\t\\t\\t\\tscaleZero: scale.getBasePixel()\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tline.pivot();\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update Points\\n\\t\\t\\tfor (i=0, ilen=points.length; i<ilen; ++i) {\\n\\t\\t\\t\\tme.updateElement(points[i], i, reset);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (showLine && line._model.tension !== 0) {\\n\\t\\t\\t\\tme.updateBezierControlPoints();\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Now pivot the point for animation\\n\\t\\t\\tfor (i=0, ilen=points.length; i<ilen; ++i) {\\n\\t\\t\\t\\tpoints[i].pivot();\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tgetPointBackgroundColor: function(point, index) {\\n\\t\\t\\tvar backgroundColor = this.chart.options.elements.point.backgroundColor;\\n\\t\\t\\tvar dataset = this.getDataset();\\n\\t\\t\\tvar custom = point.custom || {};\\n\\n\\t\\t\\tif (custom.backgroundColor) {\\n\\t\\t\\t\\tbackgroundColor = custom.backgroundColor;\\n\\t\\t\\t} else if (dataset.pointBackgroundColor) {\\n\\t\\t\\t\\tbackgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);\\n\\t\\t\\t} else if (dataset.backgroundColor) {\\n\\t\\t\\t\\tbackgroundColor = dataset.backgroundColor;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn backgroundColor;\\n\\t\\t},\\n\\n\\t\\tgetPointBorderColor: function(point, index) {\\n\\t\\t\\tvar borderColor = this.chart.options.elements.point.borderColor;\\n\\t\\t\\tvar dataset = this.getDataset();\\n\\t\\t\\tvar custom = point.custom || {};\\n\\n\\t\\t\\tif (custom.borderColor) {\\n\\t\\t\\t\\tborderColor = custom.borderColor;\\n\\t\\t\\t} else if (dataset.pointBorderColor) {\\n\\t\\t\\t\\tborderColor = helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);\\n\\t\\t\\t} else if (dataset.borderColor) {\\n\\t\\t\\t\\tborderColor = dataset.borderColor;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn borderColor;\\n\\t\\t},\\n\\n\\t\\tgetPointBorderWidth: function(point, index) {\\n\\t\\t\\tvar borderWidth = this.chart.options.elements.point.borderWidth;\\n\\t\\t\\tvar dataset = this.getDataset();\\n\\t\\t\\tvar custom = point.custom || {};\\n\\n\\t\\t\\tif (!isNaN(custom.borderWidth)) {\\n\\t\\t\\t\\tborderWidth = custom.borderWidth;\\n\\t\\t\\t} else if (!isNaN(dataset.pointBorderWidth)) {\\n\\t\\t\\t\\tborderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);\\n\\t\\t\\t} else if (!isNaN(dataset.borderWidth)) {\\n\\t\\t\\t\\tborderWidth = dataset.borderWidth;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn borderWidth;\\n\\t\\t},\\n\\n\\t\\tupdateElement: function(point, index, reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar datasetIndex = me.index;\\n\\t\\t\\tvar value = dataset.data[index];\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar pointOptions = me.chart.options.elements.point;\\n\\t\\t\\tvar x, y;\\n\\t\\t\\tvar labels = me.chart.data.labels || [];\\n\\t\\t\\tvar includeOffset = (labels.length === 1 || dataset.data.length === 1) || me.chart.isCombo;\\n\\n\\t\\t\\t// Compatibility: If the properties are defined with only the old name, use those values\\n\\t\\t\\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\\n\\t\\t\\t\\tdataset.pointRadius = dataset.radius;\\n\\t\\t\\t}\\n\\t\\t\\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\\n\\t\\t\\t\\tdataset.pointHitRadius = dataset.hitRadius;\\n\\t\\t\\t}\\n\\n\\t\\t\\tx = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex, includeOffset);\\n\\t\\t\\ty = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\\n\\n\\t\\t\\t// Utility\\n\\t\\t\\tpoint._xScale = xScale;\\n\\t\\t\\tpoint._yScale = yScale;\\n\\t\\t\\tpoint._datasetIndex = datasetIndex;\\n\\t\\t\\tpoint._index = index;\\n\\n\\t\\t\\t// Desired view properties\\n\\t\\t\\tpoint._model = {\\n\\t\\t\\t\\tx: x,\\n\\t\\t\\t\\ty: y,\\n\\t\\t\\t\\tskip: custom.skip || isNaN(x) || isNaN(y),\\n\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\tradius: custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),\\n\\t\\t\\t\\tpointStyle: custom.pointStyle || helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),\\n\\t\\t\\t\\tbackgroundColor: me.getPointBackgroundColor(point, index),\\n\\t\\t\\t\\tborderColor: me.getPointBorderColor(point, index),\\n\\t\\t\\t\\tborderWidth: me.getPointBorderWidth(point, index),\\n\\t\\t\\t\\ttension: meta.dataset._model ? meta.dataset._model.tension : 0,\\n\\t\\t\\t\\tsteppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,\\n\\t\\t\\t\\t// Tooltip\\n\\t\\t\\t\\thitRadius: custom.hitRadius || helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\tcalculatePointY: function(value, index, datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar sumPos = 0;\\n\\t\\t\\tvar sumNeg = 0;\\n\\t\\t\\tvar i, ds, dsMeta;\\n\\n\\t\\t\\tif (yScale.options.stacked) {\\n\\t\\t\\t\\tfor (i = 0; i < datasetIndex; i++) {\\n\\t\\t\\t\\t\\tds = chart.data.datasets[i];\\n\\t\\t\\t\\t\\tdsMeta = chart.getDatasetMeta(i);\\n\\t\\t\\t\\t\\tif (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\\n\\t\\t\\t\\t\\t\\tvar stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\\n\\t\\t\\t\\t\\t\\tif (stackedRightValue < 0) {\\n\\t\\t\\t\\t\\t\\t\\tsumNeg += stackedRightValue || 0;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tsumPos += stackedRightValue || 0;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar rightValue = Number(yScale.getRightValue(value));\\n\\t\\t\\t\\tif (rightValue < 0) {\\n\\t\\t\\t\\t\\treturn yScale.getPixelForValue(sumNeg + rightValue);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn yScale.getPixelForValue(sumPos + rightValue);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn yScale.getPixelForValue(value);\\n\\t\\t},\\n\\n\\t\\tupdateBezierControlPoints: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar area = me.chart.chartArea;\\n\\t\\t\\tvar points = (meta.data || []);\\n\\t\\t\\tvar i, ilen, point, model, controlPoints;\\n\\n\\t\\t\\t// Only consider points that are drawn in case the spanGaps option is used\\n\\t\\t\\tif (meta.dataset._model.spanGaps) {\\n\\t\\t\\t\\tpoints = points.filter(function(pt) {\\n\\t\\t\\t\\t\\treturn !pt._model.skip;\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction capControlPoint(pt, min, max) {\\n\\t\\t\\t\\treturn Math.max(Math.min(pt, max), min);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (meta.dataset._model.cubicInterpolationMode === 'monotone') {\\n\\t\\t\\t\\thelpers.splineCurveMonotone(points);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\\n\\t\\t\\t\\t\\tpoint = points[i];\\n\\t\\t\\t\\t\\tmodel = point._model;\\n\\t\\t\\t\\t\\tcontrolPoints = helpers.splineCurve(\\n\\t\\t\\t\\t\\t\\thelpers.previousItem(points, i)._model,\\n\\t\\t\\t\\t\\t\\tmodel,\\n\\t\\t\\t\\t\\t\\thelpers.nextItem(points, i)._model,\\n\\t\\t\\t\\t\\t\\tmeta.dataset._model.tension\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\tmodel.controlPointPreviousX = controlPoints.previous.x;\\n\\t\\t\\t\\t\\tmodel.controlPointPreviousY = controlPoints.previous.y;\\n\\t\\t\\t\\t\\tmodel.controlPointNextX = controlPoints.next.x;\\n\\t\\t\\t\\t\\tmodel.controlPointNextY = controlPoints.next.y;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (me.chart.options.elements.line.capBezierPoints) {\\n\\t\\t\\t\\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\\n\\t\\t\\t\\t\\tmodel = points[i]._model;\\n\\t\\t\\t\\t\\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\\n\\t\\t\\t\\t\\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\\n\\t\\t\\t\\t\\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\\n\\t\\t\\t\\t\\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tdraw: function(ease) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar points = meta.data || [];\\n\\t\\t\\tvar easingDecimal = ease || 1;\\n\\t\\t\\tvar i, ilen;\\n\\n\\t\\t\\t// Transition Point Locations\\n\\t\\t\\tfor (i=0, ilen=points.length; i<ilen; ++i) {\\n\\t\\t\\t\\tpoints[i].transition(easingDecimal);\\n\\t\\t\\t}\\n\\n\\t\\t\\tChart.canvasHelpers.clipArea(me.chart.chart.ctx, me.chart.chartArea);\\n\\t\\t\\t// Transition and Draw the line\\n\\t\\t\\tif (lineEnabled(me.getDataset(), me.chart.options)) {\\n\\t\\t\\t\\tmeta.dataset.transition(easingDecimal).draw();\\n\\t\\t\\t}\\n\\t\\t\\tChart.canvasHelpers.unclipArea(me.chart.chart.ctx);\\n\\n\\t\\t\\t// Draw the points\\n\\t\\t\\tfor (i=0, ilen=points.length; i<ilen; ++i) {\\n\\t\\t\\t\\tpoints[i].draw(me.chart.chartArea);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tsetHoverStyle: function(point) {\\n\\t\\t\\t// Point\\n\\t\\t\\tvar dataset = this.chart.data.datasets[point._datasetIndex];\\n\\t\\t\\tvar index = point._index;\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar model = point._model;\\n\\n\\t\\t\\tmodel.radius = custom.hoverRadius || helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\\n\\t\\t\\tmodel.backgroundColor = custom.hoverBackgroundColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\\n\\t\\t\\tmodel.borderColor = custom.hoverBorderColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\\n\\t\\t\\tmodel.borderWidth = custom.hoverBorderWidth || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(point) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar dataset = me.chart.data.datasets[point._datasetIndex];\\n\\t\\t\\tvar index = point._index;\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar model = point._model;\\n\\n\\t\\t\\t// Compatibility: If the properties are defined with only the old name, use those values\\n\\t\\t\\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\\n\\t\\t\\t\\tdataset.pointRadius = dataset.radius;\\n\\t\\t\\t}\\n\\n\\t\\t\\tmodel.radius = custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);\\n\\t\\t\\tmodel.backgroundColor = me.getPointBackgroundColor(point, index);\\n\\t\\t\\tmodel.borderColor = me.getPointBorderColor(point, index);\\n\\t\\t\\tmodel.borderWidth = me.getPointBorderWidth(point, index);\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],19:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.polarArea = {\\n\\n\\t\\tscale: {\\n\\t\\t\\ttype: 'radialLinear',\\n\\t\\t\\tlineArc: true, // so that lines are circular\\n\\t\\t\\tticks: {\\n\\t\\t\\t\\tbeginAtZero: true\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t// Boolean - Whether to animate the rotation of the chart\\n\\t\\tanimation: {\\n\\t\\t\\tanimateRotate: true,\\n\\t\\t\\tanimateScale: true\\n\\t\\t},\\n\\n\\t\\tstartAngle: -0.5 * Math.PI,\\n\\t\\taspectRatio: 1,\\n\\t\\tlegendCallback: function(chart) {\\n\\t\\t\\tvar text = [];\\n\\t\\t\\ttext.push('<ul class=\\\"' + chart.id + '-legend\\\">');\\n\\n\\t\\t\\tvar data = chart.data;\\n\\t\\t\\tvar datasets = data.datasets;\\n\\t\\t\\tvar labels = data.labels;\\n\\n\\t\\t\\tif (datasets.length) {\\n\\t\\t\\t\\tfor (var i = 0; i < datasets[0].data.length; ++i) {\\n\\t\\t\\t\\t\\ttext.push('<li><span style=\\\"background-color:' + datasets[0].backgroundColor[i] + '\\\"></span>');\\n\\t\\t\\t\\t\\tif (labels[i]) {\\n\\t\\t\\t\\t\\t\\ttext.push(labels[i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttext.push('</li>');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\ttext.push('</ul>');\\n\\t\\t\\treturn text.join('');\\n\\t\\t},\\n\\t\\tlegend: {\\n\\t\\t\\tlabels: {\\n\\t\\t\\t\\tgenerateLabels: function(chart) {\\n\\t\\t\\t\\t\\tvar data = chart.data;\\n\\t\\t\\t\\t\\tif (data.labels.length && data.datasets.length) {\\n\\t\\t\\t\\t\\t\\treturn data.labels.map(function(label, i) {\\n\\t\\t\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(0);\\n\\t\\t\\t\\t\\t\\t\\tvar ds = data.datasets[0];\\n\\t\\t\\t\\t\\t\\t\\tvar arc = meta.data[i];\\n\\t\\t\\t\\t\\t\\t\\tvar custom = arc.custom || {};\\n\\t\\t\\t\\t\\t\\t\\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\\n\\t\\t\\t\\t\\t\\t\\tvar arcOpts = chart.options.elements.arc;\\n\\t\\t\\t\\t\\t\\t\\tvar fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\\n\\t\\t\\t\\t\\t\\t\\tvar stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\\n\\t\\t\\t\\t\\t\\t\\tvar bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\\n\\n\\t\\t\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\t\\t\\ttext: label,\\n\\t\\t\\t\\t\\t\\t\\t\\tfillStyle: fill,\\n\\t\\t\\t\\t\\t\\t\\t\\tstrokeStyle: stroke,\\n\\t\\t\\t\\t\\t\\t\\t\\tlineWidth: bw,\\n\\t\\t\\t\\t\\t\\t\\t\\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Extra data used for toggling the correct item\\n\\t\\t\\t\\t\\t\\t\\t\\tindex: i\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tonClick: function(e, legendItem) {\\n\\t\\t\\t\\tvar index = legendItem.index;\\n\\t\\t\\t\\tvar chart = this.chart;\\n\\t\\t\\t\\tvar i, ilen, meta;\\n\\n\\t\\t\\t\\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\\n\\t\\t\\t\\t\\tmeta = chart.getDatasetMeta(i);\\n\\t\\t\\t\\t\\tmeta.data[index].hidden = !meta.data[index].hidden;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tchart.update();\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t// Need to override these to give a nice default\\n\\t\\ttooltips: {\\n\\t\\t\\tcallbacks: {\\n\\t\\t\\t\\ttitle: function() {\\n\\t\\t\\t\\t\\treturn '';\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlabel: function(tooltipItem, data) {\\n\\t\\t\\t\\t\\treturn data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tChart.controllers.polarArea = Chart.DatasetController.extend({\\n\\n\\t\\tdataElementType: Chart.elements.Arc,\\n\\n\\t\\tlinkScales: helpers.noop,\\n\\n\\t\\tupdate: function(reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\tvar chartArea = chart.chartArea;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar opts = chart.options;\\n\\t\\t\\tvar arcOpts = opts.elements.arc;\\n\\t\\t\\tvar minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\\n\\t\\t\\tchart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);\\n\\t\\t\\tchart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\\n\\t\\t\\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\\n\\n\\t\\t\\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);\\n\\t\\t\\tme.innerRadius = me.outerRadius - chart.radiusLength;\\n\\n\\t\\t\\tmeta.count = me.countVisibleElements();\\n\\n\\t\\t\\thelpers.each(meta.data, function(arc, index) {\\n\\t\\t\\t\\tme.updateElement(arc, index, reset);\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tupdateElement: function(arc, index, reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar opts = chart.options;\\n\\t\\t\\tvar animationOpts = opts.animation;\\n\\t\\t\\tvar scale = chart.scale;\\n\\t\\t\\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\\n\\t\\t\\tvar labels = chart.data.labels;\\n\\n\\t\\t\\tvar circumference = me.calculateCircumference(dataset.data[index]);\\n\\t\\t\\tvar centerX = scale.xCenter;\\n\\t\\t\\tvar centerY = scale.yCenter;\\n\\n\\t\\t\\t// If there is NaN data before us, we need to calculate the starting angle correctly.\\n\\t\\t\\t// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data\\n\\t\\t\\tvar visibleCount = 0;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tfor (var i = 0; i < index; ++i) {\\n\\t\\t\\t\\tif (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {\\n\\t\\t\\t\\t\\t++visibleCount;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// var negHalfPI = -0.5 * Math.PI;\\n\\t\\t\\tvar datasetStartAngle = opts.startAngle;\\n\\t\\t\\tvar distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\\n\\t\\t\\tvar startAngle = datasetStartAngle + (circumference * visibleCount);\\n\\t\\t\\tvar endAngle = startAngle + (arc.hidden ? 0 : circumference);\\n\\n\\t\\t\\tvar resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\\n\\n\\t\\t\\thelpers.extend(arc, {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\t_datasetIndex: me.index,\\n\\t\\t\\t\\t_index: index,\\n\\t\\t\\t\\t_scale: scale,\\n\\n\\t\\t\\t\\t// Desired view properties\\n\\t\\t\\t\\t_model: {\\n\\t\\t\\t\\t\\tx: centerX,\\n\\t\\t\\t\\t\\ty: centerY,\\n\\t\\t\\t\\t\\tinnerRadius: 0,\\n\\t\\t\\t\\t\\touterRadius: reset ? resetRadius : distance,\\n\\t\\t\\t\\t\\tstartAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\\n\\t\\t\\t\\t\\tendAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\\n\\t\\t\\t\\t\\tlabel: getValueAtIndexOrDefault(labels, index, labels[index])\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Apply border and fill style\\n\\t\\t\\tme.removeHoverStyle(arc);\\n\\n\\t\\t\\tarc.pivot();\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(arc) {\\n\\t\\t\\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\\n\\t\\t},\\n\\n\\t\\tcountVisibleElements: function() {\\n\\t\\t\\tvar dataset = this.getDataset();\\n\\t\\t\\tvar meta = this.getMeta();\\n\\t\\t\\tvar count = 0;\\n\\n\\t\\t\\thelpers.each(meta.data, function(element, index) {\\n\\t\\t\\t\\tif (!isNaN(dataset.data[index]) && !element.hidden) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\treturn count;\\n\\t\\t},\\n\\n\\t\\tcalculateCircumference: function(value) {\\n\\t\\t\\tvar count = this.getMeta().count;\\n\\t\\t\\tif (count > 0 && !isNaN(value)) {\\n\\t\\t\\t\\treturn (2 * Math.PI) / count;\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],20:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.radar = {\\n\\t\\taspectRatio: 1,\\n\\t\\tscale: {\\n\\t\\t\\ttype: 'radialLinear'\\n\\t\\t},\\n\\t\\telements: {\\n\\t\\t\\tline: {\\n\\t\\t\\t\\ttension: 0 // no bezier in radar\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tChart.controllers.radar = Chart.DatasetController.extend({\\n\\n\\t\\tdatasetElementType: Chart.elements.Line,\\n\\n\\t\\tdataElementType: Chart.elements.Point,\\n\\n\\t\\tlinkScales: helpers.noop,\\n\\n\\t\\tupdate: function(reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar line = meta.dataset;\\n\\t\\t\\tvar points = meta.data;\\n\\t\\t\\tvar custom = line.custom || {};\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar lineElementOptions = me.chart.options.elements.line;\\n\\t\\t\\tvar scale = me.chart.scale;\\n\\n\\t\\t\\t// Compatibility: If the properties are defined with only the old name, use those values\\n\\t\\t\\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\\n\\t\\t\\t\\tdataset.lineTension = dataset.tension;\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.extend(meta.dataset, {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\t_datasetIndex: me.index,\\n\\t\\t\\t\\t// Data\\n\\t\\t\\t\\t_children: points,\\n\\t\\t\\t\\t_loop: true,\\n\\t\\t\\t\\t// Model\\n\\t\\t\\t\\t_model: {\\n\\t\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\t\\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\\n\\t\\t\\t\\t\\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\\n\\t\\t\\t\\t\\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\\n\\t\\t\\t\\t\\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\\n\\t\\t\\t\\t\\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\\n\\t\\t\\t\\t\\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\\n\\t\\t\\t\\t\\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\\n\\t\\t\\t\\t\\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\\n\\t\\t\\t\\t\\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\\n\\n\\t\\t\\t\\t\\t// Scale\\n\\t\\t\\t\\t\\tscaleTop: scale.top,\\n\\t\\t\\t\\t\\tscaleBottom: scale.bottom,\\n\\t\\t\\t\\t\\tscaleZero: scale.getBasePosition()\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tmeta.dataset.pivot();\\n\\n\\t\\t\\t// Update Points\\n\\t\\t\\thelpers.each(points, function(point, index) {\\n\\t\\t\\t\\tme.updateElement(point, index, reset);\\n\\t\\t\\t}, me);\\n\\n\\t\\t\\t// Update bezier control points\\n\\t\\t\\tme.updateBezierControlPoints();\\n\\t\\t},\\n\\t\\tupdateElement: function(point, index, reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar scale = me.chart.scale;\\n\\t\\t\\tvar pointElementOptions = me.chart.options.elements.point;\\n\\t\\t\\tvar pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\\n\\n\\t\\t\\thelpers.extend(point, {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\t_datasetIndex: me.index,\\n\\t\\t\\t\\t_index: index,\\n\\t\\t\\t\\t_scale: scale,\\n\\n\\t\\t\\t\\t// Desired view properties\\n\\t\\t\\t\\t_model: {\\n\\t\\t\\t\\t\\tx: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales\\n\\t\\t\\t\\t\\ty: reset ? scale.yCenter : pointPosition.y,\\n\\n\\t\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\t\\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),\\n\\t\\t\\t\\t\\tradius: custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),\\n\\t\\t\\t\\t\\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),\\n\\t\\t\\t\\t\\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),\\n\\t\\t\\t\\t\\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),\\n\\t\\t\\t\\t\\tpointStyle: custom.pointStyle ? custom.pointStyle : helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),\\n\\n\\t\\t\\t\\t\\t// Tooltip\\n\\t\\t\\t\\t\\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tpoint._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));\\n\\t\\t},\\n\\t\\tupdateBezierControlPoints: function() {\\n\\t\\t\\tvar chartArea = this.chart.chartArea;\\n\\t\\t\\tvar meta = this.getMeta();\\n\\n\\t\\t\\thelpers.each(meta.data, function(point, index) {\\n\\t\\t\\t\\tvar model = point._model;\\n\\t\\t\\t\\tvar controlPoints = helpers.splineCurve(\\n\\t\\t\\t\\t\\thelpers.previousItem(meta.data, index, true)._model,\\n\\t\\t\\t\\t\\tmodel,\\n\\t\\t\\t\\t\\thelpers.nextItem(meta.data, index, true)._model,\\n\\t\\t\\t\\t\\tmodel.tension\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Prevent the bezier going outside of the bounds of the graph\\n\\t\\t\\t\\tmodel.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);\\n\\t\\t\\t\\tmodel.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);\\n\\n\\t\\t\\t\\tmodel.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);\\n\\t\\t\\t\\tmodel.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);\\n\\n\\t\\t\\t\\t// Now pivot the point for animation\\n\\t\\t\\t\\tpoint.pivot();\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tdraw: function(ease) {\\n\\t\\t\\tvar meta = this.getMeta();\\n\\t\\t\\tvar easingDecimal = ease || 1;\\n\\n\\t\\t\\t// Transition Point Locations\\n\\t\\t\\thelpers.each(meta.data, function(point) {\\n\\t\\t\\t\\tpoint.transition(easingDecimal);\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Transition and Draw the line\\n\\t\\t\\tmeta.dataset.transition(easingDecimal).draw();\\n\\n\\t\\t\\t// Draw the points\\n\\t\\t\\thelpers.each(meta.data, function(point) {\\n\\t\\t\\t\\tpoint.draw();\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tsetHoverStyle: function(point) {\\n\\t\\t\\t// Point\\n\\t\\t\\tvar dataset = this.chart.data.datasets[point._datasetIndex];\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar index = point._index;\\n\\t\\t\\tvar model = point._model;\\n\\n\\t\\t\\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\\n\\t\\t\\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\\n\\t\\t\\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\\n\\t\\t\\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(point) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[point._datasetIndex];\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar index = point._index;\\n\\t\\t\\tvar model = point._model;\\n\\t\\t\\tvar pointElementOptions = this.chart.options.elements.point;\\n\\n\\t\\t\\tmodel.radius = custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.radius, index, pointElementOptions.radius);\\n\\t\\t\\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);\\n\\t\\t\\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);\\n\\t\\t\\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],21:[function(require,module,exports){\\n/* global window: false */\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.global.animation = {\\n\\t\\tduration: 1000,\\n\\t\\teasing: 'easeOutQuart',\\n\\t\\tonProgress: helpers.noop,\\n\\t\\tonComplete: helpers.noop\\n\\t};\\n\\n\\tChart.Animation = Chart.Element.extend({\\n\\t\\tcurrentStep: null, // the current animation step\\n\\t\\tnumSteps: 60, // default number of steps\\n\\t\\teasing: '', // the easing to use for this animation\\n\\t\\trender: null, // render function used by the animation service\\n\\n\\t\\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\\n\\t\\tonAnimationComplete: null // user specified callback to fire when the animation finishes\\n\\t});\\n\\n\\tChart.animationService = {\\n\\t\\tframeDuration: 17,\\n\\t\\tanimations: [],\\n\\t\\tdropFrames: 0,\\n\\t\\trequest: null,\\n\\n\\t\\t/**\\n\\t\\t * @function Chart.animationService.addAnimation\\n\\t\\t * @param chartInstance {ChartController} the chart to animate\\n\\t\\t * @param animationObject {IAnimation} the animation that we will animate\\n\\t\\t * @param duration {Number} length of animation in ms\\n\\t\\t * @param lazy {Boolean} if true, the chart is not marked as animating to enable more responsive interactions\\n\\t\\t */\\n\\t\\taddAnimation: function(chartInstance, animationObject, duration, lazy) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tif (!lazy) {\\n\\t\\t\\t\\tchartInstance.animating = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (var index = 0; index < me.animations.length; ++index) {\\n\\t\\t\\t\\tif (me.animations[index].chartInstance === chartInstance) {\\n\\t\\t\\t\\t\\t// replacing an in progress animation\\n\\t\\t\\t\\t\\tme.animations[index].animationObject = animationObject;\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.animations.push({\\n\\t\\t\\t\\tchartInstance: chartInstance,\\n\\t\\t\\t\\tanimationObject: animationObject\\n\\t\\t\\t});\\n\\n\\t\\t\\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\\n\\t\\t\\tif (me.animations.length === 1) {\\n\\t\\t\\t\\tme.requestAnimationFrame();\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\t// Cancel the animation for a given chart instance\\n\\t\\tcancelAnimation: function(chartInstance) {\\n\\t\\t\\tvar index = helpers.findIndex(this.animations, function(animationWrapper) {\\n\\t\\t\\t\\treturn animationWrapper.chartInstance === chartInstance;\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (index !== -1) {\\n\\t\\t\\t\\tthis.animations.splice(index, 1);\\n\\t\\t\\t\\tchartInstance.animating = false;\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\trequestAnimationFrame: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (me.request === null) {\\n\\t\\t\\t\\t// Skip animation frame requests until the active one is executed.\\n\\t\\t\\t\\t// This can happen when processing mouse events, e.g. 'mousemove'\\n\\t\\t\\t\\t// and 'mouseout' events will trigger multiple renders.\\n\\t\\t\\t\\tme.request = helpers.requestAnimFrame.call(window, function() {\\n\\t\\t\\t\\t\\tme.request = null;\\n\\t\\t\\t\\t\\tme.startDigest();\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tstartDigest: function() {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tvar startTime = Date.now();\\n\\t\\t\\tvar framesToDrop = 0;\\n\\n\\t\\t\\tif (me.dropFrames > 1) {\\n\\t\\t\\t\\tframesToDrop = Math.floor(me.dropFrames);\\n\\t\\t\\t\\tme.dropFrames = me.dropFrames % 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\twhile (i < me.animations.length) {\\n\\t\\t\\t\\tif (me.animations[i].animationObject.currentStep === null) {\\n\\t\\t\\t\\t\\tme.animations[i].animationObject.currentStep = 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tme.animations[i].animationObject.currentStep += 1 + framesToDrop;\\n\\n\\t\\t\\t\\tif (me.animations[i].animationObject.currentStep > me.animations[i].animationObject.numSteps) {\\n\\t\\t\\t\\t\\tme.animations[i].animationObject.currentStep = me.animations[i].animationObject.numSteps;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tme.animations[i].animationObject.render(me.animations[i].chartInstance, me.animations[i].animationObject);\\n\\t\\t\\t\\tif (me.animations[i].animationObject.onAnimationProgress && me.animations[i].animationObject.onAnimationProgress.call) {\\n\\t\\t\\t\\t\\tme.animations[i].animationObject.onAnimationProgress.call(me.animations[i].chartInstance, me.animations[i]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (me.animations[i].animationObject.currentStep === me.animations[i].animationObject.numSteps) {\\n\\t\\t\\t\\t\\tif (me.animations[i].animationObject.onAnimationComplete && me.animations[i].animationObject.onAnimationComplete.call) {\\n\\t\\t\\t\\t\\t\\tme.animations[i].animationObject.onAnimationComplete.call(me.animations[i].chartInstance, me.animations[i]);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// executed the last frame. Remove the animation.\\n\\t\\t\\t\\t\\tme.animations[i].chartInstance.animating = false;\\n\\n\\t\\t\\t\\t\\tme.animations.splice(i, 1);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar endTime = Date.now();\\n\\t\\t\\tvar dropFrames = (endTime - startTime) / me.frameDuration;\\n\\n\\t\\t\\tme.dropFrames += dropFrames;\\n\\n\\t\\t\\t// Do we have more stuff to animate?\\n\\t\\t\\tif (me.animations.length > 0) {\\n\\t\\t\\t\\tme.requestAnimationFrame();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n};\\n\\n},{}],22:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\t// Global Chart canvas helpers object for drawing items to canvas\\n\\tvar helpers = Chart.canvasHelpers = {};\\n\\n\\thelpers.drawPoint = function(ctx, pointStyle, radius, x, y) {\\n\\t\\tvar type, edgeLength, xOffset, yOffset, height, size;\\n\\n\\t\\tif (typeof pointStyle === 'object') {\\n\\t\\t\\ttype = pointStyle.toString();\\n\\t\\t\\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\\n\\t\\t\\t\\tctx.drawImage(pointStyle, x - pointStyle.width / 2, y - pointStyle.height / 2);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (isNaN(radius) || radius <= 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tswitch (pointStyle) {\\n\\t\\t// Default includes circle\\n\\t\\tdefault:\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.arc(x, y, radius, 0, Math.PI * 2);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tctx.fill();\\n\\t\\t\\tbreak;\\n\\t\\tcase 'triangle':\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tedgeLength = 3 * radius / Math.sqrt(3);\\n\\t\\t\\theight = edgeLength * Math.sqrt(3) / 2;\\n\\t\\t\\tctx.moveTo(x - edgeLength / 2, y + height / 3);\\n\\t\\t\\tctx.lineTo(x + edgeLength / 2, y + height / 3);\\n\\t\\t\\tctx.lineTo(x, y - 2 * height / 3);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tctx.fill();\\n\\t\\t\\tbreak;\\n\\t\\tcase 'rect':\\n\\t\\t\\tsize = 1 / Math.SQRT2 * radius;\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.fillRect(x - size, y - size, 2 * size, 2 * size);\\n\\t\\t\\tctx.strokeRect(x - size, y - size, 2 * size, 2 * size);\\n\\t\\t\\tbreak;\\n\\t\\tcase 'rectRounded':\\n\\t\\t\\tvar offset = radius / Math.SQRT2;\\n\\t\\t\\tvar leftX = x - offset;\\n\\t\\t\\tvar topY = y - offset;\\n\\t\\t\\tvar sideSize = Math.SQRT2 * radius;\\n\\t\\t\\tChart.helpers.drawRoundedRectangle(ctx, leftX, topY, sideSize, sideSize, radius / 2);\\n\\t\\t\\tctx.fill();\\n\\t\\t\\tbreak;\\n\\t\\tcase 'rectRot':\\n\\t\\t\\tsize = 1 / Math.SQRT2 * radius;\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.moveTo(x - size, y);\\n\\t\\t\\tctx.lineTo(x, y + size);\\n\\t\\t\\tctx.lineTo(x + size, y);\\n\\t\\t\\tctx.lineTo(x, y - size);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tctx.fill();\\n\\t\\t\\tbreak;\\n\\t\\tcase 'cross':\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.moveTo(x, y + radius);\\n\\t\\t\\tctx.lineTo(x, y - radius);\\n\\t\\t\\tctx.moveTo(x - radius, y);\\n\\t\\t\\tctx.lineTo(x + radius, y);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tbreak;\\n\\t\\tcase 'crossRot':\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\txOffset = Math.cos(Math.PI / 4) * radius;\\n\\t\\t\\tyOffset = Math.sin(Math.PI / 4) * radius;\\n\\t\\t\\tctx.moveTo(x - xOffset, y - yOffset);\\n\\t\\t\\tctx.lineTo(x + xOffset, y + yOffset);\\n\\t\\t\\tctx.moveTo(x - xOffset, y + yOffset);\\n\\t\\t\\tctx.lineTo(x + xOffset, y - yOffset);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tbreak;\\n\\t\\tcase 'star':\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.moveTo(x, y + radius);\\n\\t\\t\\tctx.lineTo(x, y - radius);\\n\\t\\t\\tctx.moveTo(x - radius, y);\\n\\t\\t\\tctx.lineTo(x + radius, y);\\n\\t\\t\\txOffset = Math.cos(Math.PI / 4) * radius;\\n\\t\\t\\tyOffset = Math.sin(Math.PI / 4) * radius;\\n\\t\\t\\tctx.moveTo(x - xOffset, y - yOffset);\\n\\t\\t\\tctx.lineTo(x + xOffset, y + yOffset);\\n\\t\\t\\tctx.moveTo(x - xOffset, y + yOffset);\\n\\t\\t\\tctx.lineTo(x + xOffset, y - yOffset);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tbreak;\\n\\t\\tcase 'line':\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.moveTo(x - radius, y);\\n\\t\\t\\tctx.lineTo(x + radius, y);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tbreak;\\n\\t\\tcase 'dash':\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.moveTo(x, y);\\n\\t\\t\\tctx.lineTo(x + radius, y);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tctx.stroke();\\n\\t};\\n\\n\\thelpers.clipArea = function(ctx, clipArea) {\\n\\t\\tctx.save();\\n\\t\\tctx.beginPath();\\n\\t\\tctx.rect(clipArea.left, clipArea.top, clipArea.right - clipArea.left, clipArea.bottom - clipArea.top);\\n\\t\\tctx.clip();\\n\\t};\\n\\n\\thelpers.unclipArea = function(ctx) {\\n\\t\\tctx.restore();\\n\\t};\\n\\n};\\n\\n},{}],23:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\tvar plugins = Chart.plugins;\\n\\tvar platform = Chart.platform;\\n\\n\\t// Create a dictionary of chart types, to allow for extension of existing types\\n\\tChart.types = {};\\n\\n\\t// Store a reference to each instance - allowing us to globally resize chart instances on window resize.\\n\\t// Destroy method on the chart will remove the instance of the chart from this reference.\\n\\tChart.instances = {};\\n\\n\\t// Controllers available for dataset visualization eg. bar, line, slice, etc.\\n\\tChart.controllers = {};\\n\\n\\t/**\\n\\t * Initializes the given config with global and chart default values.\\n\\t */\\n\\tfunction initConfig(config) {\\n\\t\\tconfig = config || {};\\n\\n\\t\\t// Do NOT use configMerge() for the data object because this method merges arrays\\n\\t\\t// and so would change references to labels and datasets, preventing data updates.\\n\\t\\tvar data = config.data = config.data || {};\\n\\t\\tdata.datasets = data.datasets || [];\\n\\t\\tdata.labels = data.labels || [];\\n\\n\\t\\tconfig.options = helpers.configMerge(\\n\\t\\t\\tChart.defaults.global,\\n\\t\\t\\tChart.defaults[config.type],\\n\\t\\t\\tconfig.options || {});\\n\\n\\t\\treturn config;\\n\\t}\\n\\n\\t/**\\n\\t * Updates the config of the chart\\n\\t * @param chart {Chart.Controller} chart to update the options for\\n\\t */\\n\\tfunction updateConfig(chart) {\\n\\t\\tvar newOptions = chart.options;\\n\\n\\t\\t// Update Scale(s) with options\\n\\t\\tif (newOptions.scale) {\\n\\t\\t\\tchart.scale.options = newOptions.scale;\\n\\t\\t} else if (newOptions.scales) {\\n\\t\\t\\tnewOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function(scaleOptions) {\\n\\t\\t\\t\\tchart.scales[scaleOptions.id].options = scaleOptions;\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\t// Tooltip\\n\\t\\tchart.tooltip._options = newOptions.tooltips;\\n\\t}\\n\\n\\t/**\\n\\t * @class Chart.Controller\\n\\t * The main controller of a chart.\\n\\t */\\n\\tChart.Controller = function(item, config, instance) {\\n\\t\\tvar me = this;\\n\\n\\t\\tconfig = initConfig(config);\\n\\n\\t\\tvar context = platform.acquireContext(item, config);\\n\\t\\tvar canvas = context && context.canvas;\\n\\t\\tvar height = canvas && canvas.height;\\n\\t\\tvar width = canvas && canvas.width;\\n\\n\\t\\tinstance.ctx = context;\\n\\t\\tinstance.canvas = canvas;\\n\\t\\tinstance.config = config;\\n\\t\\tinstance.width = width;\\n\\t\\tinstance.height = height;\\n\\t\\tinstance.aspectRatio = height? width / height : null;\\n\\n\\t\\tme.id = helpers.uid();\\n\\t\\tme.chart = instance;\\n\\t\\tme.config = config;\\n\\t\\tme.options = config.options;\\n\\t\\tme._bufferedRender = false;\\n\\n\\t\\t// Add the chart instance to the global namespace\\n\\t\\tChart.instances[me.id] = me;\\n\\n\\t\\tObject.defineProperty(me, 'data', {\\n\\t\\t\\tget: function() {\\n\\t\\t\\t\\treturn me.config.data;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tif (!context || !canvas) {\\n\\t\\t\\t// The given item is not a compatible context2d element, let's return before finalizing\\n\\t\\t\\t// the chart initialization but after setting basic chart / controller properties that\\n\\t\\t\\t// can help to figure out that the chart is not valid (e.g chart.canvas !== null);\\n\\t\\t\\t// https://github.com/chartjs/Chart.js/issues/2807\\n\\t\\t\\tconsole.error(\\\"Failed to create chart: can't acquire context from the given item\\\");\\n\\t\\t\\treturn me;\\n\\t\\t}\\n\\n\\t\\tme.initialize();\\n\\t\\tme.update();\\n\\n\\t\\treturn me;\\n\\t};\\n\\n\\thelpers.extend(Chart.Controller.prototype, /** @lends Chart.Controller.prototype */ {\\n\\t\\tinitialize: function() {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\t// Before init plugin notification\\n\\t\\t\\tplugins.notify(me, 'beforeInit');\\n\\n\\t\\t\\thelpers.retinaScale(me.chart);\\n\\n\\t\\t\\tme.bindEvents();\\n\\n\\t\\t\\tif (me.options.responsive) {\\n\\t\\t\\t\\t// Initial resize before chart draws (must be silent to preserve initial animations).\\n\\t\\t\\t\\tme.resize(true);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Make sure scales have IDs and are built before we build any controllers.\\n\\t\\t\\tme.ensureScalesHaveIDs();\\n\\t\\t\\tme.buildScales();\\n\\t\\t\\tme.initToolTip();\\n\\n\\t\\t\\t// After init plugin notification\\n\\t\\t\\tplugins.notify(me, 'afterInit');\\n\\n\\t\\t\\treturn me;\\n\\t\\t},\\n\\n\\t\\tclear: function() {\\n\\t\\t\\thelpers.clear(this.chart);\\n\\t\\t\\treturn this;\\n\\t\\t},\\n\\n\\t\\tstop: function() {\\n\\t\\t\\t// Stops any current animation loop occurring\\n\\t\\t\\tChart.animationService.cancelAnimation(this);\\n\\t\\t\\treturn this;\\n\\t\\t},\\n\\n\\t\\tresize: function(silent) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\tvar options = me.options;\\n\\t\\t\\tvar canvas = chart.canvas;\\n\\t\\t\\tvar aspectRatio = (options.maintainAspectRatio && chart.aspectRatio) || null;\\n\\n\\t\\t\\t// the canvas render width and height will be casted to integers so make sure that\\n\\t\\t\\t// the canvas display style uses the same integer values to avoid blurring effect.\\n\\t\\t\\tvar newWidth = Math.floor(helpers.getMaximumWidth(canvas));\\n\\t\\t\\tvar newHeight = Math.floor(aspectRatio? newWidth / aspectRatio : helpers.getMaximumHeight(canvas));\\n\\n\\t\\t\\tif (chart.width === newWidth && chart.height === newHeight) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcanvas.width = chart.width = newWidth;\\n\\t\\t\\tcanvas.height = chart.height = newHeight;\\n\\t\\t\\tcanvas.style.width = newWidth + 'px';\\n\\t\\t\\tcanvas.style.height = newHeight + 'px';\\n\\n\\t\\t\\thelpers.retinaScale(chart);\\n\\n\\t\\t\\tif (!silent) {\\n\\t\\t\\t\\t// Notify any plugins about the resize\\n\\t\\t\\t\\tvar newSize = {width: newWidth, height: newHeight};\\n\\t\\t\\t\\tplugins.notify(me, 'resize', [newSize]);\\n\\n\\t\\t\\t\\t// Notify of resize\\n\\t\\t\\t\\tif (me.options.onResize) {\\n\\t\\t\\t\\t\\tme.options.onResize(me, newSize);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tme.stop();\\n\\t\\t\\t\\tme.update(me.options.responsiveAnimationDuration);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tensureScalesHaveIDs: function() {\\n\\t\\t\\tvar options = this.options;\\n\\t\\t\\tvar scalesOptions = options.scales || {};\\n\\t\\t\\tvar scaleOptions = options.scale;\\n\\n\\t\\t\\thelpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {\\n\\t\\t\\t\\txAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);\\n\\t\\t\\t});\\n\\n\\t\\t\\thelpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {\\n\\t\\t\\t\\tyAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (scaleOptions) {\\n\\t\\t\\t\\tscaleOptions.id = scaleOptions.id || 'scale';\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Builds a map of scale ID to scale object for future lookup.\\n\\t\\t */\\n\\t\\tbuildScales: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar options = me.options;\\n\\t\\t\\tvar scales = me.scales = {};\\n\\t\\t\\tvar items = [];\\n\\n\\t\\t\\tif (options.scales) {\\n\\t\\t\\t\\titems = items.concat(\\n\\t\\t\\t\\t\\t(options.scales.xAxes || []).map(function(xAxisOptions) {\\n\\t\\t\\t\\t\\t\\treturn {options: xAxisOptions, dtype: 'category'};\\n\\t\\t\\t\\t\\t}),\\n\\t\\t\\t\\t\\t(options.scales.yAxes || []).map(function(yAxisOptions) {\\n\\t\\t\\t\\t\\t\\treturn {options: yAxisOptions, dtype: 'linear'};\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (options.scale) {\\n\\t\\t\\t\\titems.push({options: options.scale, dtype: 'radialLinear', isDefault: true});\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.each(items, function(item) {\\n\\t\\t\\t\\tvar scaleOptions = item.options;\\n\\t\\t\\t\\tvar scaleType = helpers.getValueOrDefault(scaleOptions.type, item.dtype);\\n\\t\\t\\t\\tvar scaleClass = Chart.scaleService.getScaleConstructor(scaleType);\\n\\t\\t\\t\\tif (!scaleClass) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar scale = new scaleClass({\\n\\t\\t\\t\\t\\tid: scaleOptions.id,\\n\\t\\t\\t\\t\\toptions: scaleOptions,\\n\\t\\t\\t\\t\\tctx: me.chart.ctx,\\n\\t\\t\\t\\t\\tchart: me\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tscales[scale.id] = scale;\\n\\n\\t\\t\\t\\t// TODO(SB): I think we should be able to remove this custom case (options.scale)\\n\\t\\t\\t\\t// and consider it as a regular scale part of the \\\"scales\\\"\\\" map only! This would\\n\\t\\t\\t\\t// make the logic easier and remove some useless? custom code.\\n\\t\\t\\t\\tif (item.isDefault) {\\n\\t\\t\\t\\t\\tme.scale = scale;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tChart.scaleService.addScalesToLayout(this);\\n\\t\\t},\\n\\n\\t\\tbuildOrUpdateControllers: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar types = [];\\n\\t\\t\\tvar newControllers = [];\\n\\n\\t\\t\\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tvar meta = me.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\tif (!meta.type) {\\n\\t\\t\\t\\t\\tmeta.type = dataset.type || me.config.type;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttypes.push(meta.type);\\n\\n\\t\\t\\t\\tif (meta.controller) {\\n\\t\\t\\t\\t\\tmeta.controller.updateIndex(datasetIndex);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmeta.controller = new Chart.controllers[meta.type](me, datasetIndex);\\n\\t\\t\\t\\t\\tnewControllers.push(meta.controller);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, me);\\n\\n\\t\\t\\tif (types.length > 1) {\\n\\t\\t\\t\\tfor (var i = 1; i < types.length; i++) {\\n\\t\\t\\t\\t\\tif (types[i] !== types[i - 1]) {\\n\\t\\t\\t\\t\\t\\tme.isCombo = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn newControllers;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Reset the elements of all datasets\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tresetElements: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tme.getDatasetMeta(datasetIndex).controller.reset();\\n\\t\\t\\t}, me);\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t* Resets the chart back to it's state before the initial animation\\n\\t\\t*/\\n\\t\\treset: function() {\\n\\t\\t\\tthis.resetElements();\\n\\t\\t\\tthis.tooltip.initialize();\\n\\t\\t},\\n\\n\\t\\tupdate: function(animationDuration, lazy) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tupdateConfig(me);\\n\\n\\t\\t\\tif (plugins.notify(me, 'beforeUpdate') === false) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// In case the entire data object changed\\n\\t\\t\\tme.tooltip._data = me.data;\\n\\n\\t\\t\\t// Make sure dataset controllers are updated and new controllers are reset\\n\\t\\t\\tvar newControllers = me.buildOrUpdateControllers();\\n\\n\\t\\t\\t// Make sure all dataset controllers have correct meta data counts\\n\\t\\t\\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tme.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\\n\\t\\t\\t}, me);\\n\\n\\t\\t\\tme.updateLayout();\\n\\n\\t\\t\\t// Can only reset the new controllers after the scales have been updated\\n\\t\\t\\thelpers.each(newControllers, function(controller) {\\n\\t\\t\\t\\tcontroller.reset();\\n\\t\\t\\t});\\n\\n\\t\\t\\tme.updateDatasets();\\n\\n\\t\\t\\t// Do this before render so that any plugins that need final scale updates can use it\\n\\t\\t\\tplugins.notify(me, 'afterUpdate');\\n\\n\\t\\t\\tif (me._bufferedRender) {\\n\\t\\t\\t\\tme._bufferedRequest = {\\n\\t\\t\\t\\t\\tlazy: lazy,\\n\\t\\t\\t\\t\\tduration: animationDuration\\n\\t\\t\\t\\t};\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.render(animationDuration, lazy);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\\n\\t\\t * hook, in which case, plugins will not be called on `afterLayout`.\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tupdateLayout: function() {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tif (plugins.notify(me, 'beforeLayout') === false) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tChart.layoutService.update(this, this.chart.width, this.chart.height);\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * Provided for backward compatibility, use `afterLayout` instead.\\n\\t\\t\\t * @method IPlugin#afterScaleUpdate\\n\\t\\t\\t * @deprecated since version 2.5.0\\n\\t\\t\\t * @todo remove at version 3\\n\\t\\t\\t */\\n\\t\\t\\tplugins.notify(me, 'afterScaleUpdate');\\n\\t\\t\\tplugins.notify(me, 'afterLayout');\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\\n\\t\\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tupdateDatasets: function() {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tif (plugins.notify(me, 'beforeDatasetsUpdate') === false) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\\n\\t\\t\\t\\tme.getDatasetMeta(i).controller.update();\\n\\t\\t\\t}\\n\\n\\t\\t\\tplugins.notify(me, 'afterDatasetsUpdate');\\n\\t\\t},\\n\\n\\t\\trender: function(duration, lazy) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tif (plugins.notify(me, 'beforeRender') === false) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar animationOptions = me.options.animation;\\n\\t\\t\\tvar onComplete = function() {\\n\\t\\t\\t\\tplugins.notify(me, 'afterRender');\\n\\t\\t\\t\\tvar callback = animationOptions && animationOptions.onComplete;\\n\\t\\t\\t\\tif (callback && callback.call) {\\n\\t\\t\\t\\t\\tcallback.call(me);\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t\\tif (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {\\n\\t\\t\\t\\tvar animation = new Chart.Animation();\\n\\t\\t\\t\\tanimation.numSteps = (duration || animationOptions.duration) / 16.66; // 60 fps\\n\\t\\t\\t\\tanimation.easing = animationOptions.easing;\\n\\n\\t\\t\\t\\t// render function\\n\\t\\t\\t\\tanimation.render = function(chartInstance, animationObject) {\\n\\t\\t\\t\\t\\tvar easingFunction = helpers.easingEffects[animationObject.easing];\\n\\t\\t\\t\\t\\tvar stepDecimal = animationObject.currentStep / animationObject.numSteps;\\n\\t\\t\\t\\t\\tvar easeDecimal = easingFunction(stepDecimal);\\n\\n\\t\\t\\t\\t\\tchartInstance.draw(easeDecimal, stepDecimal, animationObject.currentStep);\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t// user events\\n\\t\\t\\t\\tanimation.onAnimationProgress = animationOptions.onProgress;\\n\\t\\t\\t\\tanimation.onAnimationComplete = onComplete;\\n\\n\\t\\t\\t\\tChart.animationService.addAnimation(me, animation, duration, lazy);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.draw();\\n\\t\\t\\t\\tonComplete();\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn me;\\n\\t\\t},\\n\\n\\t\\tdraw: function(easingValue) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tme.clear();\\n\\n\\t\\t\\tif (easingValue === undefined || easingValue === null) {\\n\\t\\t\\t\\teasingValue = 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Draw all the scales\\n\\t\\t\\thelpers.each(me.boxes, function(box) {\\n\\t\\t\\t\\tbox.draw(me.chartArea);\\n\\t\\t\\t}, me);\\n\\n\\t\\t\\tif (me.scale) {\\n\\t\\t\\t\\tme.scale.draw();\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.drawDatasets(easingValue);\\n\\n\\t\\t\\t// Finally draw the tooltip\\n\\t\\t\\tme.tooltip.transition(easingValue).draw();\\n\\n\\t\\t\\tplugins.notify(me, 'afterDraw', [easingValue]);\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\\n\\t\\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tdrawDatasets: function(easingValue) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tif (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Draw each dataset via its respective controller (reversed to support proper line stacking)\\n\\t\\t\\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tif (me.isDatasetVisible(datasetIndex)) {\\n\\t\\t\\t\\t\\tme.getDatasetMeta(datasetIndex).controller.draw(easingValue);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, me, true);\\n\\n\\t\\t\\tplugins.notify(me, 'afterDatasetsDraw', [easingValue]);\\n\\t\\t},\\n\\n\\t\\t// Get the single element that was clicked on\\n\\t\\t// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\\n\\t\\tgetElementAtEvent: function(e) {\\n\\t\\t\\treturn Chart.Interaction.modes.single(this, e);\\n\\t\\t},\\n\\n\\t\\tgetElementsAtEvent: function(e) {\\n\\t\\t\\treturn Chart.Interaction.modes.label(this, e, {intersect: true});\\n\\t\\t},\\n\\n\\t\\tgetElementsAtXAxis: function(e) {\\n\\t\\t\\treturn Chart.Interaction.modes['x-axis'](this, e, {intersect: true});\\n\\t\\t},\\n\\n\\t\\tgetElementsAtEventForMode: function(e, mode, options) {\\n\\t\\t\\tvar method = Chart.Interaction.modes[mode];\\n\\t\\t\\tif (typeof method === 'function') {\\n\\t\\t\\t\\treturn method(this, e, options);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn [];\\n\\t\\t},\\n\\n\\t\\tgetDatasetAtEvent: function(e) {\\n\\t\\t\\treturn Chart.Interaction.modes.dataset(this, e, {intersect: true});\\n\\t\\t},\\n\\n\\t\\tgetDatasetMeta: function(datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar dataset = me.data.datasets[datasetIndex];\\n\\t\\t\\tif (!dataset._meta) {\\n\\t\\t\\t\\tdataset._meta = {};\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar meta = dataset._meta[me.id];\\n\\t\\t\\tif (!meta) {\\n\\t\\t\\t\\tmeta = dataset._meta[me.id] = {\\n\\t\\t\\t\\t\\ttype: null,\\n\\t\\t\\t\\t\\tdata: [],\\n\\t\\t\\t\\t\\tdataset: null,\\n\\t\\t\\t\\t\\tcontroller: null,\\n\\t\\t\\t\\t\\thidden: null,\\t\\t\\t// See isDatasetVisible() comment\\n\\t\\t\\t\\t\\txAxisID: null,\\n\\t\\t\\t\\t\\tyAxisID: null\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn meta;\\n\\t\\t},\\n\\n\\t\\tgetVisibleDatasetCount: function() {\\n\\t\\t\\tvar count = 0;\\n\\t\\t\\tfor (var i = 0, ilen = this.data.datasets.length; i<ilen; ++i) {\\n\\t\\t\\t\\tif (this.isDatasetVisible(i)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t},\\n\\n\\t\\tisDatasetVisible: function(datasetIndex) {\\n\\t\\t\\tvar meta = this.getDatasetMeta(datasetIndex);\\n\\n\\t\\t\\t// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\\n\\t\\t\\t// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\\n\\t\\t\\treturn typeof meta.hidden === 'boolean'? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\\n\\t\\t},\\n\\n\\t\\tgenerateLegend: function() {\\n\\t\\t\\treturn this.options.legendCallback(this);\\n\\t\\t},\\n\\n\\t\\tdestroy: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar canvas = me.chart.canvas;\\n\\t\\t\\tvar meta, i, ilen;\\n\\n\\t\\t\\tme.stop();\\n\\n\\t\\t\\t// dataset controllers need to cleanup associated data\\n\\t\\t\\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\\n\\t\\t\\t\\tmeta = me.getDatasetMeta(i);\\n\\t\\t\\t\\tif (meta.controller) {\\n\\t\\t\\t\\t\\tmeta.controller.destroy();\\n\\t\\t\\t\\t\\tmeta.controller = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (canvas) {\\n\\t\\t\\t\\tme.unbindEvents();\\n\\t\\t\\t\\thelpers.clear(me.chart);\\n\\t\\t\\t\\tplatform.releaseContext(me.chart.ctx);\\n\\t\\t\\t\\tme.chart.canvas = null;\\n\\t\\t\\t\\tme.chart.ctx = null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tplugins.notify(me, 'destroy');\\n\\n\\t\\t\\tdelete Chart.instances[me.id];\\n\\t\\t},\\n\\n\\t\\ttoBase64Image: function() {\\n\\t\\t\\treturn this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);\\n\\t\\t},\\n\\n\\t\\tinitToolTip: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tme.tooltip = new Chart.Tooltip({\\n\\t\\t\\t\\t_chart: me.chart,\\n\\t\\t\\t\\t_chartInstance: me,\\n\\t\\t\\t\\t_data: me.data,\\n\\t\\t\\t\\t_options: me.options.tooltips\\n\\t\\t\\t}, me);\\n\\t\\t\\tme.tooltip.initialize();\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tbindEvents: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar listeners = me._listeners = {};\\n\\t\\t\\tvar listener = function() {\\n\\t\\t\\t\\tme.eventHandler.apply(me, arguments);\\n\\t\\t\\t};\\n\\n\\t\\t\\thelpers.each(me.options.events, function(type) {\\n\\t\\t\\t\\tplatform.addEventListener(me, type, listener);\\n\\t\\t\\t\\tlisteners[type] = listener;\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Responsiveness is currently based on the use of an iframe, however this method causes\\n\\t\\t\\t// performance issues and could be troublesome when used with ad blockers. So make sure\\n\\t\\t\\t// that the user is still able to create a chart without iframe when responsive is false.\\n\\t\\t\\t// See https://github.com/chartjs/Chart.js/issues/2210\\n\\t\\t\\tif (me.options.responsive) {\\n\\t\\t\\t\\tlistener = function() {\\n\\t\\t\\t\\t\\tme.resize();\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tplatform.addEventListener(me, 'resize', listener);\\n\\t\\t\\t\\tlisteners.resize = listener;\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tunbindEvents: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar listeners = me._listeners;\\n\\t\\t\\tif (!listeners) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tdelete me._listeners;\\n\\t\\t\\thelpers.each(listeners, function(listener, type) {\\n\\t\\t\\t\\tplatform.removeEventListener(me, type, listener);\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tupdateHoverStyle: function(elements, mode, enabled) {\\n\\t\\t\\tvar method = enabled? 'setHoverStyle' : 'removeHoverStyle';\\n\\t\\t\\tvar element, i, ilen;\\n\\n\\t\\t\\tfor (i=0, ilen=elements.length; i<ilen; ++i) {\\n\\t\\t\\t\\telement = elements[i];\\n\\t\\t\\t\\tif (element) {\\n\\t\\t\\t\\t\\tthis.getDatasetMeta(element._datasetIndex).controller[method](element);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\teventHandler: function(e) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar tooltip = me.tooltip;\\n\\n\\t\\t\\tif (plugins.notify(me, 'beforeEvent', [e]) === false) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Buffer any update calls so that renders do not occur\\n\\t\\t\\tme._bufferedRender = true;\\n\\t\\t\\tme._bufferedRequest = null;\\n\\n\\t\\t\\tvar changed = me.handleEvent(e);\\n\\t\\t\\tchanged |= tooltip && tooltip.handleEvent(e);\\n\\n\\t\\t\\tplugins.notify(me, 'afterEvent', [e]);\\n\\n\\t\\t\\tvar bufferedRequest = me._bufferedRequest;\\n\\t\\t\\tif (bufferedRequest) {\\n\\t\\t\\t\\t// If we have an update that was triggered, we need to do a normal render\\n\\t\\t\\t\\tme.render(bufferedRequest.duration, bufferedRequest.lazy);\\n\\t\\t\\t} else if (changed && !me.animating) {\\n\\t\\t\\t\\t// If entering, leaving, or changing elements, animate the change via pivot\\n\\t\\t\\t\\tme.stop();\\n\\n\\t\\t\\t\\t// We only need to render at this point. Updating will cause scales to be\\n\\t\\t\\t\\t// recomputed generating flicker & using more memory than necessary.\\n\\t\\t\\t\\tme.render(me.options.hover.animationDuration, true);\\n\\t\\t\\t}\\n\\n\\t\\t\\tme._bufferedRender = false;\\n\\t\\t\\tme._bufferedRequest = null;\\n\\n\\t\\t\\treturn me;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Handle an event\\n\\t\\t * @private\\n\\t\\t * @param {IEvent} event the event to handle\\n\\t\\t * @return {Boolean} true if the chart needs to re-render\\n\\t\\t */\\n\\t\\thandleEvent: function(e) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar options = me.options || {};\\n\\t\\t\\tvar hoverOptions = options.hover;\\n\\t\\t\\tvar changed = false;\\n\\n\\t\\t\\tme.lastActive = me.lastActive || [];\\n\\n\\t\\t\\t// Find Active Elements for hover and tooltips\\n\\t\\t\\tif (e.type === 'mouseout') {\\n\\t\\t\\t\\tme.active = [];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// On Hover hook\\n\\t\\t\\tif (hoverOptions.onHover) {\\n\\t\\t\\t\\t// Need to call with native event here to not break backwards compatibility\\n\\t\\t\\t\\thoverOptions.onHover.call(me, e.native, me.active);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (e.type === 'mouseup' || e.type === 'click') {\\n\\t\\t\\t\\tif (options.onClick) {\\n\\t\\t\\t\\t\\t// Use e.native here for backwards compatibility\\n\\t\\t\\t\\t\\toptions.onClick.call(me, e.native, me.active);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Remove styling for last active (even if it may still be active)\\n\\t\\t\\tif (me.lastActive.length) {\\n\\t\\t\\t\\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Built in hover styling\\n\\t\\t\\tif (me.active.length && hoverOptions.mode) {\\n\\t\\t\\t\\tme.updateHoverStyle(me.active, hoverOptions.mode, true);\\n\\t\\t\\t}\\n\\n\\t\\t\\tchanged = !helpers.arrayEquals(me.active, me.lastActive);\\n\\n\\t\\t\\t// Remember Last Actives\\n\\t\\t\\tme.lastActive = me.active;\\n\\n\\t\\t\\treturn changed;\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],24:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tvar arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\\n\\n\\t/**\\n\\t * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\\n\\t * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\\n\\t * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\\n\\t */\\n\\tfunction listenArrayEvents(array, listener) {\\n\\t\\tif (array._chartjs) {\\n\\t\\t\\tarray._chartjs.listeners.push(listener);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tObject.defineProperty(array, '_chartjs', {\\n\\t\\t\\tconfigurable: true,\\n\\t\\t\\tenumerable: false,\\n\\t\\t\\tvalue: {\\n\\t\\t\\t\\tlisteners: [listener]\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tarrayEvents.forEach(function(key) {\\n\\t\\t\\tvar method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\\n\\t\\t\\tvar base = array[key];\\n\\n\\t\\t\\tObject.defineProperty(array, key, {\\n\\t\\t\\t\\tconfigurable: true,\\n\\t\\t\\t\\tenumerable: false,\\n\\t\\t\\t\\tvalue: function() {\\n\\t\\t\\t\\t\\tvar args = Array.prototype.slice.call(arguments);\\n\\t\\t\\t\\t\\tvar res = base.apply(this, args);\\n\\n\\t\\t\\t\\t\\thelpers.each(array._chartjs.listeners, function(object) {\\n\\t\\t\\t\\t\\t\\tif (typeof object[method] === 'function') {\\n\\t\\t\\t\\t\\t\\t\\tobject[method].apply(object, args);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t});\\n\\t}\\n\\n\\t/**\\n\\t * Removes the given array event listener and cleanup extra attached properties (such as\\n\\t * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\\n\\t */\\n\\tfunction unlistenArrayEvents(array, listener) {\\n\\t\\tvar stub = array._chartjs;\\n\\t\\tif (!stub) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar listeners = stub.listeners;\\n\\t\\tvar index = listeners.indexOf(listener);\\n\\t\\tif (index !== -1) {\\n\\t\\t\\tlisteners.splice(index, 1);\\n\\t\\t}\\n\\n\\t\\tif (listeners.length > 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tarrayEvents.forEach(function(key) {\\n\\t\\t\\tdelete array[key];\\n\\t\\t});\\n\\n\\t\\tdelete array._chartjs;\\n\\t}\\n\\n\\t// Base class for all dataset controllers (line, bar, etc)\\n\\tChart.DatasetController = function(chart, datasetIndex) {\\n\\t\\tthis.initialize(chart, datasetIndex);\\n\\t};\\n\\n\\thelpers.extend(Chart.DatasetController.prototype, {\\n\\n\\t\\t/**\\n\\t\\t * Element type used to generate a meta dataset (e.g. Chart.element.Line).\\n\\t\\t * @type {Chart.core.element}\\n\\t\\t */\\n\\t\\tdatasetElementType: null,\\n\\n\\t\\t/**\\n\\t\\t * Element type used to generate a meta data (e.g. Chart.element.Point).\\n\\t\\t * @type {Chart.core.element}\\n\\t\\t */\\n\\t\\tdataElementType: null,\\n\\n\\t\\tinitialize: function(chart, datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tme.chart = chart;\\n\\t\\t\\tme.index = datasetIndex;\\n\\t\\t\\tme.linkScales();\\n\\t\\t\\tme.addElements();\\n\\t\\t},\\n\\n\\t\\tupdateIndex: function(datasetIndex) {\\n\\t\\t\\tthis.index = datasetIndex;\\n\\t\\t},\\n\\n\\t\\tlinkScales: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\n\\t\\t\\tif (meta.xAxisID === null) {\\n\\t\\t\\t\\tmeta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;\\n\\t\\t\\t}\\n\\t\\t\\tif (meta.yAxisID === null) {\\n\\t\\t\\t\\tmeta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tgetDataset: function() {\\n\\t\\t\\treturn this.chart.data.datasets[this.index];\\n\\t\\t},\\n\\n\\t\\tgetMeta: function() {\\n\\t\\t\\treturn this.chart.getDatasetMeta(this.index);\\n\\t\\t},\\n\\n\\t\\tgetScaleForId: function(scaleID) {\\n\\t\\t\\treturn this.chart.scales[scaleID];\\n\\t\\t},\\n\\n\\t\\treset: function() {\\n\\t\\t\\tthis.update(true);\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tdestroy: function() {\\n\\t\\t\\tif (this._data) {\\n\\t\\t\\t\\tunlistenArrayEvents(this._data, this);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tcreateMetaDataset: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar type = me.datasetElementType;\\n\\t\\t\\treturn type && new type({\\n\\t\\t\\t\\t_chart: me.chart.chart,\\n\\t\\t\\t\\t_datasetIndex: me.index\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tcreateMetaData: function(index) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar type = me.dataElementType;\\n\\t\\t\\treturn type && new type({\\n\\t\\t\\t\\t_chart: me.chart.chart,\\n\\t\\t\\t\\t_datasetIndex: me.index,\\n\\t\\t\\t\\t_index: index\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\taddElements: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar data = me.getDataset().data || [];\\n\\t\\t\\tvar metaData = meta.data;\\n\\t\\t\\tvar i, ilen;\\n\\n\\t\\t\\tfor (i=0, ilen=data.length; i<ilen; ++i) {\\n\\t\\t\\t\\tmetaData[i] = metaData[i] || me.createMetaData(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\tmeta.dataset = meta.dataset || me.createMetaDataset();\\n\\t\\t},\\n\\n\\t\\taddElementAndReset: function(index) {\\n\\t\\t\\tvar element = this.createMetaData(index);\\n\\t\\t\\tthis.getMeta().data.splice(index, 0, element);\\n\\t\\t\\tthis.updateElement(element, index, true);\\n\\t\\t},\\n\\n\\t\\tbuildOrUpdateElements: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar data = dataset.data || (dataset.data = []);\\n\\n\\t\\t\\t// In order to correctly handle data addition/deletion animation (an thus simulate\\n\\t\\t\\t// real-time charts), we need to monitor these data modifications and synchronize\\n\\t\\t\\t// the internal meta data accordingly.\\n\\t\\t\\tif (me._data !== data) {\\n\\t\\t\\t\\tif (me._data) {\\n\\t\\t\\t\\t\\t// This case happens when the user replaced the data array instance.\\n\\t\\t\\t\\t\\tunlistenArrayEvents(me._data, me);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlistenArrayEvents(data, me);\\n\\t\\t\\t\\tme._data = data;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Re-sync meta data in case the user replaced the data array or if we missed\\n\\t\\t\\t// any updates and so make sure that we handle number of datapoints changing.\\n\\t\\t\\tme.resyncElements();\\n\\t\\t},\\n\\n\\t\\tupdate: helpers.noop,\\n\\n\\t\\tdraw: function(ease) {\\n\\t\\t\\tvar easingDecimal = ease || 1;\\n\\t\\t\\tvar i, len;\\n\\t\\t\\tvar metaData = this.getMeta().data;\\n\\t\\t\\tfor (i = 0, len = metaData.length; i < len; ++i) {\\n\\t\\t\\t\\tmetaData[i].transition(easingDecimal).draw();\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(element, elementOpts) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[element._datasetIndex],\\n\\t\\t\\t\\tindex = element._index,\\n\\t\\t\\t\\tcustom = element.custom || {},\\n\\t\\t\\t\\tvalueOrDefault = helpers.getValueAtIndexOrDefault,\\n\\t\\t\\t\\tmodel = element._model;\\n\\n\\t\\t\\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);\\n\\t\\t\\tmodel.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);\\n\\t\\t\\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);\\n\\t\\t},\\n\\n\\t\\tsetHoverStyle: function(element) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[element._datasetIndex],\\n\\t\\t\\t\\tindex = element._index,\\n\\t\\t\\t\\tcustom = element.custom || {},\\n\\t\\t\\t\\tvalueOrDefault = helpers.getValueAtIndexOrDefault,\\n\\t\\t\\t\\tgetHoverColor = helpers.getHoverColor,\\n\\t\\t\\t\\tmodel = element._model;\\n\\n\\t\\t\\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));\\n\\t\\t\\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));\\n\\t\\t\\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tresyncElements: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar data = me.getDataset().data;\\n\\t\\t\\tvar numMeta = meta.data.length;\\n\\t\\t\\tvar numData = data.length;\\n\\n\\t\\t\\tif (numData < numMeta) {\\n\\t\\t\\t\\tmeta.data.splice(numData, numMeta - numData);\\n\\t\\t\\t} else if (numData > numMeta) {\\n\\t\\t\\t\\tme.insertElements(numMeta, numData - numMeta);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tinsertElements: function(start, count) {\\n\\t\\t\\tfor (var i=0; i<count; ++i) {\\n\\t\\t\\t\\tthis.addElementAndReset(start + i);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tonDataPush: function() {\\n\\t\\t\\tthis.insertElements(this.getDataset().data.length-1, arguments.length);\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tonDataPop: function() {\\n\\t\\t\\tthis.getMeta().data.pop();\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tonDataShift: function() {\\n\\t\\t\\tthis.getMeta().data.shift();\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tonDataSplice: function(start, count) {\\n\\t\\t\\tthis.getMeta().data.splice(start, count);\\n\\t\\t\\tthis.insertElements(start, arguments.length - 2);\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tonDataUnshift: function() {\\n\\t\\t\\tthis.insertElements(0, arguments.length);\\n\\t\\t}\\n\\t});\\n\\n\\tChart.DatasetController.extend = helpers.inherits;\\n};\\n\\n},{}],25:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.elements = {};\\n\\n\\tChart.Element = function(configuration) {\\n\\t\\thelpers.extend(this, configuration);\\n\\t\\tthis.initialize.apply(this, arguments);\\n\\t};\\n\\n\\thelpers.extend(Chart.Element.prototype, {\\n\\n\\t\\tinitialize: function() {\\n\\t\\t\\tthis.hidden = false;\\n\\t\\t},\\n\\n\\t\\tpivot: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (!me._view) {\\n\\t\\t\\t\\tme._view = helpers.clone(me._model);\\n\\t\\t\\t}\\n\\t\\t\\tme._start = helpers.clone(me._view);\\n\\t\\t\\treturn me;\\n\\t\\t},\\n\\n\\t\\ttransition: function(ease) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tif (!me._view) {\\n\\t\\t\\t\\tme._view = helpers.clone(me._model);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// No animation -> No Transition\\n\\t\\t\\tif (ease === 1) {\\n\\t\\t\\t\\tme._view = me._model;\\n\\t\\t\\t\\tme._start = null;\\n\\t\\t\\t\\treturn me;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!me._start) {\\n\\t\\t\\t\\tme.pivot();\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.each(me._model, function(value, key) {\\n\\n\\t\\t\\t\\tif (key[0] === '_') {\\n\\t\\t\\t\\t\\t// Only non-underscored properties\\n\\t\\t\\t\\t// Init if doesn't exist\\n\\t\\t\\t\\t} else if (!me._view.hasOwnProperty(key)) {\\n\\t\\t\\t\\t\\tif (typeof value === 'number' && !isNaN(me._view[key])) {\\n\\t\\t\\t\\t\\t\\tme._view[key] = value * ease;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tme._view[key] = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t// No unnecessary computations\\n\\t\\t\\t\\t} else if (value === me._view[key]) {\\n\\t\\t\\t\\t\\t// It's the same! Woohoo!\\n\\t\\t\\t\\t// Color transitions if possible\\n\\t\\t\\t\\t} else if (typeof value === 'string') {\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tvar color = helpers.color(me._model[key]).mix(helpers.color(me._start[key]), ease);\\n\\t\\t\\t\\t\\t\\tme._view[key] = color.rgbString();\\n\\t\\t\\t\\t\\t} catch (err) {\\n\\t\\t\\t\\t\\t\\tme._view[key] = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Number transitions\\n\\t\\t\\t\\t} else if (typeof value === 'number') {\\n\\t\\t\\t\\t\\tvar startVal = me._start[key] !== undefined && isNaN(me._start[key]) === false ? me._start[key] : 0;\\n\\t\\t\\t\\t\\tme._view[key] = ((me._model[key] - startVal) * ease) + startVal;\\n\\t\\t\\t\\t// Everything else\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tme._view[key] = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, me);\\n\\n\\t\\t\\treturn me;\\n\\t\\t},\\n\\n\\t\\ttooltipPosition: function() {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: this._model.x,\\n\\t\\t\\t\\ty: this._model.y\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\thasValue: function() {\\n\\t\\t\\treturn helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);\\n\\t\\t}\\n\\t});\\n\\n\\tChart.Element.extend = helpers.inherits;\\n\\n};\\n\\n},{}],26:[function(require,module,exports){\\n/* global window: false */\\n/* global document: false */\\n'use strict';\\n\\nvar color = require(3);\\n\\nmodule.exports = function(Chart) {\\n\\t// Global Chart helpers object for utility methods and classes\\n\\tvar helpers = Chart.helpers = {};\\n\\n\\t// -- Basic js utility methods\\n\\thelpers.each = function(loopable, callback, self, reverse) {\\n\\t\\t// Check to see if null or undefined firstly.\\n\\t\\tvar i, len;\\n\\t\\tif (helpers.isArray(loopable)) {\\n\\t\\t\\tlen = loopable.length;\\n\\t\\t\\tif (reverse) {\\n\\t\\t\\t\\tfor (i = len - 1; i >= 0; i--) {\\n\\t\\t\\t\\t\\tcallback.call(self, loopable[i], i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (i = 0; i < len; i++) {\\n\\t\\t\\t\\t\\tcallback.call(self, loopable[i], i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else if (typeof loopable === 'object') {\\n\\t\\t\\tvar keys = Object.keys(loopable);\\n\\t\\t\\tlen = keys.length;\\n\\t\\t\\tfor (i = 0; i < len; i++) {\\n\\t\\t\\t\\tcallback.call(self, loopable[keys[i]], keys[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\thelpers.clone = function(obj) {\\n\\t\\tvar objClone = {};\\n\\t\\thelpers.each(obj, function(value, key) {\\n\\t\\t\\tif (helpers.isArray(value)) {\\n\\t\\t\\t\\tobjClone[key] = value.slice(0);\\n\\t\\t\\t} else if (typeof value === 'object' && value !== null) {\\n\\t\\t\\t\\tobjClone[key] = helpers.clone(value);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tobjClone[key] = value;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn objClone;\\n\\t};\\n\\thelpers.extend = function(base) {\\n\\t\\tvar setFn = function(value, key) {\\n\\t\\t\\tbase[key] = value;\\n\\t\\t};\\n\\t\\tfor (var i = 1, ilen = arguments.length; i < ilen; i++) {\\n\\t\\t\\thelpers.each(arguments[i], setFn);\\n\\t\\t}\\n\\t\\treturn base;\\n\\t};\\n\\t// Need a special merge function to chart configs since they are now grouped\\n\\thelpers.configMerge = function(_base) {\\n\\t\\tvar base = helpers.clone(_base);\\n\\t\\thelpers.each(Array.prototype.slice.call(arguments, 1), function(extension) {\\n\\t\\t\\thelpers.each(extension, function(value, key) {\\n\\t\\t\\t\\tvar baseHasProperty = base.hasOwnProperty(key);\\n\\t\\t\\t\\tvar baseVal = baseHasProperty ? base[key] : {};\\n\\n\\t\\t\\t\\tif (key === 'scales') {\\n\\t\\t\\t\\t\\t// Scale config merging is complex. Add our own function here for that\\n\\t\\t\\t\\t\\tbase[key] = helpers.scaleMerge(baseVal, value);\\n\\t\\t\\t\\t} else if (key === 'scale') {\\n\\t\\t\\t\\t\\t// Used in polar area & radar charts since there is only one scale\\n\\t\\t\\t\\t\\tbase[key] = helpers.configMerge(baseVal, Chart.scaleService.getScaleDefaults(value.type), value);\\n\\t\\t\\t\\t} else if (baseHasProperty\\n\\t\\t\\t\\t\\t\\t&& typeof baseVal === 'object'\\n\\t\\t\\t\\t\\t\\t&& !helpers.isArray(baseVal)\\n\\t\\t\\t\\t\\t\\t&& baseVal !== null\\n\\t\\t\\t\\t\\t\\t&& typeof value === 'object'\\n\\t\\t\\t\\t\\t\\t&& !helpers.isArray(value)) {\\n\\t\\t\\t\\t\\t// If we are overwriting an object with an object, do a merge of the properties.\\n\\t\\t\\t\\t\\tbase[key] = helpers.configMerge(baseVal, value);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// can just overwrite the value in this case\\n\\t\\t\\t\\t\\tbase[key] = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\treturn base;\\n\\t};\\n\\thelpers.scaleMerge = function(_base, extension) {\\n\\t\\tvar base = helpers.clone(_base);\\n\\n\\t\\thelpers.each(extension, function(value, key) {\\n\\t\\t\\tif (key === 'xAxes' || key === 'yAxes') {\\n\\t\\t\\t\\t// These properties are arrays of items\\n\\t\\t\\t\\tif (base.hasOwnProperty(key)) {\\n\\t\\t\\t\\t\\thelpers.each(value, function(valueObj, index) {\\n\\t\\t\\t\\t\\t\\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\\n\\t\\t\\t\\t\\t\\tvar axisDefaults = Chart.scaleService.getScaleDefaults(axisType);\\n\\t\\t\\t\\t\\t\\tif (index >= base[key].length || !base[key][index].type) {\\n\\t\\t\\t\\t\\t\\t\\tbase[key].push(helpers.configMerge(axisDefaults, valueObj));\\n\\t\\t\\t\\t\\t\\t} else if (valueObj.type && valueObj.type !== base[key][index].type) {\\n\\t\\t\\t\\t\\t\\t\\t// Type changed. Bring in the new defaults before we bring in valueObj so that valueObj can override the correct scale defaults\\n\\t\\t\\t\\t\\t\\t\\tbase[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Type is the same\\n\\t\\t\\t\\t\\t\\t\\tbase[key][index] = helpers.configMerge(base[key][index], valueObj);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbase[key] = [];\\n\\t\\t\\t\\t\\thelpers.each(value, function(valueObj) {\\n\\t\\t\\t\\t\\t\\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\\n\\t\\t\\t\\t\\t\\tbase[key].push(helpers.configMerge(Chart.scaleService.getScaleDefaults(axisType), valueObj));\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (base.hasOwnProperty(key) && typeof base[key] === 'object' && base[key] !== null && typeof value === 'object') {\\n\\t\\t\\t\\t// If we are overwriting an object with an object, do a merge of the properties.\\n\\t\\t\\t\\tbase[key] = helpers.configMerge(base[key], value);\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// can just overwrite the value in this case\\n\\t\\t\\t\\tbase[key] = value;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn base;\\n\\t};\\n\\thelpers.getValueAtIndexOrDefault = function(value, index, defaultValue) {\\n\\t\\tif (value === undefined || value === null) {\\n\\t\\t\\treturn defaultValue;\\n\\t\\t}\\n\\n\\t\\tif (helpers.isArray(value)) {\\n\\t\\t\\treturn index < value.length ? value[index] : defaultValue;\\n\\t\\t}\\n\\n\\t\\treturn value;\\n\\t};\\n\\thelpers.getValueOrDefault = function(value, defaultValue) {\\n\\t\\treturn value === undefined ? defaultValue : value;\\n\\t};\\n\\thelpers.indexOf = Array.prototype.indexOf?\\n\\t\\tfunction(array, item) {\\n\\t\\t\\treturn array.indexOf(item);\\n\\t\\t}:\\n\\t\\tfunction(array, item) {\\n\\t\\t\\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\\n\\t\\t\\t\\tif (array[i] === item) {\\n\\t\\t\\t\\t\\treturn i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t};\\n\\thelpers.where = function(collection, filterCallback) {\\n\\t\\tif (helpers.isArray(collection) && Array.prototype.filter) {\\n\\t\\t\\treturn collection.filter(filterCallback);\\n\\t\\t}\\n\\t\\tvar filtered = [];\\n\\n\\t\\thelpers.each(collection, function(item) {\\n\\t\\t\\tif (filterCallback(item)) {\\n\\t\\t\\t\\tfiltered.push(item);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn filtered;\\n\\t};\\n\\thelpers.findIndex = Array.prototype.findIndex?\\n\\t\\tfunction(array, callback, scope) {\\n\\t\\t\\treturn array.findIndex(callback, scope);\\n\\t\\t} :\\n\\t\\tfunction(array, callback, scope) {\\n\\t\\t\\tscope = scope === undefined? array : scope;\\n\\t\\t\\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\\n\\t\\t\\t\\tif (callback.call(scope, array[i], i, array)) {\\n\\t\\t\\t\\t\\treturn i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t};\\n\\thelpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {\\n\\t\\t// Default to start of the array\\n\\t\\tif (startIndex === undefined || startIndex === null) {\\n\\t\\t\\tstartIndex = -1;\\n\\t\\t}\\n\\t\\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++) {\\n\\t\\t\\tvar currentItem = arrayToSearch[i];\\n\\t\\t\\tif (filterCallback(currentItem)) {\\n\\t\\t\\t\\treturn currentItem;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\thelpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {\\n\\t\\t// Default to end of the array\\n\\t\\tif (startIndex === undefined || startIndex === null) {\\n\\t\\t\\tstartIndex = arrayToSearch.length;\\n\\t\\t}\\n\\t\\tfor (var i = startIndex - 1; i >= 0; i--) {\\n\\t\\t\\tvar currentItem = arrayToSearch[i];\\n\\t\\t\\tif (filterCallback(currentItem)) {\\n\\t\\t\\t\\treturn currentItem;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\thelpers.inherits = function(extensions) {\\n\\t\\t// Basic javascript inheritance based on the model created in Backbone.js\\n\\t\\tvar me = this;\\n\\t\\tvar ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {\\n\\t\\t\\treturn me.apply(this, arguments);\\n\\t\\t};\\n\\n\\t\\tvar Surrogate = function() {\\n\\t\\t\\tthis.constructor = ChartElement;\\n\\t\\t};\\n\\t\\tSurrogate.prototype = me.prototype;\\n\\t\\tChartElement.prototype = new Surrogate();\\n\\n\\t\\tChartElement.extend = helpers.inherits;\\n\\n\\t\\tif (extensions) {\\n\\t\\t\\thelpers.extend(ChartElement.prototype, extensions);\\n\\t\\t}\\n\\n\\t\\tChartElement.__super__ = me.prototype;\\n\\n\\t\\treturn ChartElement;\\n\\t};\\n\\thelpers.noop = function() {};\\n\\thelpers.uid = (function() {\\n\\t\\tvar id = 0;\\n\\t\\treturn function() {\\n\\t\\t\\treturn id++;\\n\\t\\t};\\n\\t}());\\n\\t// -- Math methods\\n\\thelpers.isNumber = function(n) {\\n\\t\\treturn !isNaN(parseFloat(n)) && isFinite(n);\\n\\t};\\n\\thelpers.almostEquals = function(x, y, epsilon) {\\n\\t\\treturn Math.abs(x - y) < epsilon;\\n\\t};\\n\\thelpers.almostWhole = function(x, epsilon) {\\n\\t\\tvar rounded = Math.round(x);\\n\\t\\treturn (((rounded - epsilon) < x) && ((rounded + epsilon) > x));\\n\\t};\\n\\thelpers.max = function(array) {\\n\\t\\treturn array.reduce(function(max, value) {\\n\\t\\t\\tif (!isNaN(value)) {\\n\\t\\t\\t\\treturn Math.max(max, value);\\n\\t\\t\\t}\\n\\t\\t\\treturn max;\\n\\t\\t}, Number.NEGATIVE_INFINITY);\\n\\t};\\n\\thelpers.min = function(array) {\\n\\t\\treturn array.reduce(function(min, value) {\\n\\t\\t\\tif (!isNaN(value)) {\\n\\t\\t\\t\\treturn Math.min(min, value);\\n\\t\\t\\t}\\n\\t\\t\\treturn min;\\n\\t\\t}, Number.POSITIVE_INFINITY);\\n\\t};\\n\\thelpers.sign = Math.sign?\\n\\t\\tfunction(x) {\\n\\t\\t\\treturn Math.sign(x);\\n\\t\\t} :\\n\\t\\tfunction(x) {\\n\\t\\t\\tx = +x; // convert to a number\\n\\t\\t\\tif (x === 0 || isNaN(x)) {\\n\\t\\t\\t\\treturn x;\\n\\t\\t\\t}\\n\\t\\t\\treturn x > 0 ? 1 : -1;\\n\\t\\t};\\n\\thelpers.log10 = Math.log10?\\n\\t\\tfunction(x) {\\n\\t\\t\\treturn Math.log10(x);\\n\\t\\t} :\\n\\t\\tfunction(x) {\\n\\t\\t\\treturn Math.log(x) / Math.LN10;\\n\\t\\t};\\n\\thelpers.toRadians = function(degrees) {\\n\\t\\treturn degrees * (Math.PI / 180);\\n\\t};\\n\\thelpers.toDegrees = function(radians) {\\n\\t\\treturn radians * (180 / Math.PI);\\n\\t};\\n\\t// Gets the angle from vertical upright to the point about a centre.\\n\\thelpers.getAngleFromPoint = function(centrePoint, anglePoint) {\\n\\t\\tvar distanceFromXCenter = anglePoint.x - centrePoint.x,\\n\\t\\t\\tdistanceFromYCenter = anglePoint.y - centrePoint.y,\\n\\t\\t\\tradialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\\n\\n\\t\\tvar angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\\n\\n\\t\\tif (angle < (-0.5 * Math.PI)) {\\n\\t\\t\\tangle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tangle: angle,\\n\\t\\t\\tdistance: radialDistanceFromCenter\\n\\t\\t};\\n\\t};\\n\\thelpers.distanceBetweenPoints = function(pt1, pt2) {\\n\\t\\treturn Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\\n\\t};\\n\\thelpers.aliasPixel = function(pixelWidth) {\\n\\t\\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;\\n\\t};\\n\\thelpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {\\n\\t\\t// Props to Rob Spencer at scaled innovation for his post on splining between points\\n\\t\\t// http://scaledinnovation.com/analytics/splines/aboutSplines.html\\n\\n\\t\\t// This function must also respect \\\"skipped\\\" points\\n\\n\\t\\tvar previous = firstPoint.skip ? middlePoint : firstPoint,\\n\\t\\t\\tcurrent = middlePoint,\\n\\t\\t\\tnext = afterPoint.skip ? middlePoint : afterPoint;\\n\\n\\t\\tvar d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\\n\\t\\tvar d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\\n\\n\\t\\tvar s01 = d01 / (d01 + d12);\\n\\t\\tvar s12 = d12 / (d01 + d12);\\n\\n\\t\\t// If all points are the same, s01 & s02 will be inf\\n\\t\\ts01 = isNaN(s01) ? 0 : s01;\\n\\t\\ts12 = isNaN(s12) ? 0 : s12;\\n\\n\\t\\tvar fa = t * s01; // scaling factor for triangle Ta\\n\\t\\tvar fb = t * s12;\\n\\n\\t\\treturn {\\n\\t\\t\\tprevious: {\\n\\t\\t\\t\\tx: current.x - fa * (next.x - previous.x),\\n\\t\\t\\t\\ty: current.y - fa * (next.y - previous.y)\\n\\t\\t\\t},\\n\\t\\t\\tnext: {\\n\\t\\t\\t\\tx: current.x + fb * (next.x - previous.x),\\n\\t\\t\\t\\ty: current.y + fb * (next.y - previous.y)\\n\\t\\t\\t}\\n\\t\\t};\\n\\t};\\n\\thelpers.EPSILON = Number.EPSILON || 1e-14;\\n\\thelpers.splineCurveMonotone = function(points) {\\n\\t\\t// This function calculates Bézier control points in a similar way than |splineCurve|,\\n\\t\\t// but preserves monotonicity of the provided data and ensures no local extremums are added\\n\\t\\t// between the dataset discrete points due to the interpolation.\\n\\t\\t// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\\n\\n\\t\\tvar pointsWithTangents = (points || []).map(function(point) {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tmodel: point._model,\\n\\t\\t\\t\\tdeltaK: 0,\\n\\t\\t\\t\\tmK: 0\\n\\t\\t\\t};\\n\\t\\t});\\n\\n\\t\\t// Calculate slopes (deltaK) and initialize tangents (mK)\\n\\t\\tvar pointsLen = pointsWithTangents.length;\\n\\t\\tvar i, pointBefore, pointCurrent, pointAfter;\\n\\t\\tfor (i = 0; i < pointsLen; ++i) {\\n\\t\\t\\tpointCurrent = pointsWithTangents[i];\\n\\t\\t\\tif (pointCurrent.model.skip) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\\n\\t\\t\\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\\n\\t\\t\\tif (pointAfter && !pointAfter.model.skip) {\\n\\t\\t\\t\\tvar slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);\\n\\n\\t\\t\\t\\t// In the case of two points that appear at the same x pixel, slopeDeltaX is 0\\n\\t\\t\\t\\tpointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!pointBefore || pointBefore.model.skip) {\\n\\t\\t\\t\\tpointCurrent.mK = pointCurrent.deltaK;\\n\\t\\t\\t} else if (!pointAfter || pointAfter.model.skip) {\\n\\t\\t\\t\\tpointCurrent.mK = pointBefore.deltaK;\\n\\t\\t\\t} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\\n\\t\\t\\t\\tpointCurrent.mK = 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Adjust tangents to ensure monotonic properties\\n\\t\\tvar alphaK, betaK, tauK, squaredMagnitude;\\n\\t\\tfor (i = 0; i < pointsLen - 1; ++i) {\\n\\t\\t\\tpointCurrent = pointsWithTangents[i];\\n\\t\\t\\tpointAfter = pointsWithTangents[i + 1];\\n\\t\\t\\tif (pointCurrent.model.skip || pointAfter.model.skip) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\\n\\t\\t\\t\\tpointCurrent.mK = pointAfter.mK = 0;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\talphaK = pointCurrent.mK / pointCurrent.deltaK;\\n\\t\\t\\tbetaK = pointAfter.mK / pointCurrent.deltaK;\\n\\t\\t\\tsquaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\\n\\t\\t\\tif (squaredMagnitude <= 9) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\ttauK = 3 / Math.sqrt(squaredMagnitude);\\n\\t\\t\\tpointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\\n\\t\\t\\tpointAfter.mK = betaK * tauK * pointCurrent.deltaK;\\n\\t\\t}\\n\\n\\t\\t// Compute control points\\n\\t\\tvar deltaX;\\n\\t\\tfor (i = 0; i < pointsLen; ++i) {\\n\\t\\t\\tpointCurrent = pointsWithTangents[i];\\n\\t\\t\\tif (pointCurrent.model.skip) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\\n\\t\\t\\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\\n\\t\\t\\tif (pointBefore && !pointBefore.model.skip) {\\n\\t\\t\\t\\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\\n\\t\\t\\t\\tpointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\\n\\t\\t\\t\\tpointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\\n\\t\\t\\t}\\n\\t\\t\\tif (pointAfter && !pointAfter.model.skip) {\\n\\t\\t\\t\\tdeltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\\n\\t\\t\\t\\tpointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\\n\\t\\t\\t\\tpointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\thelpers.nextItem = function(collection, index, loop) {\\n\\t\\tif (loop) {\\n\\t\\t\\treturn index >= collection.length - 1 ? collection[0] : collection[index + 1];\\n\\t\\t}\\n\\t\\treturn index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\\n\\t};\\n\\thelpers.previousItem = function(collection, index, loop) {\\n\\t\\tif (loop) {\\n\\t\\t\\treturn index <= 0 ? collection[collection.length - 1] : collection[index - 1];\\n\\t\\t}\\n\\t\\treturn index <= 0 ? collection[0] : collection[index - 1];\\n\\t};\\n\\t// Implementation of the nice number algorithm used in determining where axis labels will go\\n\\thelpers.niceNum = function(range, round) {\\n\\t\\tvar exponent = Math.floor(helpers.log10(range));\\n\\t\\tvar fraction = range / Math.pow(10, exponent);\\n\\t\\tvar niceFraction;\\n\\n\\t\\tif (round) {\\n\\t\\t\\tif (fraction < 1.5) {\\n\\t\\t\\t\\tniceFraction = 1;\\n\\t\\t\\t} else if (fraction < 3) {\\n\\t\\t\\t\\tniceFraction = 2;\\n\\t\\t\\t} else if (fraction < 7) {\\n\\t\\t\\t\\tniceFraction = 5;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tniceFraction = 10;\\n\\t\\t\\t}\\n\\t\\t} else if (fraction <= 1.0) {\\n\\t\\t\\tniceFraction = 1;\\n\\t\\t} else if (fraction <= 2) {\\n\\t\\t\\tniceFraction = 2;\\n\\t\\t} else if (fraction <= 5) {\\n\\t\\t\\tniceFraction = 5;\\n\\t\\t} else {\\n\\t\\t\\tniceFraction = 10;\\n\\t\\t}\\n\\n\\t\\treturn niceFraction * Math.pow(10, exponent);\\n\\t};\\n\\t// Easing functions adapted from Robert Penner's easing equations\\n\\t// http://www.robertpenner.com/easing/\\n\\tvar easingEffects = helpers.easingEffects = {\\n\\t\\tlinear: function(t) {\\n\\t\\t\\treturn t;\\n\\t\\t},\\n\\t\\teaseInQuad: function(t) {\\n\\t\\t\\treturn t * t;\\n\\t\\t},\\n\\t\\teaseOutQuad: function(t) {\\n\\t\\t\\treturn -1 * t * (t - 2);\\n\\t\\t},\\n\\t\\teaseInOutQuad: function(t) {\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * t * t;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1 / 2 * ((--t) * (t - 2) - 1);\\n\\t\\t},\\n\\t\\teaseInCubic: function(t) {\\n\\t\\t\\treturn t * t * t;\\n\\t\\t},\\n\\t\\teaseOutCubic: function(t) {\\n\\t\\t\\treturn 1 * ((t = t / 1 - 1) * t * t + 1);\\n\\t\\t},\\n\\t\\teaseInOutCubic: function(t) {\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * t * t * t;\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 / 2 * ((t -= 2) * t * t + 2);\\n\\t\\t},\\n\\t\\teaseInQuart: function(t) {\\n\\t\\t\\treturn t * t * t * t;\\n\\t\\t},\\n\\t\\teaseOutQuart: function(t) {\\n\\t\\t\\treturn -1 * ((t = t / 1 - 1) * t * t * t - 1);\\n\\t\\t},\\n\\t\\teaseInOutQuart: function(t) {\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * t * t * t * t;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1 / 2 * ((t -= 2) * t * t * t - 2);\\n\\t\\t},\\n\\t\\teaseInQuint: function(t) {\\n\\t\\t\\treturn 1 * (t /= 1) * t * t * t * t;\\n\\t\\t},\\n\\t\\teaseOutQuint: function(t) {\\n\\t\\t\\treturn 1 * ((t = t / 1 - 1) * t * t * t * t + 1);\\n\\t\\t},\\n\\t\\teaseInOutQuint: function(t) {\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * t * t * t * t * t;\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 / 2 * ((t -= 2) * t * t * t * t + 2);\\n\\t\\t},\\n\\t\\teaseInSine: function(t) {\\n\\t\\t\\treturn -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;\\n\\t\\t},\\n\\t\\teaseOutSine: function(t) {\\n\\t\\t\\treturn 1 * Math.sin(t / 1 * (Math.PI / 2));\\n\\t\\t},\\n\\t\\teaseInOutSine: function(t) {\\n\\t\\t\\treturn -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);\\n\\t\\t},\\n\\t\\teaseInExpo: function(t) {\\n\\t\\t\\treturn (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));\\n\\t\\t},\\n\\t\\teaseOutExpo: function(t) {\\n\\t\\t\\treturn (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);\\n\\t\\t},\\n\\t\\teaseInOutExpo: function(t) {\\n\\t\\t\\tif (t === 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif (t === 1) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * Math.pow(2, 10 * (t - 1));\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 / 2 * (-Math.pow(2, -10 * --t) + 2);\\n\\t\\t},\\n\\t\\teaseInCirc: function(t) {\\n\\t\\t\\tif (t >= 1) {\\n\\t\\t\\t\\treturn t;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);\\n\\t\\t},\\n\\t\\teaseOutCirc: function(t) {\\n\\t\\t\\treturn 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);\\n\\t\\t},\\n\\t\\teaseInOutCirc: function(t) {\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn -1 / 2 * (Math.sqrt(1 - t * t) - 1);\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);\\n\\t\\t},\\n\\t\\teaseInElastic: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\tvar p = 0;\\n\\t\\t\\tvar a = 1;\\n\\t\\t\\tif (t === 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif ((t /= 1) === 1) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (!p) {\\n\\t\\t\\t\\tp = 1 * 0.3;\\n\\t\\t\\t}\\n\\t\\t\\tif (a < Math.abs(1)) {\\n\\t\\t\\t\\ta = 1;\\n\\t\\t\\t\\ts = p / 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts = p / (2 * Math.PI) * Math.asin(1 / a);\\n\\t\\t\\t}\\n\\t\\t\\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\\n\\t\\t},\\n\\t\\teaseOutElastic: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\tvar p = 0;\\n\\t\\t\\tvar a = 1;\\n\\t\\t\\tif (t === 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif ((t /= 1) === 1) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (!p) {\\n\\t\\t\\t\\tp = 1 * 0.3;\\n\\t\\t\\t}\\n\\t\\t\\tif (a < Math.abs(1)) {\\n\\t\\t\\t\\ta = 1;\\n\\t\\t\\t\\ts = p / 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts = p / (2 * Math.PI) * Math.asin(1 / a);\\n\\t\\t\\t}\\n\\t\\t\\treturn a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;\\n\\t\\t},\\n\\t\\teaseInOutElastic: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\tvar p = 0;\\n\\t\\t\\tvar a = 1;\\n\\t\\t\\tif (t === 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif ((t /= 1 / 2) === 2) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (!p) {\\n\\t\\t\\t\\tp = 1 * (0.3 * 1.5);\\n\\t\\t\\t}\\n\\t\\t\\tif (a < Math.abs(1)) {\\n\\t\\t\\t\\ta = 1;\\n\\t\\t\\t\\ts = p / 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts = p / (2 * Math.PI) * Math.asin(1 / a);\\n\\t\\t\\t}\\n\\t\\t\\tif (t < 1) {\\n\\t\\t\\t\\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\\n\\t\\t\\t}\\n\\t\\t\\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;\\n\\t\\t},\\n\\t\\teaseInBack: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\treturn 1 * (t /= 1) * t * ((s + 1) * t - s);\\n\\t\\t},\\n\\t\\teaseOutBack: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\treturn 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);\\n\\t\\t},\\n\\t\\teaseInOutBack: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\\n\\t\\t},\\n\\t\\teaseInBounce: function(t) {\\n\\t\\t\\treturn 1 - easingEffects.easeOutBounce(1 - t);\\n\\t\\t},\\n\\t\\teaseOutBounce: function(t) {\\n\\t\\t\\tif ((t /= 1) < (1 / 2.75)) {\\n\\t\\t\\t\\treturn 1 * (7.5625 * t * t);\\n\\t\\t\\t} else if (t < (2 / 2.75)) {\\n\\t\\t\\t\\treturn 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75);\\n\\t\\t\\t} else if (t < (2.5 / 2.75)) {\\n\\t\\t\\t\\treturn 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375);\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375);\\n\\t\\t},\\n\\t\\teaseInOutBounce: function(t) {\\n\\t\\t\\tif (t < 1 / 2) {\\n\\t\\t\\t\\treturn easingEffects.easeInBounce(t * 2) * 0.5;\\n\\t\\t\\t}\\n\\t\\t\\treturn easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;\\n\\t\\t}\\n\\t};\\n\\t// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\\n\\thelpers.requestAnimFrame = (function() {\\n\\t\\treturn window.requestAnimationFrame ||\\n\\t\\t\\twindow.webkitRequestAnimationFrame ||\\n\\t\\t\\twindow.mozRequestAnimationFrame ||\\n\\t\\t\\twindow.oRequestAnimationFrame ||\\n\\t\\t\\twindow.msRequestAnimationFrame ||\\n\\t\\t\\tfunction(callback) {\\n\\t\\t\\t\\treturn window.setTimeout(callback, 1000 / 60);\\n\\t\\t\\t};\\n\\t}());\\n\\t// -- DOM methods\\n\\thelpers.getRelativePosition = function(evt, chart) {\\n\\t\\tvar mouseX, mouseY;\\n\\t\\tvar e = evt.originalEvent || evt,\\n\\t\\t\\tcanvas = evt.currentTarget || evt.srcElement,\\n\\t\\t\\tboundingRect = canvas.getBoundingClientRect();\\n\\n\\t\\tvar touches = e.touches;\\n\\t\\tif (touches && touches.length > 0) {\\n\\t\\t\\tmouseX = touches[0].clientX;\\n\\t\\t\\tmouseY = touches[0].clientY;\\n\\n\\t\\t} else {\\n\\t\\t\\tmouseX = e.clientX;\\n\\t\\t\\tmouseY = e.clientY;\\n\\t\\t}\\n\\n\\t\\t// Scale mouse coordinates into canvas coordinates\\n\\t\\t// by following the pattern laid out by 'jerryj' in the comments of\\n\\t\\t// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\\n\\t\\tvar paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));\\n\\t\\tvar paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));\\n\\t\\tvar paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));\\n\\t\\tvar paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));\\n\\t\\tvar width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\\n\\t\\tvar height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\\n\\n\\t\\t// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\\n\\t\\t// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\\n\\t\\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);\\n\\t\\tmouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\\n\\n\\t\\treturn {\\n\\t\\t\\tx: mouseX,\\n\\t\\t\\ty: mouseY\\n\\t\\t};\\n\\n\\t};\\n\\thelpers.addEvent = function(node, eventType, method) {\\n\\t\\tif (node.addEventListener) {\\n\\t\\t\\tnode.addEventListener(eventType, method);\\n\\t\\t} else if (node.attachEvent) {\\n\\t\\t\\tnode.attachEvent('on' + eventType, method);\\n\\t\\t} else {\\n\\t\\t\\tnode['on' + eventType] = method;\\n\\t\\t}\\n\\t};\\n\\thelpers.removeEvent = function(node, eventType, handler) {\\n\\t\\tif (node.removeEventListener) {\\n\\t\\t\\tnode.removeEventListener(eventType, handler, false);\\n\\t\\t} else if (node.detachEvent) {\\n\\t\\t\\tnode.detachEvent('on' + eventType, handler);\\n\\t\\t} else {\\n\\t\\t\\tnode['on' + eventType] = helpers.noop;\\n\\t\\t}\\n\\t};\\n\\n\\t// Private helper function to convert max-width/max-height values that may be percentages into a number\\n\\tfunction parseMaxStyle(styleValue, node, parentProperty) {\\n\\t\\tvar valueInPixels;\\n\\t\\tif (typeof(styleValue) === 'string') {\\n\\t\\t\\tvalueInPixels = parseInt(styleValue, 10);\\n\\n\\t\\t\\tif (styleValue.indexOf('%') !== -1) {\\n\\t\\t\\t\\t// percentage * size in dimension\\n\\t\\t\\t\\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tvalueInPixels = styleValue;\\n\\t\\t}\\n\\n\\t\\treturn valueInPixels;\\n\\t}\\n\\n\\t/**\\n\\t * Returns if the given value contains an effective constraint.\\n\\t * @private\\n\\t */\\n\\tfunction isConstrainedValue(value) {\\n\\t\\treturn value !== undefined && value !== null && value !== 'none';\\n\\t}\\n\\n\\t// Private helper to get a constraint dimension\\n\\t// @param domNode : the node to check the constraint on\\n\\t// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)\\n\\t// @param percentageProperty : property of parent to use when calculating width as a percentage\\n\\t// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser\\n\\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\\n\\t\\tvar view = document.defaultView;\\n\\t\\tvar parentNode = domNode.parentNode;\\n\\t\\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\\n\\t\\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\\n\\t\\tvar hasCNode = isConstrainedValue(constrainedNode);\\n\\t\\tvar hasCContainer = isConstrainedValue(constrainedContainer);\\n\\t\\tvar infinity = Number.POSITIVE_INFINITY;\\n\\n\\t\\tif (hasCNode || hasCContainer) {\\n\\t\\t\\treturn Math.min(\\n\\t\\t\\t\\thasCNode? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\\n\\t\\t\\t\\thasCContainer? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\\n\\t\\t}\\n\\n\\t\\treturn 'none';\\n\\t}\\n\\t// returns Number or undefined if no constraint\\n\\thelpers.getConstraintWidth = function(domNode) {\\n\\t\\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');\\n\\t};\\n\\t// returns Number or undefined if no constraint\\n\\thelpers.getConstraintHeight = function(domNode) {\\n\\t\\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');\\n\\t};\\n\\thelpers.getMaximumWidth = function(domNode) {\\n\\t\\tvar container = domNode.parentNode;\\n\\t\\tvar paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);\\n\\t\\tvar paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);\\n\\t\\tvar w = container.clientWidth - paddingLeft - paddingRight;\\n\\t\\tvar cw = helpers.getConstraintWidth(domNode);\\n\\t\\treturn isNaN(cw)? w : Math.min(w, cw);\\n\\t};\\n\\thelpers.getMaximumHeight = function(domNode) {\\n\\t\\tvar container = domNode.parentNode;\\n\\t\\tvar paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);\\n\\t\\tvar paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);\\n\\t\\tvar h = container.clientHeight - paddingTop - paddingBottom;\\n\\t\\tvar ch = helpers.getConstraintHeight(domNode);\\n\\t\\treturn isNaN(ch)? h : Math.min(h, ch);\\n\\t};\\n\\thelpers.getStyle = function(el, property) {\\n\\t\\treturn el.currentStyle ?\\n\\t\\t\\tel.currentStyle[property] :\\n\\t\\t\\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);\\n\\t};\\n\\thelpers.retinaScale = function(chart) {\\n\\t\\tvar pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;\\n\\t\\tif (pixelRatio === 1) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar canvas = chart.canvas;\\n\\t\\tvar height = chart.height;\\n\\t\\tvar width = chart.width;\\n\\n\\t\\tcanvas.height = height * pixelRatio;\\n\\t\\tcanvas.width = width * pixelRatio;\\n\\t\\tchart.ctx.scale(pixelRatio, pixelRatio);\\n\\n\\t\\t// If no style has been set on the canvas, the render size is used as display size,\\n\\t\\t// making the chart visually bigger, so let's enforce it to the \\\"correct\\\" values.\\n\\t\\t// See https://github.com/chartjs/Chart.js/issues/3575\\n\\t\\tcanvas.style.height = height + 'px';\\n\\t\\tcanvas.style.width = width + 'px';\\n\\t};\\n\\t// -- Canvas methods\\n\\thelpers.clear = function(chart) {\\n\\t\\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\\n\\t};\\n\\thelpers.fontString = function(pixelSize, fontStyle, fontFamily) {\\n\\t\\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\\n\\t};\\n\\thelpers.longestText = function(ctx, font, arrayOfThings, cache) {\\n\\t\\tcache = cache || {};\\n\\t\\tvar data = cache.data = cache.data || {};\\n\\t\\tvar gc = cache.garbageCollect = cache.garbageCollect || [];\\n\\n\\t\\tif (cache.font !== font) {\\n\\t\\t\\tdata = cache.data = {};\\n\\t\\t\\tgc = cache.garbageCollect = [];\\n\\t\\t\\tcache.font = font;\\n\\t\\t}\\n\\n\\t\\tctx.font = font;\\n\\t\\tvar longest = 0;\\n\\t\\thelpers.each(arrayOfThings, function(thing) {\\n\\t\\t\\t// Undefined strings and arrays should not be measured\\n\\t\\t\\tif (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {\\n\\t\\t\\t\\tlongest = helpers.measureText(ctx, data, gc, longest, thing);\\n\\t\\t\\t} else if (helpers.isArray(thing)) {\\n\\t\\t\\t\\t// if it is an array lets measure each element\\n\\t\\t\\t\\t// to do maybe simplify this function a bit so we can do this more recursively?\\n\\t\\t\\t\\thelpers.each(thing, function(nestedThing) {\\n\\t\\t\\t\\t\\t// Undefined strings and arrays should not be measured\\n\\t\\t\\t\\t\\tif (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {\\n\\t\\t\\t\\t\\t\\tlongest = helpers.measureText(ctx, data, gc, longest, nestedThing);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tvar gcLen = gc.length / 2;\\n\\t\\tif (gcLen > arrayOfThings.length) {\\n\\t\\t\\tfor (var i = 0; i < gcLen; i++) {\\n\\t\\t\\t\\tdelete data[gc[i]];\\n\\t\\t\\t}\\n\\t\\t\\tgc.splice(0, gcLen);\\n\\t\\t}\\n\\t\\treturn longest;\\n\\t};\\n\\thelpers.measureText = function(ctx, data, gc, longest, string) {\\n\\t\\tvar textWidth = data[string];\\n\\t\\tif (!textWidth) {\\n\\t\\t\\ttextWidth = data[string] = ctx.measureText(string).width;\\n\\t\\t\\tgc.push(string);\\n\\t\\t}\\n\\t\\tif (textWidth > longest) {\\n\\t\\t\\tlongest = textWidth;\\n\\t\\t}\\n\\t\\treturn longest;\\n\\t};\\n\\thelpers.numberOfLabelLines = function(arrayOfThings) {\\n\\t\\tvar numberOfLines = 1;\\n\\t\\thelpers.each(arrayOfThings, function(thing) {\\n\\t\\t\\tif (helpers.isArray(thing)) {\\n\\t\\t\\t\\tif (thing.length > numberOfLines) {\\n\\t\\t\\t\\t\\tnumberOfLines = thing.length;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn numberOfLines;\\n\\t};\\n\\thelpers.drawRoundedRectangle = function(ctx, x, y, width, height, radius) {\\n\\t\\tctx.beginPath();\\n\\t\\tctx.moveTo(x + radius, y);\\n\\t\\tctx.lineTo(x + width - radius, y);\\n\\t\\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\\n\\t\\tctx.lineTo(x + width, y + height - radius);\\n\\t\\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\\n\\t\\tctx.lineTo(x + radius, y + height);\\n\\t\\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\\n\\t\\tctx.lineTo(x, y + radius);\\n\\t\\tctx.quadraticCurveTo(x, y, x + radius, y);\\n\\t\\tctx.closePath();\\n\\t};\\n\\thelpers.color = function(c) {\\n\\t\\tif (!color) {\\n\\t\\t\\tconsole.error('Color.js not found!');\\n\\t\\t\\treturn c;\\n\\t\\t}\\n\\n\\t\\t/* global CanvasGradient */\\n\\t\\tif (c instanceof CanvasGradient) {\\n\\t\\t\\treturn color(Chart.defaults.global.defaultColor);\\n\\t\\t}\\n\\n\\t\\treturn color(c);\\n\\t};\\n\\thelpers.isArray = Array.isArray?\\n\\t\\tfunction(obj) {\\n\\t\\t\\treturn Array.isArray(obj);\\n\\t\\t} :\\n\\t\\tfunction(obj) {\\n\\t\\t\\treturn Object.prototype.toString.call(obj) === '[object Array]';\\n\\t\\t};\\n\\t// ! @see http://stackoverflow.com/a/14853974\\n\\thelpers.arrayEquals = function(a0, a1) {\\n\\t\\tvar i, ilen, v0, v1;\\n\\n\\t\\tif (!a0 || !a1 || a0.length !== a1.length) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tfor (i = 0, ilen=a0.length; i < ilen; ++i) {\\n\\t\\t\\tv0 = a0[i];\\n\\t\\t\\tv1 = a1[i];\\n\\n\\t\\t\\tif (v0 instanceof Array && v1 instanceof Array) {\\n\\t\\t\\t\\tif (!helpers.arrayEquals(v0, v1)) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (v0 !== v1) {\\n\\t\\t\\t\\t// NOTE: two different object instances will never be equal: {x:20} != {x:20}\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t};\\n\\thelpers.callCallback = function(fn, args, _tArg) {\\n\\t\\tif (fn && typeof fn.call === 'function') {\\n\\t\\t\\tfn.apply(_tArg, args);\\n\\t\\t}\\n\\t};\\n\\thelpers.getHoverColor = function(colorValue) {\\n\\t\\t/* global CanvasPattern */\\n\\t\\treturn (colorValue instanceof CanvasPattern) ?\\n\\t\\t\\tcolorValue :\\n\\t\\t\\thelpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();\\n\\t};\\n};\\n\\n},{\\\"3\\\":3}],27:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\tvar helpers = Chart.helpers;\\n\\n\\t/**\\n\\t * Helper function to get relative position for an event\\n\\t * @param {Event|IEvent} event - The event to get the position for\\n\\t * @param {Chart} chart - The chart\\n\\t * @returns {Point} the event position\\n\\t */\\n\\tfunction getRelativePosition(e, chart) {\\n\\t\\tif (e.native) {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: e.x,\\n\\t\\t\\t\\ty: e.y\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\treturn helpers.getRelativePosition(e, chart);\\n\\t}\\n\\n\\t/**\\n\\t * Helper function to traverse all of the visible elements in the chart\\n\\t * @param chart {chart} the chart\\n\\t * @param handler {Function} the callback to execute for each visible item\\n\\t */\\n\\tfunction parseVisibleItems(chart, handler) {\\n\\t\\tvar datasets = chart.data.datasets;\\n\\t\\tvar meta, i, j, ilen, jlen;\\n\\n\\t\\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\\n\\t\\t\\tif (!chart.isDatasetVisible(i)) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tmeta = chart.getDatasetMeta(i);\\n\\t\\t\\tfor (j = 0, jlen = meta.data.length; j < jlen; ++j) {\\n\\t\\t\\t\\tvar element = meta.data[j];\\n\\t\\t\\t\\tif (!element._view.skip) {\\n\\t\\t\\t\\t\\thandler(element);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Helper function to get the items that intersect the event position\\n\\t * @param items {ChartElement[]} elements to filter\\n\\t * @param position {Point} the point to be nearest to\\n\\t * @return {ChartElement[]} the nearest items\\n\\t */\\n\\tfunction getIntersectItems(chart, position) {\\n\\t\\tvar elements = [];\\n\\n\\t\\tparseVisibleItems(chart, function(element) {\\n\\t\\t\\tif (element.inRange(position.x, position.y)) {\\n\\t\\t\\t\\telements.push(element);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn elements;\\n\\t}\\n\\n\\t/**\\n\\t * Helper function to get the items nearest to the event position considering all visible items in teh chart\\n\\t * @param chart {Chart} the chart to look at elements from\\n\\t * @param position {Point} the point to be nearest to\\n\\t * @param intersect {Boolean} if true, only consider items that intersect the position\\n\\t * @param distanceMetric {Function} Optional function to provide the distance between\\n\\t * @return {ChartElement[]} the nearest items\\n\\t */\\n\\tfunction getNearestItems(chart, position, intersect, distanceMetric) {\\n\\t\\tvar minDistance = Number.POSITIVE_INFINITY;\\n\\t\\tvar nearestItems = [];\\n\\n\\t\\tif (!distanceMetric) {\\n\\t\\t\\tdistanceMetric = helpers.distanceBetweenPoints;\\n\\t\\t}\\n\\n\\t\\tparseVisibleItems(chart, function(element) {\\n\\t\\t\\tif (intersect && !element.inRange(position.x, position.y)) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar center = element.getCenterPoint();\\n\\t\\t\\tvar distance = distanceMetric(position, center);\\n\\n\\t\\t\\tif (distance < minDistance) {\\n\\t\\t\\t\\tnearestItems = [element];\\n\\t\\t\\t\\tminDistance = distance;\\n\\t\\t\\t} else if (distance === minDistance) {\\n\\t\\t\\t\\t// Can have multiple items at the same distance in which case we sort by size\\n\\t\\t\\t\\tnearestItems.push(element);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn nearestItems;\\n\\t}\\n\\n\\tfunction indexMode(chart, e, options) {\\n\\t\\tvar position = getRelativePosition(e, chart.chart);\\n\\t\\tvar distanceMetric = function(pt1, pt2) {\\n\\t\\t\\treturn Math.abs(pt1.x - pt2.x);\\n\\t\\t};\\n\\t\\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\\n\\t\\tvar elements = [];\\n\\n\\t\\tif (!items.length) {\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\n\\t\\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\\n\\t\\t\\tif (chart.isDatasetVisible(datasetIndex)) {\\n\\t\\t\\t\\tvar meta = chart.getDatasetMeta(datasetIndex),\\n\\t\\t\\t\\t\\telement = meta.data[items[0]._index];\\n\\n\\t\\t\\t\\t// don't count items that are skipped (null data)\\n\\t\\t\\t\\tif (element && !element._view.skip) {\\n\\t\\t\\t\\t\\telements.push(element);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn elements;\\n\\t}\\n\\n\\t/**\\n\\t * @interface IInteractionOptions\\n\\t */\\n\\t/**\\n\\t * If true, only consider items that intersect the point\\n\\t * @name IInterfaceOptions#boolean\\n\\t * @type Boolean\\n\\t */\\n\\n\\t/**\\n\\t * Contains interaction related functions\\n\\t * @namespace Chart.Interaction\\n\\t */\\n\\tChart.Interaction = {\\n\\t\\t// Helper function for different modes\\n\\t\\tmodes: {\\n\\t\\t\\tsingle: function(chart, e) {\\n\\t\\t\\t\\tvar position = getRelativePosition(e, chart.chart);\\n\\t\\t\\t\\tvar elements = [];\\n\\n\\t\\t\\t\\tparseVisibleItems(chart, function(element) {\\n\\t\\t\\t\\t\\tif (element.inRange(position.x, position.y)) {\\n\\t\\t\\t\\t\\t\\telements.push(element);\\n\\t\\t\\t\\t\\t\\treturn elements;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\treturn elements.slice(0, 1);\\n\\t\\t\\t},\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * @function Chart.Interaction.modes.label\\n\\t\\t\\t * @deprecated since version 2.4.0\\n\\t\\t\\t */\\n\\t\\t\\tlabel: indexMode,\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\\n\\t\\t\\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\\n\\t\\t\\t * @function Chart.Interaction.modes.index\\n\\t\\t\\t * @since v2.4.0\\n\\t\\t\\t * @param chart {chart} the chart we are returning items from\\n\\t\\t\\t * @param e {Event} the event we are find things at\\n\\t\\t\\t * @param options {IInteractionOptions} options to use during interaction\\n\\t\\t\\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\\n\\t\\t\\t */\\n\\t\\t\\tindex: indexMode,\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\\n\\t\\t\\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\\n\\t\\t\\t * @function Chart.Interaction.modes.dataset\\n\\t\\t\\t * @param chart {chart} the chart we are returning items from\\n\\t\\t\\t * @param e {Event} the event we are find things at\\n\\t\\t\\t * @param options {IInteractionOptions} options to use during interaction\\n\\t\\t\\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\\n\\t\\t\\t */\\n\\t\\t\\tdataset: function(chart, e, options) {\\n\\t\\t\\t\\tvar position = getRelativePosition(e, chart.chart);\\n\\t\\t\\t\\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false);\\n\\n\\t\\t\\t\\tif (items.length > 0) {\\n\\t\\t\\t\\t\\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn items;\\n\\t\\t\\t},\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * @function Chart.Interaction.modes.x-axis\\n\\t\\t\\t * @deprecated since version 2.4.0. Use index mode and intersect == true\\n\\t\\t\\t */\\n\\t\\t\\t'x-axis': function(chart, e) {\\n\\t\\t\\t\\treturn indexMode(chart, e, true);\\n\\t\\t\\t},\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * Point mode returns all elements that hit test based on the event position\\n\\t\\t\\t * of the event\\n\\t\\t\\t * @function Chart.Interaction.modes.intersect\\n\\t\\t\\t * @param chart {chart} the chart we are returning items from\\n\\t\\t\\t * @param e {Event} the event we are find things at\\n\\t\\t\\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\\n\\t\\t\\t */\\n\\t\\t\\tpoint: function(chart, e) {\\n\\t\\t\\t\\tvar position = getRelativePosition(e, chart.chart);\\n\\t\\t\\t\\treturn getIntersectItems(chart, position);\\n\\t\\t\\t},\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * nearest mode returns the element closest to the point\\n\\t\\t\\t * @function Chart.Interaction.modes.intersect\\n\\t\\t\\t * @param chart {chart} the chart we are returning items from\\n\\t\\t\\t * @param e {Event} the event we are find things at\\n\\t\\t\\t * @param options {IInteractionOptions} options to use\\n\\t\\t\\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\\n\\t\\t\\t */\\n\\t\\t\\tnearest: function(chart, e, options) {\\n\\t\\t\\t\\tvar position = getRelativePosition(e, chart.chart);\\n\\t\\t\\t\\tvar nearestItems = getNearestItems(chart, position, options.intersect);\\n\\n\\t\\t\\t\\t// We have multiple items at the same distance from the event. Now sort by smallest\\n\\t\\t\\t\\tif (nearestItems.length > 1) {\\n\\t\\t\\t\\t\\tnearestItems.sort(function(a, b) {\\n\\t\\t\\t\\t\\t\\tvar sizeA = a.getArea();\\n\\t\\t\\t\\t\\t\\tvar sizeB = b.getArea();\\n\\t\\t\\t\\t\\t\\tvar ret = sizeA - sizeB;\\n\\n\\t\\t\\t\\t\\t\\tif (ret === 0) {\\n\\t\\t\\t\\t\\t\\t\\t// if equal sort by dataset index\\n\\t\\t\\t\\t\\t\\t\\tret = a._datasetIndex - b._datasetIndex;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\treturn ret;\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Return only 1 item\\n\\t\\t\\t\\treturn nearestItems.slice(0, 1);\\n\\t\\t\\t},\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * x mode returns the elements that hit-test at the current x coordinate\\n\\t\\t\\t * @function Chart.Interaction.modes.x\\n\\t\\t\\t * @param chart {chart} the chart we are returning items from\\n\\t\\t\\t * @param e {Event} the event we are find things at\\n\\t\\t\\t * @param options {IInteractionOptions} options to use\\n\\t\\t\\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\\n\\t\\t\\t */\\n\\t\\t\\tx: function(chart, e, options) {\\n\\t\\t\\t\\tvar position = getRelativePosition(e, chart.chart);\\n\\t\\t\\t\\tvar items = [];\\n\\t\\t\\t\\tvar intersectsItem = false;\\n\\n\\t\\t\\t\\tparseVisibleItems(chart, function(element) {\\n\\t\\t\\t\\t\\tif (element.inXRange(position.x)) {\\n\\t\\t\\t\\t\\t\\titems.push(element);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (element.inRange(position.x, position.y)) {\\n\\t\\t\\t\\t\\t\\tintersectsItem = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t// If we want to trigger on an intersect and we don't have any items\\n\\t\\t\\t\\t// that intersect the position, return nothing\\n\\t\\t\\t\\tif (options.intersect && !intersectsItem) {\\n\\t\\t\\t\\t\\titems = [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn items;\\n\\t\\t\\t},\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * y mode returns the elements that hit-test at the current y coordinate\\n\\t\\t\\t * @function Chart.Interaction.modes.y\\n\\t\\t\\t * @param chart {chart} the chart we are returning items from\\n\\t\\t\\t * @param e {Event} the event we are find things at\\n\\t\\t\\t * @param options {IInteractionOptions} options to use\\n\\t\\t\\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\\n\\t\\t\\t */\\n\\t\\t\\ty: function(chart, e, options) {\\n\\t\\t\\t\\tvar position = getRelativePosition(e, chart.chart);\\n\\t\\t\\t\\tvar items = [];\\n\\t\\t\\t\\tvar intersectsItem = false;\\n\\n\\t\\t\\t\\tparseVisibleItems(chart, function(element) {\\n\\t\\t\\t\\t\\tif (element.inYRange(position.y)) {\\n\\t\\t\\t\\t\\t\\titems.push(element);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (element.inRange(position.x, position.y)) {\\n\\t\\t\\t\\t\\t\\tintersectsItem = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t// If we want to trigger on an intersect and we don't have any items\\n\\t\\t\\t\\t// that intersect the position, return nothing\\n\\t\\t\\t\\tif (options.intersect && !intersectsItem) {\\n\\t\\t\\t\\t\\titems = [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn items;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n};\\n\\n},{}],28:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function() {\\n\\n\\t// Occupy the global variable of Chart, and create a simple base class\\n\\tvar Chart = function(item, config) {\\n\\t\\tthis.controller = new Chart.Controller(item, config, this);\\n\\t\\treturn this.controller;\\n\\t};\\n\\n\\t// Globally expose the defaults to allow for user updating/changing\\n\\tChart.defaults = {\\n\\t\\tglobal: {\\n\\t\\t\\tresponsive: true,\\n\\t\\t\\tresponsiveAnimationDuration: 0,\\n\\t\\t\\tmaintainAspectRatio: true,\\n\\t\\t\\tevents: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],\\n\\t\\t\\thover: {\\n\\t\\t\\t\\tonHover: null,\\n\\t\\t\\t\\tmode: 'nearest',\\n\\t\\t\\t\\tintersect: true,\\n\\t\\t\\t\\tanimationDuration: 400\\n\\t\\t\\t},\\n\\t\\t\\tonClick: null,\\n\\t\\t\\tdefaultColor: 'rgba(0,0,0,0.1)',\\n\\t\\t\\tdefaultFontColor: '#666',\\n\\t\\t\\tdefaultFontFamily: \\\"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\\\",\\n\\t\\t\\tdefaultFontSize: 12,\\n\\t\\t\\tdefaultFontStyle: 'normal',\\n\\t\\t\\tshowLines: true,\\n\\n\\t\\t\\t// Element defaults defined in element extensions\\n\\t\\t\\telements: {},\\n\\n\\t\\t\\t// Legend callback string\\n\\t\\t\\tlegendCallback: function(chart) {\\n\\t\\t\\t\\tvar text = [];\\n\\t\\t\\t\\ttext.push('<ul class=\\\"' + chart.id + '-legend\\\">');\\n\\t\\t\\t\\tfor (var i = 0; i < chart.data.datasets.length; i++) {\\n\\t\\t\\t\\t\\ttext.push('<li><span style=\\\"background-color:' + chart.data.datasets[i].backgroundColor + '\\\"></span>');\\n\\t\\t\\t\\t\\tif (chart.data.datasets[i].label) {\\n\\t\\t\\t\\t\\t\\ttext.push(chart.data.datasets[i].label);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttext.push('</li>');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttext.push('</ul>');\\n\\n\\t\\t\\t\\treturn text.join('');\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tChart.Chart = Chart;\\n\\n\\treturn Chart;\\n};\\n\\n},{}],29:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\t// The layout service is very self explanatory.  It's responsible for the layout within a chart.\\n\\t// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\\n\\t// It is this service's responsibility of carrying out that layout.\\n\\tChart.layoutService = {\\n\\t\\tdefaults: {},\\n\\n\\t\\t// Register a box to a chartInstance. A box is simply a reference to an object that requires layout. eg. Scales, Legend, Plugins.\\n\\t\\taddBox: function(chartInstance, box) {\\n\\t\\t\\tif (!chartInstance.boxes) {\\n\\t\\t\\t\\tchartInstance.boxes = [];\\n\\t\\t\\t}\\n\\t\\t\\tchartInstance.boxes.push(box);\\n\\t\\t},\\n\\n\\t\\tremoveBox: function(chartInstance, box) {\\n\\t\\t\\tif (!chartInstance.boxes) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tchartInstance.boxes.splice(chartInstance.boxes.indexOf(box), 1);\\n\\t\\t},\\n\\n\\t\\t// The most important function\\n\\t\\tupdate: function(chartInstance, width, height) {\\n\\n\\t\\t\\tif (!chartInstance) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar layoutOptions = chartInstance.options.layout;\\n\\t\\t\\tvar padding = layoutOptions ? layoutOptions.padding : null;\\n\\n\\t\\t\\tvar leftPadding = 0;\\n\\t\\t\\tvar rightPadding = 0;\\n\\t\\t\\tvar topPadding = 0;\\n\\t\\t\\tvar bottomPadding = 0;\\n\\n\\t\\t\\tif (!isNaN(padding)) {\\n\\t\\t\\t\\t// options.layout.padding is a number. assign to all\\n\\t\\t\\t\\tleftPadding = padding;\\n\\t\\t\\t\\trightPadding = padding;\\n\\t\\t\\t\\ttopPadding = padding;\\n\\t\\t\\t\\tbottomPadding = padding;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tleftPadding = padding.left || 0;\\n\\t\\t\\t\\trightPadding = padding.right || 0;\\n\\t\\t\\t\\ttopPadding = padding.top || 0;\\n\\t\\t\\t\\tbottomPadding = padding.bottom || 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar leftBoxes = helpers.where(chartInstance.boxes, function(box) {\\n\\t\\t\\t\\treturn box.options.position === 'left';\\n\\t\\t\\t});\\n\\t\\t\\tvar rightBoxes = helpers.where(chartInstance.boxes, function(box) {\\n\\t\\t\\t\\treturn box.options.position === 'right';\\n\\t\\t\\t});\\n\\t\\t\\tvar topBoxes = helpers.where(chartInstance.boxes, function(box) {\\n\\t\\t\\t\\treturn box.options.position === 'top';\\n\\t\\t\\t});\\n\\t\\t\\tvar bottomBoxes = helpers.where(chartInstance.boxes, function(box) {\\n\\t\\t\\t\\treturn box.options.position === 'bottom';\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Boxes that overlay the chartarea such as the radialLinear scale\\n\\t\\t\\tvar chartAreaBoxes = helpers.where(chartInstance.boxes, function(box) {\\n\\t\\t\\t\\treturn box.options.position === 'chartArea';\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Ensure that full width boxes are at the very top / bottom\\n\\t\\t\\ttopBoxes.sort(function(a, b) {\\n\\t\\t\\t\\treturn (b.options.fullWidth ? 1 : 0) - (a.options.fullWidth ? 1 : 0);\\n\\t\\t\\t});\\n\\t\\t\\tbottomBoxes.sort(function(a, b) {\\n\\t\\t\\t\\treturn (a.options.fullWidth ? 1 : 0) - (b.options.fullWidth ? 1 : 0);\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Essentially we now have any number of boxes on each of the 4 sides.\\n\\t\\t\\t// Our canvas looks like the following.\\n\\t\\t\\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\\n\\t\\t\\t// B1 is the bottom axis\\n\\t\\t\\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\\n\\t\\t\\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\\n\\t\\t\\t// an error will be thrown.\\n\\t\\t\\t//\\n\\t\\t\\t// |----------------------------------------------------|\\n\\t\\t\\t// |                  T1 (Full Width)                   |\\n\\t\\t\\t// |----------------------------------------------------|\\n\\t\\t\\t// |    |    |                 T2                  |    |\\n\\t\\t\\t// |    |----|-------------------------------------|----|\\n\\t\\t\\t// |    |    | C1 |                           | C2 |    |\\n\\t\\t\\t// |    |    |----|                           |----|    |\\n\\t\\t\\t// |    |    |                                     |    |\\n\\t\\t\\t// | L1 | L2 |           ChartArea (C0)            | R1 |\\n\\t\\t\\t// |    |    |                                     |    |\\n\\t\\t\\t// |    |    |----|                           |----|    |\\n\\t\\t\\t// |    |    | C3 |                           | C4 |    |\\n\\t\\t\\t// |    |----|-------------------------------------|----|\\n\\t\\t\\t// |    |    |                 B1                  |    |\\n\\t\\t\\t// |----------------------------------------------------|\\n\\t\\t\\t// |                  B2 (Full Width)                   |\\n\\t\\t\\t// |----------------------------------------------------|\\n\\t\\t\\t//\\n\\t\\t\\t// What we do to find the best sizing, we do the following\\n\\t\\t\\t// 1. Determine the minimum size of the chart area.\\n\\t\\t\\t// 2. Split the remaining width equally between each vertical axis\\n\\t\\t\\t// 3. Split the remaining height equally between each horizontal axis\\n\\t\\t\\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\\n\\t\\t\\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\\n\\t\\t\\t// 6. Refit each axis\\n\\t\\t\\t// 7. Position each axis in the final location\\n\\t\\t\\t// 8. Tell the chart the final location of the chart area\\n\\t\\t\\t// 9. Tell any axes that overlay the chart area the positions of the chart area\\n\\n\\t\\t\\t// Step 1\\n\\t\\t\\tvar chartWidth = width - leftPadding - rightPadding;\\n\\t\\t\\tvar chartHeight = height - topPadding - bottomPadding;\\n\\t\\t\\tvar chartAreaWidth = chartWidth / 2; // min 50%\\n\\t\\t\\tvar chartAreaHeight = chartHeight / 2; // min 50%\\n\\n\\t\\t\\t// Step 2\\n\\t\\t\\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\\n\\n\\t\\t\\t// Step 3\\n\\t\\t\\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\\n\\n\\t\\t\\t// Step 4\\n\\t\\t\\tvar maxChartAreaWidth = chartWidth;\\n\\t\\t\\tvar maxChartAreaHeight = chartHeight;\\n\\t\\t\\tvar minBoxSizes = [];\\n\\n\\t\\t\\tfunction getMinimumBoxSize(box) {\\n\\t\\t\\t\\tvar minSize;\\n\\t\\t\\t\\tvar isHorizontal = box.isHorizontal();\\n\\n\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\tminSize = box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\\n\\t\\t\\t\\t\\tmaxChartAreaHeight -= minSize.height;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tminSize = box.update(verticalBoxWidth, chartAreaHeight);\\n\\t\\t\\t\\t\\tmaxChartAreaWidth -= minSize.width;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tminBoxSizes.push({\\n\\t\\t\\t\\t\\thorizontal: isHorizontal,\\n\\t\\t\\t\\t\\tminSize: minSize,\\n\\t\\t\\t\\t\\tbox: box,\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\\n\\n\\t\\t\\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\\n\\t\\t\\tvar maxHorizontalLeftPadding = 0;\\n\\t\\t\\tvar maxHorizontalRightPadding = 0;\\n\\t\\t\\tvar maxVerticalTopPadding = 0;\\n\\t\\t\\tvar maxVerticalBottomPadding = 0;\\n\\n\\t\\t\\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\\n\\t\\t\\t\\tif (horizontalBox.getPadding) {\\n\\t\\t\\t\\t\\tvar boxPadding = horizontalBox.getPadding();\\n\\t\\t\\t\\t\\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\\n\\t\\t\\t\\t\\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\\n\\t\\t\\t\\tif (verticalBox.getPadding) {\\n\\t\\t\\t\\t\\tvar boxPadding = verticalBox.getPadding();\\n\\t\\t\\t\\t\\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\\n\\t\\t\\t\\t\\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\\n\\t\\t\\t// be if the axes are drawn at their minimum sizes.\\n\\t\\t\\t// Steps 5 & 6\\n\\t\\t\\tvar totalLeftBoxesWidth = leftPadding;\\n\\t\\t\\tvar totalRightBoxesWidth = rightPadding;\\n\\t\\t\\tvar totalTopBoxesHeight = topPadding;\\n\\t\\t\\tvar totalBottomBoxesHeight = bottomPadding;\\n\\n\\t\\t\\t// Function to fit a box\\n\\t\\t\\tfunction fitBox(box) {\\n\\t\\t\\t\\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\\n\\t\\t\\t\\t\\treturn minBox.box === box;\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tif (minBoxSize) {\\n\\t\\t\\t\\t\\tif (box.isHorizontal()) {\\n\\t\\t\\t\\t\\t\\tvar scaleMargin = {\\n\\t\\t\\t\\t\\t\\t\\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\\n\\t\\t\\t\\t\\t\\t\\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\\n\\t\\t\\t\\t\\t\\t\\ttop: 0,\\n\\t\\t\\t\\t\\t\\t\\tbottom: 0\\n\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\\n\\t\\t\\t\\t\\t\\t// on the margin. Sometimes they need to increase in size slightly\\n\\t\\t\\t\\t\\t\\tbox.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update, and calculate the left and right margins for the horizontal boxes\\n\\t\\t\\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\\n\\n\\t\\t\\thelpers.each(leftBoxes, function(box) {\\n\\t\\t\\t\\ttotalLeftBoxesWidth += box.width;\\n\\t\\t\\t});\\n\\n\\t\\t\\thelpers.each(rightBoxes, function(box) {\\n\\t\\t\\t\\ttotalRightBoxesWidth += box.width;\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Set the Left and Right margins for the horizontal boxes\\n\\t\\t\\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\\n\\n\\t\\t\\t// Figure out how much margin is on the top and bottom of the vertical boxes\\n\\t\\t\\thelpers.each(topBoxes, function(box) {\\n\\t\\t\\t\\ttotalTopBoxesHeight += box.height;\\n\\t\\t\\t});\\n\\n\\t\\t\\thelpers.each(bottomBoxes, function(box) {\\n\\t\\t\\t\\ttotalBottomBoxesHeight += box.height;\\n\\t\\t\\t});\\n\\n\\t\\t\\tfunction finalFitVerticalBox(box) {\\n\\t\\t\\t\\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\\n\\t\\t\\t\\t\\treturn minSize.box === box;\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tvar scaleMargin = {\\n\\t\\t\\t\\t\\tleft: 0,\\n\\t\\t\\t\\t\\tright: 0,\\n\\t\\t\\t\\t\\ttop: totalTopBoxesHeight,\\n\\t\\t\\t\\t\\tbottom: totalBottomBoxesHeight\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tif (minBoxSize) {\\n\\t\\t\\t\\t\\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Let the left layout know the final margin\\n\\t\\t\\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\\n\\n\\t\\t\\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\\n\\t\\t\\ttotalLeftBoxesWidth = leftPadding;\\n\\t\\t\\ttotalRightBoxesWidth = rightPadding;\\n\\t\\t\\ttotalTopBoxesHeight = topPadding;\\n\\t\\t\\ttotalBottomBoxesHeight = bottomPadding;\\n\\n\\t\\t\\thelpers.each(leftBoxes, function(box) {\\n\\t\\t\\t\\ttotalLeftBoxesWidth += box.width;\\n\\t\\t\\t});\\n\\n\\t\\t\\thelpers.each(rightBoxes, function(box) {\\n\\t\\t\\t\\ttotalRightBoxesWidth += box.width;\\n\\t\\t\\t});\\n\\n\\t\\t\\thelpers.each(topBoxes, function(box) {\\n\\t\\t\\t\\ttotalTopBoxesHeight += box.height;\\n\\t\\t\\t});\\n\\t\\t\\thelpers.each(bottomBoxes, function(box) {\\n\\t\\t\\t\\ttotalBottomBoxesHeight += box.height;\\n\\t\\t\\t});\\n\\n\\t\\t\\t// We may be adding some padding to account for rotated x axis labels\\n\\t\\t\\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\\n\\t\\t\\ttotalLeftBoxesWidth += leftPaddingAddition;\\n\\t\\t\\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\\n\\n\\t\\t\\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\\n\\t\\t\\ttotalTopBoxesHeight += topPaddingAddition;\\n\\t\\t\\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\\n\\n\\t\\t\\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\\n\\t\\t\\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\\n\\t\\t\\t// without calling `fit` again\\n\\t\\t\\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\\n\\t\\t\\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\\n\\n\\t\\t\\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\\n\\t\\t\\t\\thelpers.each(leftBoxes, function(box) {\\n\\t\\t\\t\\t\\tbox.height = newMaxChartAreaHeight;\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\thelpers.each(rightBoxes, function(box) {\\n\\t\\t\\t\\t\\tbox.height = newMaxChartAreaHeight;\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\thelpers.each(topBoxes, function(box) {\\n\\t\\t\\t\\t\\tif (!box.options.fullWidth) {\\n\\t\\t\\t\\t\\t\\tbox.width = newMaxChartAreaWidth;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\thelpers.each(bottomBoxes, function(box) {\\n\\t\\t\\t\\t\\tif (!box.options.fullWidth) {\\n\\t\\t\\t\\t\\t\\tbox.width = newMaxChartAreaWidth;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tmaxChartAreaHeight = newMaxChartAreaHeight;\\n\\t\\t\\t\\tmaxChartAreaWidth = newMaxChartAreaWidth;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Step 7 - Position the boxes\\n\\t\\t\\tvar left = leftPadding + leftPaddingAddition;\\n\\t\\t\\tvar top = topPadding + topPaddingAddition;\\n\\n\\t\\t\\tfunction placeBox(box) {\\n\\t\\t\\t\\tif (box.isHorizontal()) {\\n\\t\\t\\t\\t\\tbox.left = box.options.fullWidth ? leftPadding : totalLeftBoxesWidth;\\n\\t\\t\\t\\t\\tbox.right = box.options.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\\n\\t\\t\\t\\t\\tbox.top = top;\\n\\t\\t\\t\\t\\tbox.bottom = top + box.height;\\n\\n\\t\\t\\t\\t\\t// Move to next point\\n\\t\\t\\t\\t\\ttop = box.bottom;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tbox.left = left;\\n\\t\\t\\t\\t\\tbox.right = left + box.width;\\n\\t\\t\\t\\t\\tbox.top = totalTopBoxesHeight;\\n\\t\\t\\t\\t\\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\\n\\n\\t\\t\\t\\t\\t// Move to next point\\n\\t\\t\\t\\t\\tleft = box.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\\n\\n\\t\\t\\t// Account for chart width and height\\n\\t\\t\\tleft += maxChartAreaWidth;\\n\\t\\t\\ttop += maxChartAreaHeight;\\n\\n\\t\\t\\thelpers.each(rightBoxes, placeBox);\\n\\t\\t\\thelpers.each(bottomBoxes, placeBox);\\n\\n\\t\\t\\t// Step 8\\n\\t\\t\\tchartInstance.chartArea = {\\n\\t\\t\\t\\tleft: totalLeftBoxesWidth,\\n\\t\\t\\t\\ttop: totalTopBoxesHeight,\\n\\t\\t\\t\\tright: totalLeftBoxesWidth + maxChartAreaWidth,\\n\\t\\t\\t\\tbottom: totalTopBoxesHeight + maxChartAreaHeight\\n\\t\\t\\t};\\n\\n\\t\\t\\t// Step 9\\n\\t\\t\\thelpers.each(chartAreaBoxes, function(box) {\\n\\t\\t\\t\\tbox.left = chartInstance.chartArea.left;\\n\\t\\t\\t\\tbox.top = chartInstance.chartArea.top;\\n\\t\\t\\t\\tbox.right = chartInstance.chartArea.right;\\n\\t\\t\\t\\tbox.bottom = chartInstance.chartArea.bottom;\\n\\n\\t\\t\\t\\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n};\\n\\n},{}],30:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\tvar noop = helpers.noop;\\n\\n\\tChart.defaults.global.legend = {\\n\\n\\t\\tdisplay: true,\\n\\t\\tposition: 'top',\\n\\t\\tfullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)\\n\\t\\treverse: false,\\n\\n\\t\\t// a callback that will handle\\n\\t\\tonClick: function(e, legendItem) {\\n\\t\\t\\tvar index = legendItem.datasetIndex;\\n\\t\\t\\tvar ci = this.chart;\\n\\t\\t\\tvar meta = ci.getDatasetMeta(index);\\n\\n\\t\\t\\t// See controller.isDatasetVisible comment\\n\\t\\t\\tmeta.hidden = meta.hidden === null? !ci.data.datasets[index].hidden : null;\\n\\n\\t\\t\\t// We hid a dataset ... rerender the chart\\n\\t\\t\\tci.update();\\n\\t\\t},\\n\\n\\t\\tonHover: null,\\n\\n\\t\\tlabels: {\\n\\t\\t\\tboxWidth: 40,\\n\\t\\t\\tpadding: 10,\\n\\t\\t\\t// Generates labels shown in the legend\\n\\t\\t\\t// Valid properties to return:\\n\\t\\t\\t// text : text to display\\n\\t\\t\\t// fillStyle : fill of coloured box\\n\\t\\t\\t// strokeStyle: stroke of coloured box\\n\\t\\t\\t// hidden : if this legend item refers to a hidden item\\n\\t\\t\\t// lineCap : cap style for line\\n\\t\\t\\t// lineDash\\n\\t\\t\\t// lineDashOffset :\\n\\t\\t\\t// lineJoin :\\n\\t\\t\\t// lineWidth :\\n\\t\\t\\tgenerateLabels: function(chart) {\\n\\t\\t\\t\\tvar data = chart.data;\\n\\t\\t\\t\\treturn helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {\\n\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\ttext: dataset.label,\\n\\t\\t\\t\\t\\t\\tfillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\\n\\t\\t\\t\\t\\t\\thidden: !chart.isDatasetVisible(i),\\n\\t\\t\\t\\t\\t\\tlineCap: dataset.borderCapStyle,\\n\\t\\t\\t\\t\\t\\tlineDash: dataset.borderDash,\\n\\t\\t\\t\\t\\t\\tlineDashOffset: dataset.borderDashOffset,\\n\\t\\t\\t\\t\\t\\tlineJoin: dataset.borderJoinStyle,\\n\\t\\t\\t\\t\\t\\tlineWidth: dataset.borderWidth,\\n\\t\\t\\t\\t\\t\\tstrokeStyle: dataset.borderColor,\\n\\t\\t\\t\\t\\t\\tpointStyle: dataset.pointStyle,\\n\\n\\t\\t\\t\\t\\t\\t// Below is extra data used for toggling the datasets\\n\\t\\t\\t\\t\\t\\tdatasetIndex: i\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}, this) : [];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Helper function to get the box width based on the usePointStyle option\\n\\t * @param labelopts {Object} the label options on the legend\\n\\t * @param fontSize {Number} the label font size\\n\\t * @return {Number} width of the color box area\\n\\t */\\n\\tfunction getBoxWidth(labelOpts, fontSize) {\\n\\t\\treturn labelOpts.usePointStyle ?\\n\\t\\t\\tfontSize * Math.SQRT2 :\\n\\t\\t\\tlabelOpts.boxWidth;\\n\\t}\\n\\n\\tChart.Legend = Chart.Element.extend({\\n\\n\\t\\tinitialize: function(config) {\\n\\t\\t\\thelpers.extend(this, config);\\n\\n\\t\\t\\t// Contains hit boxes for each dataset (in dataset order)\\n\\t\\t\\tthis.legendHitBoxes = [];\\n\\n\\t\\t\\t// Are we in doughnut mode which has a different data type\\n\\t\\t\\tthis.doughnutMode = false;\\n\\t\\t},\\n\\n\\t\\t// These methods are ordered by lifecycle. Utilities then follow.\\n\\t\\t// Any function defined here is inherited by all legend types.\\n\\t\\t// Any function can be extended by the legend type\\n\\n\\t\\tbeforeUpdate: noop,\\n\\t\\tupdate: function(maxWidth, maxHeight, margins) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\\n\\t\\t\\tme.beforeUpdate();\\n\\n\\t\\t\\t// Absorb the master measurements\\n\\t\\t\\tme.maxWidth = maxWidth;\\n\\t\\t\\tme.maxHeight = maxHeight;\\n\\t\\t\\tme.margins = margins;\\n\\n\\t\\t\\t// Dimensions\\n\\t\\t\\tme.beforeSetDimensions();\\n\\t\\t\\tme.setDimensions();\\n\\t\\t\\tme.afterSetDimensions();\\n\\t\\t\\t// Labels\\n\\t\\t\\tme.beforeBuildLabels();\\n\\t\\t\\tme.buildLabels();\\n\\t\\t\\tme.afterBuildLabels();\\n\\n\\t\\t\\t// Fit\\n\\t\\t\\tme.beforeFit();\\n\\t\\t\\tme.fit();\\n\\t\\t\\tme.afterFit();\\n\\t\\t\\t//\\n\\t\\t\\tme.afterUpdate();\\n\\n\\t\\t\\treturn me.minSize;\\n\\t\\t},\\n\\t\\tafterUpdate: noop,\\n\\n\\t\\t//\\n\\n\\t\\tbeforeSetDimensions: noop,\\n\\t\\tsetDimensions: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\t// Set the unconstrained dimension before label rotation\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\t// Reset position before calculating rotation\\n\\t\\t\\t\\tme.width = me.maxWidth;\\n\\t\\t\\t\\tme.left = 0;\\n\\t\\t\\t\\tme.right = me.width;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.height = me.maxHeight;\\n\\n\\t\\t\\t\\t// Reset position before calculating rotation\\n\\t\\t\\t\\tme.top = 0;\\n\\t\\t\\t\\tme.bottom = me.height;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Reset padding\\n\\t\\t\\tme.paddingLeft = 0;\\n\\t\\t\\tme.paddingTop = 0;\\n\\t\\t\\tme.paddingRight = 0;\\n\\t\\t\\tme.paddingBottom = 0;\\n\\n\\t\\t\\t// Reset minSize\\n\\t\\t\\tme.minSize = {\\n\\t\\t\\t\\twidth: 0,\\n\\t\\t\\t\\theight: 0\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tafterSetDimensions: noop,\\n\\n\\t\\t//\\n\\n\\t\\tbeforeBuildLabels: noop,\\n\\t\\tbuildLabels: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar labelOpts = me.options.labels;\\n\\t\\t\\tvar legendItems = labelOpts.generateLabels.call(me, me.chart);\\n\\n\\t\\t\\tif (labelOpts.filter) {\\n\\t\\t\\t\\tlegendItems = legendItems.filter(function(item) {\\n\\t\\t\\t\\t\\treturn labelOpts.filter(item, me.chart.data);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (me.options.reverse) {\\n\\t\\t\\t\\tlegendItems.reverse();\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.legendItems = legendItems;\\n\\t\\t},\\n\\t\\tafterBuildLabels: noop,\\n\\n\\t\\t//\\n\\n\\t\\tbeforeFit: noop,\\n\\t\\tfit: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar labelOpts = opts.labels;\\n\\t\\t\\tvar display = opts.display;\\n\\n\\t\\t\\tvar ctx = me.ctx;\\n\\n\\t\\t\\tvar globalDefault = Chart.defaults.global,\\n\\t\\t\\t\\titemOrDefault = helpers.getValueOrDefault,\\n\\t\\t\\t\\tfontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\\n\\t\\t\\t\\tfontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\\n\\t\\t\\t\\tfontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\\n\\t\\t\\t\\tlabelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\\n\\n\\t\\t\\t// Reset hit boxes\\n\\t\\t\\tvar hitboxes = me.legendHitBoxes = [];\\n\\n\\t\\t\\tvar minSize = me.minSize;\\n\\t\\t\\tvar isHorizontal = me.isHorizontal();\\n\\n\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\tminSize.width = me.maxWidth; // fill all the width\\n\\t\\t\\t\\tminSize.height = display ? 10 : 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tminSize.width = display ? 10 : 0;\\n\\t\\t\\t\\tminSize.height = me.maxHeight; // fill all the height\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Increase sizes here\\n\\t\\t\\tif (display) {\\n\\t\\t\\t\\tctx.font = labelFont;\\n\\n\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\t// Labels\\n\\n\\t\\t\\t\\t\\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\\n\\t\\t\\t\\t\\tvar lineWidths = me.lineWidths = [0];\\n\\t\\t\\t\\t\\tvar totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;\\n\\n\\t\\t\\t\\t\\tctx.textAlign = 'left';\\n\\t\\t\\t\\t\\tctx.textBaseline = 'top';\\n\\n\\t\\t\\t\\t\\thelpers.each(me.legendItems, function(legendItem, i) {\\n\\t\\t\\t\\t\\t\\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\\n\\t\\t\\t\\t\\t\\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\\n\\n\\t\\t\\t\\t\\t\\tif (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\\n\\t\\t\\t\\t\\t\\t\\ttotalHeight += fontSize + (labelOpts.padding);\\n\\t\\t\\t\\t\\t\\t\\tlineWidths[lineWidths.length] = me.left;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Store the hitbox width and height here. Final position will be updated in `draw`\\n\\t\\t\\t\\t\\t\\thitboxes[i] = {\\n\\t\\t\\t\\t\\t\\t\\tleft: 0,\\n\\t\\t\\t\\t\\t\\t\\ttop: 0,\\n\\t\\t\\t\\t\\t\\t\\twidth: width,\\n\\t\\t\\t\\t\\t\\t\\theight: fontSize\\n\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\\n\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\tminSize.height += totalHeight;\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvar vPadding = labelOpts.padding;\\n\\t\\t\\t\\t\\tvar columnWidths = me.columnWidths = [];\\n\\t\\t\\t\\t\\tvar totalWidth = labelOpts.padding;\\n\\t\\t\\t\\t\\tvar currentColWidth = 0;\\n\\t\\t\\t\\t\\tvar currentColHeight = 0;\\n\\t\\t\\t\\t\\tvar itemHeight = fontSize + vPadding;\\n\\n\\t\\t\\t\\t\\thelpers.each(me.legendItems, function(legendItem, i) {\\n\\t\\t\\t\\t\\t\\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\\n\\t\\t\\t\\t\\t\\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\\n\\n\\t\\t\\t\\t\\t\\t// If too tall, go to new column\\n\\t\\t\\t\\t\\t\\tif (currentColHeight + itemHeight > minSize.height) {\\n\\t\\t\\t\\t\\t\\t\\ttotalWidth += currentColWidth + labelOpts.padding;\\n\\t\\t\\t\\t\\t\\t\\tcolumnWidths.push(currentColWidth); // previous column width\\n\\n\\t\\t\\t\\t\\t\\t\\tcurrentColWidth = 0;\\n\\t\\t\\t\\t\\t\\t\\tcurrentColHeight = 0;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Get max width\\n\\t\\t\\t\\t\\t\\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\\n\\t\\t\\t\\t\\t\\tcurrentColHeight += itemHeight;\\n\\n\\t\\t\\t\\t\\t\\t// Store the hitbox width and height here. Final position will be updated in `draw`\\n\\t\\t\\t\\t\\t\\thitboxes[i] = {\\n\\t\\t\\t\\t\\t\\t\\tleft: 0,\\n\\t\\t\\t\\t\\t\\t\\ttop: 0,\\n\\t\\t\\t\\t\\t\\t\\twidth: itemWidth,\\n\\t\\t\\t\\t\\t\\t\\theight: fontSize\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\ttotalWidth += currentColWidth;\\n\\t\\t\\t\\t\\tcolumnWidths.push(currentColWidth);\\n\\t\\t\\t\\t\\tminSize.width += totalWidth;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.width = minSize.width;\\n\\t\\t\\tme.height = minSize.height;\\n\\t\\t},\\n\\t\\tafterFit: noop,\\n\\n\\t\\t// Shared Methods\\n\\t\\tisHorizontal: function() {\\n\\t\\t\\treturn this.options.position === 'top' || this.options.position === 'bottom';\\n\\t\\t},\\n\\n\\t\\t// Actually draw the legend on the canvas\\n\\t\\tdraw: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar labelOpts = opts.labels;\\n\\t\\t\\tvar globalDefault = Chart.defaults.global,\\n\\t\\t\\t\\tlineDefault = globalDefault.elements.line,\\n\\t\\t\\t\\tlegendWidth = me.width,\\n\\t\\t\\t\\tlineWidths = me.lineWidths;\\n\\n\\t\\t\\tif (opts.display) {\\n\\t\\t\\t\\tvar ctx = me.ctx,\\n\\t\\t\\t\\t\\tcursor,\\n\\t\\t\\t\\t\\titemOrDefault = helpers.getValueOrDefault,\\n\\t\\t\\t\\t\\tfontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),\\n\\t\\t\\t\\t\\tfontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\\n\\t\\t\\t\\t\\tfontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\\n\\t\\t\\t\\t\\tfontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\\n\\t\\t\\t\\t\\tlabelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\\n\\n\\t\\t\\t\\t// Canvas setup\\n\\t\\t\\t\\tctx.textAlign = 'left';\\n\\t\\t\\t\\tctx.textBaseline = 'top';\\n\\t\\t\\t\\tctx.lineWidth = 0.5;\\n\\t\\t\\t\\tctx.strokeStyle = fontColor; // for strikethrough effect\\n\\t\\t\\t\\tctx.fillStyle = fontColor; // render in correct colour\\n\\t\\t\\t\\tctx.font = labelFont;\\n\\n\\t\\t\\t\\tvar boxWidth = getBoxWidth(labelOpts, fontSize),\\n\\t\\t\\t\\t\\thitboxes = me.legendHitBoxes;\\n\\n\\t\\t\\t\\t// current position\\n\\t\\t\\t\\tvar drawLegendBox = function(x, y, legendItem) {\\n\\t\\t\\t\\t\\tif (isNaN(boxWidth) || boxWidth <= 0) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Set the ctx for the box\\n\\t\\t\\t\\t\\tctx.save();\\n\\n\\t\\t\\t\\t\\tctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\\n\\t\\t\\t\\t\\tctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\\n\\t\\t\\t\\t\\tctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\\n\\t\\t\\t\\t\\tctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\\n\\t\\t\\t\\t\\tctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\\n\\t\\t\\t\\t\\tctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\\n\\t\\t\\t\\t\\tvar isLineWidthZero = (itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);\\n\\n\\t\\t\\t\\t\\tif (ctx.setLineDash) {\\n\\t\\t\\t\\t\\t\\t// IE 9 and 10 do not support line dash\\n\\t\\t\\t\\t\\t\\tctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (opts.labels && opts.labels.usePointStyle) {\\n\\t\\t\\t\\t\\t\\t// Recalculate x and y for drawPoint() because its expecting\\n\\t\\t\\t\\t\\t\\t// x and y to be center of figure (instead of top left)\\n\\t\\t\\t\\t\\t\\tvar radius = fontSize * Math.SQRT2 / 2;\\n\\t\\t\\t\\t\\t\\tvar offSet = radius / Math.SQRT2;\\n\\t\\t\\t\\t\\t\\tvar centerX = x + offSet;\\n\\t\\t\\t\\t\\t\\tvar centerY = y + offSet;\\n\\n\\t\\t\\t\\t\\t\\t// Draw pointStyle as legend symbol\\n\\t\\t\\t\\t\\t\\tChart.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// Draw box as legend symbol\\n\\t\\t\\t\\t\\t\\tif (!isLineWidthZero) {\\n\\t\\t\\t\\t\\t\\t\\tctx.strokeRect(x, y, boxWidth, fontSize);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tctx.fillRect(x, y, boxWidth, fontSize);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tctx.restore();\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tvar fillText = function(x, y, legendItem, textWidth) {\\n\\t\\t\\t\\t\\tctx.fillText(legendItem.text, boxWidth + (fontSize / 2) + x, y);\\n\\n\\t\\t\\t\\t\\tif (legendItem.hidden) {\\n\\t\\t\\t\\t\\t\\t// Strikethrough the text if hidden\\n\\t\\t\\t\\t\\t\\tctx.beginPath();\\n\\t\\t\\t\\t\\t\\tctx.lineWidth = 2;\\n\\t\\t\\t\\t\\t\\tctx.moveTo(boxWidth + (fontSize / 2) + x, y + (fontSize / 2));\\n\\t\\t\\t\\t\\t\\tctx.lineTo(boxWidth + (fontSize / 2) + x + textWidth, y + (fontSize / 2));\\n\\t\\t\\t\\t\\t\\tctx.stroke();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t// Horizontal\\n\\t\\t\\t\\tvar isHorizontal = me.isHorizontal();\\n\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\tcursor = {\\n\\t\\t\\t\\t\\t\\tx: me.left + ((legendWidth - lineWidths[0]) / 2),\\n\\t\\t\\t\\t\\t\\ty: me.top + labelOpts.padding,\\n\\t\\t\\t\\t\\t\\tline: 0\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcursor = {\\n\\t\\t\\t\\t\\t\\tx: me.left + labelOpts.padding,\\n\\t\\t\\t\\t\\t\\ty: me.top + labelOpts.padding,\\n\\t\\t\\t\\t\\t\\tline: 0\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar itemHeight = fontSize + labelOpts.padding;\\n\\t\\t\\t\\thelpers.each(me.legendItems, function(legendItem, i) {\\n\\t\\t\\t\\t\\tvar textWidth = ctx.measureText(legendItem.text).width,\\n\\t\\t\\t\\t\\t\\twidth = boxWidth + (fontSize / 2) + textWidth,\\n\\t\\t\\t\\t\\t\\tx = cursor.x,\\n\\t\\t\\t\\t\\t\\ty = cursor.y;\\n\\n\\t\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\t\\tif (x + width >= legendWidth) {\\n\\t\\t\\t\\t\\t\\t\\ty = cursor.y += itemHeight;\\n\\t\\t\\t\\t\\t\\t\\tcursor.line++;\\n\\t\\t\\t\\t\\t\\t\\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else if (y + itemHeight > me.bottom) {\\n\\t\\t\\t\\t\\t\\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\\n\\t\\t\\t\\t\\t\\ty = cursor.y = me.top + labelOpts.padding;\\n\\t\\t\\t\\t\\t\\tcursor.line++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tdrawLegendBox(x, y, legendItem);\\n\\n\\t\\t\\t\\t\\thitboxes[i].left = x;\\n\\t\\t\\t\\t\\thitboxes[i].top = y;\\n\\n\\t\\t\\t\\t\\t// Fill the actual label\\n\\t\\t\\t\\t\\tfillText(x, y, legendItem, textWidth);\\n\\n\\t\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\t\\tcursor.x += width + (labelOpts.padding);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcursor.y += itemHeight;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Handle an event\\n\\t\\t * @private\\n\\t\\t * @param {IEvent} event - The event to handle\\n\\t\\t * @return {Boolean} true if a change occured\\n\\t\\t */\\n\\t\\thandleEvent: function(e) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar type = e.type === 'mouseup' ? 'click' : e.type;\\n\\t\\t\\tvar changed = false;\\n\\n\\t\\t\\tif (type === 'mousemove') {\\n\\t\\t\\t\\tif (!opts.onHover) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (type === 'click') {\\n\\t\\t\\t\\tif (!opts.onClick) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Chart event already has relative position in it\\n\\t\\t\\tvar x = e.x,\\n\\t\\t\\t\\ty = e.y;\\n\\n\\t\\t\\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\\n\\t\\t\\t\\t// See if we are touching one of the dataset boxes\\n\\t\\t\\t\\tvar lh = me.legendHitBoxes;\\n\\t\\t\\t\\tfor (var i = 0; i < lh.length; ++i) {\\n\\t\\t\\t\\t\\tvar hitBox = lh[i];\\n\\n\\t\\t\\t\\t\\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\\n\\t\\t\\t\\t\\t\\t// Touching an element\\n\\t\\t\\t\\t\\t\\tif (type === 'click') {\\n\\t\\t\\t\\t\\t\\t\\t// use e.native for backwards compatibility\\n\\t\\t\\t\\t\\t\\t\\topts.onClick.call(me, e.native, me.legendItems[i]);\\n\\t\\t\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t} else if (type === 'mousemove') {\\n\\t\\t\\t\\t\\t\\t\\t// use e.native for backwards compatibility\\n\\t\\t\\t\\t\\t\\t\\topts.onHover.call(me, e.native, me.legendItems[i]);\\n\\t\\t\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn changed;\\n\\t\\t}\\n\\t});\\n\\n\\tfunction createNewLegendAndAttach(chartInstance, legendOpts) {\\n\\t\\tvar legend = new Chart.Legend({\\n\\t\\t\\tctx: chartInstance.chart.ctx,\\n\\t\\t\\toptions: legendOpts,\\n\\t\\t\\tchart: chartInstance\\n\\t\\t});\\n\\t\\tchartInstance.legend = legend;\\n\\t\\tChart.layoutService.addBox(chartInstance, legend);\\n\\t}\\n\\n\\t// Register the legend plugin\\n\\tChart.plugins.register({\\n\\t\\tbeforeInit: function(chartInstance) {\\n\\t\\t\\tvar legendOpts = chartInstance.options.legend;\\n\\n\\t\\t\\tif (legendOpts) {\\n\\t\\t\\t\\tcreateNewLegendAndAttach(chartInstance, legendOpts);\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tbeforeUpdate: function(chartInstance) {\\n\\t\\t\\tvar legendOpts = chartInstance.options.legend;\\n\\n\\t\\t\\tif (legendOpts) {\\n\\t\\t\\t\\tlegendOpts = helpers.configMerge(Chart.defaults.global.legend, legendOpts);\\n\\n\\t\\t\\t\\tif (chartInstance.legend) {\\n\\t\\t\\t\\t\\tchartInstance.legend.options = legendOpts;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcreateNewLegendAndAttach(chartInstance, legendOpts);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tChart.layoutService.removeBox(chartInstance, chartInstance.legend);\\n\\t\\t\\t\\tdelete chartInstance.legend;\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tafterEvent: function(chartInstance, e) {\\n\\t\\t\\tvar legend = chartInstance.legend;\\n\\t\\t\\tif (legend) {\\n\\t\\t\\t\\tlegend.handleEvent(e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],31:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.global.plugins = {};\\n\\n\\t/**\\n\\t * The plugin service singleton\\n\\t * @namespace Chart.plugins\\n\\t * @since 2.1.0\\n\\t */\\n\\tChart.plugins = {\\n\\t\\t/**\\n\\t\\t * Globally registered plugins.\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\t_plugins: [],\\n\\n\\t\\t/**\\n\\t\\t * This identifier is used to invalidate the descriptors cache attached to each chart\\n\\t\\t * when a global plugin is registered or unregistered. In this case, the cache ID is\\n\\t\\t * incremented and descriptors are regenerated during following API calls.\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\t_cacheId: 0,\\n\\n\\t\\t/**\\n\\t\\t * Registers the given plugin(s) if not already registered.\\n\\t\\t * @param {Array|Object} plugins plugin instance(s).\\n\\t\\t */\\n\\t\\tregister: function(plugins) {\\n\\t\\t\\tvar p = this._plugins;\\n\\t\\t\\t([]).concat(plugins).forEach(function(plugin) {\\n\\t\\t\\t\\tif (p.indexOf(plugin) === -1) {\\n\\t\\t\\t\\t\\tp.push(plugin);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tthis._cacheId++;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Unregisters the given plugin(s) only if registered.\\n\\t\\t * @param {Array|Object} plugins plugin instance(s).\\n\\t\\t */\\n\\t\\tunregister: function(plugins) {\\n\\t\\t\\tvar p = this._plugins;\\n\\t\\t\\t([]).concat(plugins).forEach(function(plugin) {\\n\\t\\t\\t\\tvar idx = p.indexOf(plugin);\\n\\t\\t\\t\\tif (idx !== -1) {\\n\\t\\t\\t\\t\\tp.splice(idx, 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tthis._cacheId++;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Remove all registered plugins.\\n\\t\\t * @since 2.1.5\\n\\t\\t */\\n\\t\\tclear: function() {\\n\\t\\t\\tthis._plugins = [];\\n\\t\\t\\tthis._cacheId++;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Returns the number of registered plugins?\\n\\t\\t * @returns {Number}\\n\\t\\t * @since 2.1.5\\n\\t\\t */\\n\\t\\tcount: function() {\\n\\t\\t\\treturn this._plugins.length;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Returns all registered plugin instances.\\n\\t\\t * @returns {Array} array of plugin objects.\\n\\t\\t * @since 2.1.5\\n\\t\\t */\\n\\t\\tgetAll: function() {\\n\\t\\t\\treturn this._plugins;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\\n\\t\\t * This method immediately returns as soon as a plugin explicitly returns false. The\\n\\t\\t * returned value can be used, for instance, to interrupt the current action.\\n\\t\\t * @param {Object} chart - The chart instance for which plugins should be called.\\n\\t\\t * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\\n\\t\\t * @param {Array} [args] - Extra arguments to apply to the hook call.\\n\\t\\t * @returns {Boolean} false if any of the plugins return false, else returns true.\\n\\t\\t */\\n\\t\\tnotify: function(chart, hook, args) {\\n\\t\\t\\tvar descriptors = this.descriptors(chart);\\n\\t\\t\\tvar ilen = descriptors.length;\\n\\t\\t\\tvar i, descriptor, plugin, params, method;\\n\\n\\t\\t\\tfor (i=0; i<ilen; ++i) {\\n\\t\\t\\t\\tdescriptor = descriptors[i];\\n\\t\\t\\t\\tplugin = descriptor.plugin;\\n\\t\\t\\t\\tmethod = plugin[hook];\\n\\t\\t\\t\\tif (typeof method === 'function') {\\n\\t\\t\\t\\t\\tparams = [chart].concat(args || []);\\n\\t\\t\\t\\t\\tparams.push(descriptor.options);\\n\\t\\t\\t\\t\\tif (method.apply(plugin, params) === false) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Returns descriptors of enabled plugins for the given chart.\\n\\t\\t * @returns {Array} [{ plugin, options }]\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tdescriptors: function(chart) {\\n\\t\\t\\tvar cache = chart._plugins || (chart._plugins = {});\\n\\t\\t\\tif (cache.id === this._cacheId) {\\n\\t\\t\\t\\treturn cache.descriptors;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar plugins = [];\\n\\t\\t\\tvar descriptors = [];\\n\\t\\t\\tvar config = (chart && chart.config) || {};\\n\\t\\t\\tvar defaults = Chart.defaults.global.plugins;\\n\\t\\t\\tvar options = (config.options && config.options.plugins) || {};\\n\\n\\t\\t\\tthis._plugins.concat(config.plugins || []).forEach(function(plugin) {\\n\\t\\t\\t\\tvar idx = plugins.indexOf(plugin);\\n\\t\\t\\t\\tif (idx !== -1) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar id = plugin.id;\\n\\t\\t\\t\\tvar opts = options[id];\\n\\t\\t\\t\\tif (opts === false) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (opts === true) {\\n\\t\\t\\t\\t\\topts = helpers.clone(defaults[id]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tplugins.push(plugin);\\n\\t\\t\\t\\tdescriptors.push({\\n\\t\\t\\t\\t\\tplugin: plugin,\\n\\t\\t\\t\\t\\toptions: opts || {}\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\n\\t\\t\\tcache.descriptors = descriptors;\\n\\t\\t\\tcache.id = this._cacheId;\\n\\t\\t\\treturn descriptors;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Plugin extension hooks.\\n\\t * @interface IPlugin\\n\\t * @since 2.1.0\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#beforeInit\\n\\t * @desc Called before initializing `chart`.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#afterInit\\n\\t * @desc Called after `chart` has been initialized and before the first update.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#beforeUpdate\\n\\t * @desc Called before updating `chart`. If any plugin returns `false`, the update\\n\\t * is cancelled (and thus subsequent render(s)) until another `update` is triggered.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t * @returns {Boolean} `false` to cancel the chart update.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#afterUpdate\\n\\t * @desc Called after `chart` has been updated and before rendering. Note that this\\n\\t * hook will not be called if the chart update has been previously cancelled.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#beforeDatasetsUpdate\\n \\t * @desc Called before updating the `chart` datasets. If any plugin returns `false`,\\n\\t * the datasets update is cancelled until another `update` is triggered.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t * @returns {Boolean} false to cancel the datasets update.\\n\\t * @since version 2.1.5\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#afterDatasetsUpdate\\n\\t * @desc Called after the `chart` datasets have been updated. Note that this hook\\n\\t * will not be called if the datasets update has been previously cancelled.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t * @since version 2.1.5\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#beforeLayout\\n\\t * @desc Called before laying out `chart`. If any plugin returns `false`,\\n\\t * the layout update is cancelled until another `update` is triggered.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t * @returns {Boolean} `false` to cancel the chart layout.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#afterLayout\\n\\t * @desc Called after the `chart` has been layed out. Note that this hook will not\\n\\t * be called if the layout update has been previously cancelled.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#beforeRender\\n\\t * @desc Called before rendering `chart`. If any plugin returns `false`,\\n\\t * the rendering is cancelled until another `render` is triggered.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t * @returns {Boolean} `false` to cancel the chart rendering.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#afterRender\\n\\t * @desc Called after the `chart` has been fully rendered (and animation completed). Note\\n\\t * that this hook will not be called if the rendering has been previously cancelled.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#beforeDraw\\n\\t * @desc Called before drawing `chart` at every animation frame specified by the given\\n\\t * easing value. If any plugin returns `false`, the frame drawing is cancelled until\\n\\t * another `render` is triggered.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\\n\\t * @param {Object} options - The plugin options.\\n\\t * @returns {Boolean} `false` to cancel the chart drawing.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#afterDraw\\n\\t * @desc Called after the `chart` has been drawn for the specific easing value. Note\\n\\t * that this hook will not be called if the drawing has been previously cancelled.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#beforeDatasetsDraw\\n \\t * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,\\n\\t * the datasets drawing is cancelled until another `render` is triggered.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\\n\\t * @param {Object} options - The plugin options.\\n\\t * @returns {Boolean} `false` to cancel the chart datasets drawing.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#afterDatasetsDraw\\n\\t * @desc Called after the `chart` datasets have been drawn. Note that this hook\\n\\t * will not be called if the datasets drawing has been previously cancelled.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#beforeEvent\\n \\t * @desc Called before processing the specified `event`. If any plugin returns `false`,\\n\\t * the event will be discarded.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {IEvent} event - The event object.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#afterEvent\\n\\t * @desc Called after the `event` has been consumed. Note that this hook\\n\\t * will not be called if the `event` has been previously discarded.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {IEvent} event - The event object.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#resize\\n\\t * @desc Called after the chart as been resized.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Number} size - The new canvas display size (eq. canvas.style width & height).\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#destroy\\n\\t * @desc Called after the chart as been destroyed.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\n\\t/**\\n\\t * Provided for backward compatibility, use Chart.plugins instead\\n\\t * @namespace Chart.pluginService\\n\\t * @deprecated since version 2.1.5\\n\\t * @todo remove at version 3\\n\\t * @private\\n\\t */\\n\\tChart.pluginService = Chart.plugins;\\n\\n\\t/**\\n\\t * Provided for backward compatibility, inheriting from Chart.PlugingBase has no\\n\\t * effect, instead simply create/register plugins via plain JavaScript objects.\\n\\t * @interface Chart.PluginBase\\n\\t * @deprecated since version 2.5.0\\n\\t * @todo remove at version 3\\n\\t * @private\\n\\t */\\n\\tChart.PluginBase = helpers.inherits({});\\n};\\n\\n},{}],32:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.scale = {\\n\\t\\tdisplay: true,\\n\\t\\tposition: 'left',\\n\\n\\t\\t// grid line settings\\n\\t\\tgridLines: {\\n\\t\\t\\tdisplay: true,\\n\\t\\t\\tcolor: 'rgba(0, 0, 0, 0.1)',\\n\\t\\t\\tlineWidth: 1,\\n\\t\\t\\tdrawBorder: true,\\n\\t\\t\\tdrawOnChartArea: true,\\n\\t\\t\\tdrawTicks: true,\\n\\t\\t\\ttickMarkLength: 10,\\n\\t\\t\\tzeroLineWidth: 1,\\n\\t\\t\\tzeroLineColor: 'rgba(0,0,0,0.25)',\\n\\t\\t\\toffsetGridLines: false,\\n\\t\\t\\tborderDash: [],\\n\\t\\t\\tborderDashOffset: 0.0\\n\\t\\t},\\n\\n\\t\\t// scale label\\n\\t\\tscaleLabel: {\\n\\t\\t\\t// actual label\\n\\t\\t\\tlabelString: '',\\n\\n\\t\\t\\t// display property\\n\\t\\t\\tdisplay: false\\n\\t\\t},\\n\\n\\t\\t// label settings\\n\\t\\tticks: {\\n\\t\\t\\tbeginAtZero: false,\\n\\t\\t\\tminRotation: 0,\\n\\t\\t\\tmaxRotation: 50,\\n\\t\\t\\tmirror: false,\\n\\t\\t\\tpadding: 0,\\n\\t\\t\\treverse: false,\\n\\t\\t\\tdisplay: true,\\n\\t\\t\\tautoSkip: true,\\n\\t\\t\\tautoSkipPadding: 0,\\n\\t\\t\\tlabelOffset: 0,\\n\\t\\t\\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\\n\\t\\t\\tcallback: Chart.Ticks.formatters.values\\n\\t\\t}\\n\\t};\\n\\n\\tfunction computeTextSize(context, tick, font) {\\n\\t\\treturn helpers.isArray(tick) ?\\n\\t\\t\\thelpers.longestText(context, font, tick) :\\n\\t\\t\\tcontext.measureText(tick).width;\\n\\t}\\n\\n\\tfunction parseFontOptions(options) {\\n\\t\\tvar getValueOrDefault = helpers.getValueOrDefault;\\n\\t\\tvar globalDefaults = Chart.defaults.global;\\n\\t\\tvar size = getValueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\\n\\t\\tvar style = getValueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\\n\\t\\tvar family = getValueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\\n\\n\\t\\treturn {\\n\\t\\t\\tsize: size,\\n\\t\\t\\tstyle: style,\\n\\t\\t\\tfamily: family,\\n\\t\\t\\tfont: helpers.fontString(size, style, family)\\n\\t\\t};\\n\\t}\\n\\n\\tChart.Scale = Chart.Element.extend({\\n\\t\\t/**\\n\\t\\t * Get the padding needed for the scale\\n\\t\\t * @method getPadding\\n\\t\\t * @private\\n\\t\\t * @returns {Padding} the necessary padding\\n\\t\\t */\\n\\t\\tgetPadding: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tleft: me.paddingLeft || 0,\\n\\t\\t\\t\\ttop: me.paddingTop || 0,\\n\\t\\t\\t\\tright: me.paddingRight || 0,\\n\\t\\t\\t\\tbottom: me.paddingBottom || 0\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t// These methods are ordered by lifecyle. Utilities then follow.\\n\\t\\t// Any function defined here is inherited by all scale types.\\n\\t\\t// Any function can be extended by the scale type\\n\\n\\t\\tbeforeUpdate: function() {\\n\\t\\t\\thelpers.callCallback(this.options.beforeUpdate, [this]);\\n\\t\\t},\\n\\t\\tupdate: function(maxWidth, maxHeight, margins) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\\n\\t\\t\\tme.beforeUpdate();\\n\\n\\t\\t\\t// Absorb the master measurements\\n\\t\\t\\tme.maxWidth = maxWidth;\\n\\t\\t\\tme.maxHeight = maxHeight;\\n\\t\\t\\tme.margins = helpers.extend({\\n\\t\\t\\t\\tleft: 0,\\n\\t\\t\\t\\tright: 0,\\n\\t\\t\\t\\ttop: 0,\\n\\t\\t\\t\\tbottom: 0\\n\\t\\t\\t}, margins);\\n\\t\\t\\tme.longestTextCache = me.longestTextCache || {};\\n\\n\\t\\t\\t// Dimensions\\n\\t\\t\\tme.beforeSetDimensions();\\n\\t\\t\\tme.setDimensions();\\n\\t\\t\\tme.afterSetDimensions();\\n\\n\\t\\t\\t// Data min/max\\n\\t\\t\\tme.beforeDataLimits();\\n\\t\\t\\tme.determineDataLimits();\\n\\t\\t\\tme.afterDataLimits();\\n\\n\\t\\t\\t// Ticks\\n\\t\\t\\tme.beforeBuildTicks();\\n\\t\\t\\tme.buildTicks();\\n\\t\\t\\tme.afterBuildTicks();\\n\\n\\t\\t\\tme.beforeTickToLabelConversion();\\n\\t\\t\\tme.convertTicksToLabels();\\n\\t\\t\\tme.afterTickToLabelConversion();\\n\\n\\t\\t\\t// Tick Rotation\\n\\t\\t\\tme.beforeCalculateTickRotation();\\n\\t\\t\\tme.calculateTickRotation();\\n\\t\\t\\tme.afterCalculateTickRotation();\\n\\t\\t\\t// Fit\\n\\t\\t\\tme.beforeFit();\\n\\t\\t\\tme.fit();\\n\\t\\t\\tme.afterFit();\\n\\t\\t\\t//\\n\\t\\t\\tme.afterUpdate();\\n\\n\\t\\t\\treturn me.minSize;\\n\\n\\t\\t},\\n\\t\\tafterUpdate: function() {\\n\\t\\t\\thelpers.callCallback(this.options.afterUpdate, [this]);\\n\\t\\t},\\n\\n\\t\\t//\\n\\n\\t\\tbeforeSetDimensions: function() {\\n\\t\\t\\thelpers.callCallback(this.options.beforeSetDimensions, [this]);\\n\\t\\t},\\n\\t\\tsetDimensions: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\t// Set the unconstrained dimension before label rotation\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\t// Reset position before calculating rotation\\n\\t\\t\\t\\tme.width = me.maxWidth;\\n\\t\\t\\t\\tme.left = 0;\\n\\t\\t\\t\\tme.right = me.width;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.height = me.maxHeight;\\n\\n\\t\\t\\t\\t// Reset position before calculating rotation\\n\\t\\t\\t\\tme.top = 0;\\n\\t\\t\\t\\tme.bottom = me.height;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Reset padding\\n\\t\\t\\tme.paddingLeft = 0;\\n\\t\\t\\tme.paddingTop = 0;\\n\\t\\t\\tme.paddingRight = 0;\\n\\t\\t\\tme.paddingBottom = 0;\\n\\t\\t},\\n\\t\\tafterSetDimensions: function() {\\n\\t\\t\\thelpers.callCallback(this.options.afterSetDimensions, [this]);\\n\\t\\t},\\n\\n\\t\\t// Data limits\\n\\t\\tbeforeDataLimits: function() {\\n\\t\\t\\thelpers.callCallback(this.options.beforeDataLimits, [this]);\\n\\t\\t},\\n\\t\\tdetermineDataLimits: helpers.noop,\\n\\t\\tafterDataLimits: function() {\\n\\t\\t\\thelpers.callCallback(this.options.afterDataLimits, [this]);\\n\\t\\t},\\n\\n\\t\\t//\\n\\t\\tbeforeBuildTicks: function() {\\n\\t\\t\\thelpers.callCallback(this.options.beforeBuildTicks, [this]);\\n\\t\\t},\\n\\t\\tbuildTicks: helpers.noop,\\n\\t\\tafterBuildTicks: function() {\\n\\t\\t\\thelpers.callCallback(this.options.afterBuildTicks, [this]);\\n\\t\\t},\\n\\n\\t\\tbeforeTickToLabelConversion: function() {\\n\\t\\t\\thelpers.callCallback(this.options.beforeTickToLabelConversion, [this]);\\n\\t\\t},\\n\\t\\tconvertTicksToLabels: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\t// Convert ticks to strings\\n\\t\\t\\tvar tickOpts = me.options.ticks;\\n\\t\\t\\tme.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback);\\n\\t\\t},\\n\\t\\tafterTickToLabelConversion: function() {\\n\\t\\t\\thelpers.callCallback(this.options.afterTickToLabelConversion, [this]);\\n\\t\\t},\\n\\n\\t\\t//\\n\\n\\t\\tbeforeCalculateTickRotation: function() {\\n\\t\\t\\thelpers.callCallback(this.options.beforeCalculateTickRotation, [this]);\\n\\t\\t},\\n\\t\\tcalculateTickRotation: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar context = me.ctx;\\n\\t\\t\\tvar tickOpts = me.options.ticks;\\n\\n\\t\\t\\t// Get the width of each grid by calculating the difference\\n\\t\\t\\t// between x offsets between 0 and 1.\\n\\t\\t\\tvar tickFont = parseFontOptions(tickOpts);\\n\\t\\t\\tcontext.font = tickFont.font;\\n\\n\\t\\t\\tvar labelRotation = tickOpts.minRotation || 0;\\n\\n\\t\\t\\tif (me.options.display && me.isHorizontal()) {\\n\\t\\t\\t\\tvar originalLabelWidth = helpers.longestText(context, tickFont.font, me.ticks, me.longestTextCache);\\n\\t\\t\\t\\tvar labelWidth = originalLabelWidth;\\n\\t\\t\\t\\tvar cosRotation;\\n\\t\\t\\t\\tvar sinRotation;\\n\\n\\t\\t\\t\\t// Allow 3 pixels x2 padding either side for label readability\\n\\t\\t\\t\\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\\n\\n\\t\\t\\t\\t// Max label rotation can be set or default to 90 - also act as a loop counter\\n\\t\\t\\t\\twhile (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\\n\\t\\t\\t\\t\\tvar angleRadians = helpers.toRadians(labelRotation);\\n\\t\\t\\t\\t\\tcosRotation = Math.cos(angleRadians);\\n\\t\\t\\t\\t\\tsinRotation = Math.sin(angleRadians);\\n\\n\\t\\t\\t\\t\\tif (sinRotation * originalLabelWidth > me.maxHeight) {\\n\\t\\t\\t\\t\\t\\t// go back one step\\n\\t\\t\\t\\t\\t\\tlabelRotation--;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tlabelRotation++;\\n\\t\\t\\t\\t\\tlabelWidth = cosRotation * originalLabelWidth;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.labelRotation = labelRotation;\\n\\t\\t},\\n\\t\\tafterCalculateTickRotation: function() {\\n\\t\\t\\thelpers.callCallback(this.options.afterCalculateTickRotation, [this]);\\n\\t\\t},\\n\\n\\t\\t//\\n\\n\\t\\tbeforeFit: function() {\\n\\t\\t\\thelpers.callCallback(this.options.beforeFit, [this]);\\n\\t\\t},\\n\\t\\tfit: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\t// Reset\\n\\t\\t\\tvar minSize = me.minSize = {\\n\\t\\t\\t\\twidth: 0,\\n\\t\\t\\t\\theight: 0\\n\\t\\t\\t};\\n\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar tickOpts = opts.ticks;\\n\\t\\t\\tvar scaleLabelOpts = opts.scaleLabel;\\n\\t\\t\\tvar gridLineOpts = opts.gridLines;\\n\\t\\t\\tvar display = opts.display;\\n\\t\\t\\tvar isHorizontal = me.isHorizontal();\\n\\n\\t\\t\\tvar tickFont = parseFontOptions(tickOpts);\\n\\t\\t\\tvar scaleLabelFontSize = parseFontOptions(scaleLabelOpts).size * 1.5;\\n\\t\\t\\tvar tickMarkLength = opts.gridLines.tickMarkLength;\\n\\n\\t\\t\\t// Width\\n\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t// subtract the margins to line up with the chartArea if we are a full width scale\\n\\t\\t\\t\\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// height\\n\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tminSize.height = me.maxHeight; // fill all the height\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Are we showing a title for the scale?\\n\\t\\t\\tif (scaleLabelOpts.display && display) {\\n\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\tminSize.height += scaleLabelFontSize;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tminSize.width += scaleLabelFontSize;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Don't bother fitting the ticks if we are not showing them\\n\\t\\t\\tif (tickOpts.display && display) {\\n\\t\\t\\t\\tvar largestTextWidth = helpers.longestText(me.ctx, tickFont.font, me.ticks, me.longestTextCache);\\n\\t\\t\\t\\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);\\n\\t\\t\\t\\tvar lineSpace = tickFont.size * 0.5;\\n\\n\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\t// A horizontal axis is more constrained by the height.\\n\\t\\t\\t\\t\\tme.longestLabelWidth = largestTextWidth;\\n\\n\\t\\t\\t\\t\\tvar angleRadians = helpers.toRadians(me.labelRotation);\\n\\t\\t\\t\\t\\tvar cosRotation = Math.cos(angleRadians);\\n\\t\\t\\t\\t\\tvar sinRotation = Math.sin(angleRadians);\\n\\n\\t\\t\\t\\t\\t// TODO - improve this calculation\\n\\t\\t\\t\\t\\tvar labelHeight = (sinRotation * largestTextWidth)\\n\\t\\t\\t\\t\\t\\t+ (tickFont.size * tallestLabelHeightInLines)\\n\\t\\t\\t\\t\\t\\t+ (lineSpace * tallestLabelHeightInLines);\\n\\n\\t\\t\\t\\t\\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);\\n\\t\\t\\t\\t\\tme.ctx.font = tickFont.font;\\n\\n\\t\\t\\t\\t\\tvar firstTick = me.ticks[0];\\n\\t\\t\\t\\t\\tvar firstLabelWidth = computeTextSize(me.ctx, firstTick, tickFont.font);\\n\\n\\t\\t\\t\\t\\tvar lastTick = me.ticks[me.ticks.length - 1];\\n\\t\\t\\t\\t\\tvar lastLabelWidth = computeTextSize(me.ctx, lastTick, tickFont.font);\\n\\n\\t\\t\\t\\t\\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated\\n\\t\\t\\t\\t\\t// by the font height\\n\\t\\t\\t\\t\\tif (me.labelRotation !== 0) {\\n\\t\\t\\t\\t\\t\\tme.paddingLeft = opts.position === 'bottom'? (cosRotation * firstLabelWidth) + 3: (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges\\n\\t\\t\\t\\t\\t\\tme.paddingRight = opts.position === 'bottom'? (cosRotation * lineSpace) + 3: (cosRotation * lastLabelWidth) + 3;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tme.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\\n\\t\\t\\t\\t\\t\\tme.paddingRight = lastLabelWidth / 2 + 3;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first\\n\\t\\t\\t\\t\\t// Account for padding\\n\\n\\t\\t\\t\\t\\tif (tickOpts.mirror) {\\n\\t\\t\\t\\t\\t\\tlargestTextWidth = 0;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tlargestTextWidth += me.options.ticks.padding;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tminSize.width += largestTextWidth;\\n\\t\\t\\t\\t\\tme.paddingTop = tickFont.size / 2;\\n\\t\\t\\t\\t\\tme.paddingBottom = tickFont.size / 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.handleMargins();\\n\\n\\t\\t\\tme.width = minSize.width;\\n\\t\\t\\tme.height = minSize.height;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Handle margins and padding interactions\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\thandleMargins: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (me.margins) {\\n\\t\\t\\t\\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\\n\\t\\t\\t\\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\\n\\t\\t\\t\\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\\n\\t\\t\\t\\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tafterFit: function() {\\n\\t\\t\\thelpers.callCallback(this.options.afterFit, [this]);\\n\\t\\t},\\n\\n\\t\\t// Shared Methods\\n\\t\\tisHorizontal: function() {\\n\\t\\t\\treturn this.options.position === 'top' || this.options.position === 'bottom';\\n\\t\\t},\\n\\t\\tisFullWidth: function() {\\n\\t\\t\\treturn (this.options.fullWidth);\\n\\t\\t},\\n\\n\\t\\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\\n\\t\\tgetRightValue: function(rawValue) {\\n\\t\\t\\t// Null and undefined values first\\n\\t\\t\\tif (rawValue === null || typeof(rawValue) === 'undefined') {\\n\\t\\t\\t\\treturn NaN;\\n\\t\\t\\t}\\n\\t\\t\\t// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\\n\\t\\t\\tif (typeof(rawValue) === 'number' && !isFinite(rawValue)) {\\n\\t\\t\\t\\treturn NaN;\\n\\t\\t\\t}\\n\\t\\t\\t// If it is in fact an object, dive in one more level\\n\\t\\t\\tif (typeof(rawValue) === 'object') {\\n\\t\\t\\t\\tif ((rawValue instanceof Date) || (rawValue.isValid)) {\\n\\t\\t\\t\\t\\treturn rawValue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this.getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Value is good, return it\\n\\t\\t\\treturn rawValue;\\n\\t\\t},\\n\\n\\t\\t// Used to get the value to display in the tooltip for the data at the given index\\n\\t\\t// function getLabelForIndex(index, datasetIndex)\\n\\t\\tgetLabelForIndex: helpers.noop,\\n\\n\\t\\t// Used to get data value locations.  Value can either be an index or a numerical value\\n\\t\\tgetPixelForValue: helpers.noop,\\n\\n\\t\\t// Used to get the data value from a given pixel. This is the inverse of getPixelForValue\\n\\t\\tgetValueForPixel: helpers.noop,\\n\\n\\t\\t// Used for tick location, should\\n\\t\\tgetPixelForTick: function(index, includeOffset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\\n\\t\\t\\t\\tvar tickWidth = innerWidth / Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\\n\\t\\t\\t\\tvar pixel = (tickWidth * index) + me.paddingLeft;\\n\\n\\t\\t\\t\\tif (includeOffset) {\\n\\t\\t\\t\\t\\tpixel += tickWidth / 2;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar finalVal = me.left + Math.round(pixel);\\n\\t\\t\\t\\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\\n\\t\\t\\t\\treturn finalVal;\\n\\t\\t\\t}\\n\\t\\t\\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\\n\\t\\t\\treturn me.top + (index * (innerHeight / (me.ticks.length - 1)));\\n\\t\\t},\\n\\n\\t\\t// Utility for getting the pixel location of a percentage of scale\\n\\t\\tgetPixelForDecimal: function(decimal /* , includeOffset*/) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\\n\\t\\t\\t\\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;\\n\\n\\t\\t\\t\\tvar finalVal = me.left + Math.round(valueOffset);\\n\\t\\t\\t\\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\\n\\t\\t\\t\\treturn finalVal;\\n\\t\\t\\t}\\n\\t\\t\\treturn me.top + (decimal * me.height);\\n\\t\\t},\\n\\n\\t\\tgetBasePixel: function() {\\n\\t\\t\\treturn this.getPixelForValue(this.getBaseValue());\\n\\t\\t},\\n\\n\\t\\tgetBaseValue: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar min = me.min;\\n\\t\\t\\tvar max = me.max;\\n\\n\\t\\t\\treturn me.beginAtZero ? 0:\\n\\t\\t\\t\\tmin < 0 && max < 0? max :\\n\\t\\t\\t\\tmin > 0 && max > 0? min :\\n\\t\\t\\t\\t0;\\n\\t\\t},\\n\\n\\t\\t// Actually draw the scale on the canvas\\n\\t\\t// @param {rectangle} chartArea : the area of the chart to draw full grid lines on\\n\\t\\tdraw: function(chartArea) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar options = me.options;\\n\\t\\t\\tif (!options.display) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar context = me.ctx;\\n\\t\\t\\tvar globalDefaults = Chart.defaults.global;\\n\\t\\t\\tvar optionTicks = options.ticks;\\n\\t\\t\\tvar gridLines = options.gridLines;\\n\\t\\t\\tvar scaleLabel = options.scaleLabel;\\n\\n\\t\\t\\tvar isRotated = me.labelRotation !== 0;\\n\\t\\t\\tvar skipRatio;\\n\\t\\t\\tvar useAutoskipper = optionTicks.autoSkip;\\n\\t\\t\\tvar isHorizontal = me.isHorizontal();\\n\\n\\t\\t\\t// figure out the maximum number of gridlines to show\\n\\t\\t\\tvar maxTicks;\\n\\t\\t\\tif (optionTicks.maxTicksLimit) {\\n\\t\\t\\t\\tmaxTicks = optionTicks.maxTicksLimit;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\\n\\t\\t\\tvar tickFont = parseFontOptions(optionTicks);\\n\\n\\t\\t\\tvar tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\\n\\t\\t\\tvar borderDash = helpers.getValueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\\n\\t\\t\\tvar borderDashOffset = helpers.getValueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\\n\\n\\t\\t\\tvar scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\\n\\t\\t\\tvar scaleLabelFont = parseFontOptions(scaleLabel);\\n\\n\\t\\t\\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\\n\\t\\t\\tvar cosRotation = Math.cos(labelRotationRadians);\\n\\t\\t\\tvar longestRotatedLabel = me.longestLabelWidth * cosRotation;\\n\\n\\t\\t\\t// Make sure we draw text in the correct color and font\\n\\t\\t\\tcontext.fillStyle = tickFontColor;\\n\\n\\t\\t\\tvar itemsToDraw = [];\\n\\n\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\tskipRatio = false;\\n\\n\\t\\t\\t\\t// Only calculate the skip ratio with the half width of longestRotateLabel if we got an actual rotation\\n\\t\\t\\t\\t// See #2584\\n\\t\\t\\t\\tif (isRotated) {\\n\\t\\t\\t\\t\\tlongestRotatedLabel /= 2;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length > (me.width - (me.paddingLeft + me.paddingRight))) {\\n\\t\\t\\t\\t\\tskipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length) / (me.width - (me.paddingLeft + me.paddingRight)));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if they defined a max number of optionTicks,\\n\\t\\t\\t\\t// increase skipRatio until that number is met\\n\\t\\t\\t\\tif (maxTicks && me.ticks.length > maxTicks) {\\n\\t\\t\\t\\t\\twhile (!skipRatio || me.ticks.length / (skipRatio || 1) > maxTicks) {\\n\\t\\t\\t\\t\\t\\tif (!skipRatio) {\\n\\t\\t\\t\\t\\t\\t\\tskipRatio = 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tskipRatio += 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (!useAutoskipper) {\\n\\t\\t\\t\\t\\tskipRatio = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tvar xTickStart = options.position === 'right' ? me.left : me.right - tl;\\n\\t\\t\\tvar xTickEnd = options.position === 'right' ? me.left + tl : me.right;\\n\\t\\t\\tvar yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;\\n\\t\\t\\tvar yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;\\n\\n\\t\\t\\thelpers.each(me.ticks, function(label, index) {\\n\\t\\t\\t\\t// If the callback returned a null or undefined value, do not draw this line\\n\\t\\t\\t\\tif (label === undefined || label === null) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar isLastTick = me.ticks.length === index + 1;\\n\\n\\t\\t\\t\\t// Since we always show the last tick,we need may need to hide the last shown one before\\n\\t\\t\\t\\tvar shouldSkip = (skipRatio > 1 && index % skipRatio > 0) || (index % skipRatio === 0 && index + skipRatio >= me.ticks.length);\\n\\t\\t\\t\\tif (shouldSkip && !isLastTick || (label === undefined || label === null)) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar lineWidth, lineColor;\\n\\t\\t\\t\\tif (index === (typeof me.zeroLineIndex !== 'undefined' ? me.zeroLineIndex : 0)) {\\n\\t\\t\\t\\t\\t// Draw the first index specially\\n\\t\\t\\t\\t\\tlineWidth = gridLines.zeroLineWidth;\\n\\t\\t\\t\\t\\tlineColor = gridLines.zeroLineColor;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);\\n\\t\\t\\t\\t\\tlineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Common properties\\n\\t\\t\\t\\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\\n\\t\\t\\t\\tvar textAlign = 'middle';\\n\\t\\t\\t\\tvar textBaseline = 'middle';\\n\\n\\t\\t\\t\\tif (isHorizontal) {\\n\\n\\t\\t\\t\\t\\tif (options.position === 'bottom') {\\n\\t\\t\\t\\t\\t\\t// bottom\\n\\t\\t\\t\\t\\t\\ttextBaseline = !isRotated? 'top':'middle';\\n\\t\\t\\t\\t\\t\\ttextAlign = !isRotated? 'center': 'right';\\n\\t\\t\\t\\t\\t\\tlabelY = me.top + tl;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// top\\n\\t\\t\\t\\t\\t\\ttextBaseline = !isRotated? 'bottom':'middle';\\n\\t\\t\\t\\t\\t\\ttextAlign = !isRotated? 'center': 'left';\\n\\t\\t\\t\\t\\t\\tlabelY = me.bottom - tl;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth); // xvalues for grid lines\\n\\t\\t\\t\\t\\tlabelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\\n\\n\\t\\t\\t\\t\\ttx1 = tx2 = x1 = x2 = xLineValue;\\n\\t\\t\\t\\t\\tty1 = yTickStart;\\n\\t\\t\\t\\t\\tty2 = yTickEnd;\\n\\t\\t\\t\\t\\ty1 = chartArea.top;\\n\\t\\t\\t\\t\\ty2 = chartArea.bottom;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvar isLeft = options.position === 'left';\\n\\t\\t\\t\\t\\tvar tickPadding = optionTicks.padding;\\n\\t\\t\\t\\t\\tvar labelXOffset;\\n\\n\\t\\t\\t\\t\\tif (optionTicks.mirror) {\\n\\t\\t\\t\\t\\t\\ttextAlign = isLeft ? 'left' : 'right';\\n\\t\\t\\t\\t\\t\\tlabelXOffset = tickPadding;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\ttextAlign = isLeft ? 'right' : 'left';\\n\\t\\t\\t\\t\\t\\tlabelXOffset = tl + tickPadding;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tlabelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\\n\\n\\t\\t\\t\\t\\tvar yLineValue = me.getPixelForTick(index); // xvalues for grid lines\\n\\t\\t\\t\\t\\tyLineValue += helpers.aliasPixel(lineWidth);\\n\\t\\t\\t\\t\\tlabelY = me.getPixelForTick(index, gridLines.offsetGridLines);\\n\\n\\t\\t\\t\\t\\ttx1 = xTickStart;\\n\\t\\t\\t\\t\\ttx2 = xTickEnd;\\n\\t\\t\\t\\t\\tx1 = chartArea.left;\\n\\t\\t\\t\\t\\tx2 = chartArea.right;\\n\\t\\t\\t\\t\\tty1 = ty2 = y1 = y2 = yLineValue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\titemsToDraw.push({\\n\\t\\t\\t\\t\\ttx1: tx1,\\n\\t\\t\\t\\t\\tty1: ty1,\\n\\t\\t\\t\\t\\ttx2: tx2,\\n\\t\\t\\t\\t\\tty2: ty2,\\n\\t\\t\\t\\t\\tx1: x1,\\n\\t\\t\\t\\t\\ty1: y1,\\n\\t\\t\\t\\t\\tx2: x2,\\n\\t\\t\\t\\t\\ty2: y2,\\n\\t\\t\\t\\t\\tlabelX: labelX,\\n\\t\\t\\t\\t\\tlabelY: labelY,\\n\\t\\t\\t\\t\\tglWidth: lineWidth,\\n\\t\\t\\t\\t\\tglColor: lineColor,\\n\\t\\t\\t\\t\\tglBorderDash: borderDash,\\n\\t\\t\\t\\t\\tglBorderDashOffset: borderDashOffset,\\n\\t\\t\\t\\t\\trotation: -1 * labelRotationRadians,\\n\\t\\t\\t\\t\\tlabel: label,\\n\\t\\t\\t\\t\\ttextBaseline: textBaseline,\\n\\t\\t\\t\\t\\ttextAlign: textAlign\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Draw all of the tick labels, tick marks, and grid lines at the correct places\\n\\t\\t\\thelpers.each(itemsToDraw, function(itemToDraw) {\\n\\t\\t\\t\\tif (gridLines.display) {\\n\\t\\t\\t\\t\\tcontext.save();\\n\\t\\t\\t\\t\\tcontext.lineWidth = itemToDraw.glWidth;\\n\\t\\t\\t\\t\\tcontext.strokeStyle = itemToDraw.glColor;\\n\\t\\t\\t\\t\\tif (context.setLineDash) {\\n\\t\\t\\t\\t\\t\\tcontext.setLineDash(itemToDraw.glBorderDash);\\n\\t\\t\\t\\t\\t\\tcontext.lineDashOffset = itemToDraw.glBorderDashOffset;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcontext.beginPath();\\n\\n\\t\\t\\t\\t\\tif (gridLines.drawTicks) {\\n\\t\\t\\t\\t\\t\\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);\\n\\t\\t\\t\\t\\t\\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (gridLines.drawOnChartArea) {\\n\\t\\t\\t\\t\\t\\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);\\n\\t\\t\\t\\t\\t\\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcontext.stroke();\\n\\t\\t\\t\\t\\tcontext.restore();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (optionTicks.display) {\\n\\t\\t\\t\\t\\tcontext.save();\\n\\t\\t\\t\\t\\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);\\n\\t\\t\\t\\t\\tcontext.rotate(itemToDraw.rotation);\\n\\t\\t\\t\\t\\tcontext.font = tickFont.font;\\n\\t\\t\\t\\t\\tcontext.textBaseline = itemToDraw.textBaseline;\\n\\t\\t\\t\\t\\tcontext.textAlign = itemToDraw.textAlign;\\n\\n\\t\\t\\t\\t\\tvar label = itemToDraw.label;\\n\\t\\t\\t\\t\\tif (helpers.isArray(label)) {\\n\\t\\t\\t\\t\\t\\tfor (var i = 0, y = 0; i < label.length; ++i) {\\n\\t\\t\\t\\t\\t\\t\\t// We just make sure the multiline element is a string here..\\n\\t\\t\\t\\t\\t\\t\\tcontext.fillText('' + label[i], 0, y);\\n\\t\\t\\t\\t\\t\\t\\t// apply same lineSpacing as calculated @ L#320\\n\\t\\t\\t\\t\\t\\t\\ty += (tickFont.size * 1.5);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcontext.fillText(label, 0, 0);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcontext.restore();\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (scaleLabel.display) {\\n\\t\\t\\t\\t// Draw the scale label\\n\\t\\t\\t\\tvar scaleLabelX;\\n\\t\\t\\t\\tvar scaleLabelY;\\n\\t\\t\\t\\tvar rotation = 0;\\n\\n\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\tscaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\\n\\t\\t\\t\\t\\tscaleLabelY = options.position === 'bottom' ? me.bottom - (scaleLabelFont.size / 2) : me.top + (scaleLabelFont.size / 2);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvar isLeft = options.position === 'left';\\n\\t\\t\\t\\t\\tscaleLabelX = isLeft ? me.left + (scaleLabelFont.size / 2) : me.right - (scaleLabelFont.size / 2);\\n\\t\\t\\t\\t\\tscaleLabelY = me.top + ((me.bottom - me.top) / 2);\\n\\t\\t\\t\\t\\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcontext.save();\\n\\t\\t\\t\\tcontext.translate(scaleLabelX, scaleLabelY);\\n\\t\\t\\t\\tcontext.rotate(rotation);\\n\\t\\t\\t\\tcontext.textAlign = 'center';\\n\\t\\t\\t\\tcontext.textBaseline = 'middle';\\n\\t\\t\\t\\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour\\n\\t\\t\\t\\tcontext.font = scaleLabelFont.font;\\n\\t\\t\\t\\tcontext.fillText(scaleLabel.labelString, 0, 0);\\n\\t\\t\\t\\tcontext.restore();\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (gridLines.drawBorder) {\\n\\t\\t\\t\\t// Draw the line at the edge of the axis\\n\\t\\t\\t\\tcontext.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);\\n\\t\\t\\t\\tcontext.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);\\n\\t\\t\\t\\tvar x1 = me.left,\\n\\t\\t\\t\\t\\tx2 = me.right,\\n\\t\\t\\t\\t\\ty1 = me.top,\\n\\t\\t\\t\\t\\ty2 = me.bottom;\\n\\n\\t\\t\\t\\tvar aliasPixel = helpers.aliasPixel(context.lineWidth);\\n\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\ty1 = y2 = options.position === 'top' ? me.bottom : me.top;\\n\\t\\t\\t\\t\\ty1 += aliasPixel;\\n\\t\\t\\t\\t\\ty2 += aliasPixel;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tx1 = x2 = options.position === 'left' ? me.right : me.left;\\n\\t\\t\\t\\t\\tx1 += aliasPixel;\\n\\t\\t\\t\\t\\tx2 += aliasPixel;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcontext.beginPath();\\n\\t\\t\\t\\tcontext.moveTo(x1, y1);\\n\\t\\t\\t\\tcontext.lineTo(x2, y2);\\n\\t\\t\\t\\tcontext.stroke();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],33:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.scaleService = {\\n\\t\\t// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\\n\\t\\t// use the new chart options to grab the correct scale\\n\\t\\tconstructors: {},\\n\\t\\t// Use a registration function so that we can move to an ES6 map when we no longer need to support\\n\\t\\t// old browsers\\n\\n\\t\\t// Scale config defaults\\n\\t\\tdefaults: {},\\n\\t\\tregisterScaleType: function(type, scaleConstructor, defaults) {\\n\\t\\t\\tthis.constructors[type] = scaleConstructor;\\n\\t\\t\\tthis.defaults[type] = helpers.clone(defaults);\\n\\t\\t},\\n\\t\\tgetScaleConstructor: function(type) {\\n\\t\\t\\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\\n\\t\\t},\\n\\t\\tgetScaleDefaults: function(type) {\\n\\t\\t\\t// Return the scale defaults merged with the global settings so that we always use the latest ones\\n\\t\\t\\treturn this.defaults.hasOwnProperty(type) ? helpers.scaleMerge(Chart.defaults.scale, this.defaults[type]) : {};\\n\\t\\t},\\n\\t\\tupdateScaleDefaults: function(type, additions) {\\n\\t\\t\\tvar defaults = this.defaults;\\n\\t\\t\\tif (defaults.hasOwnProperty(type)) {\\n\\t\\t\\t\\tdefaults[type] = helpers.extend(defaults[type], additions);\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\taddScalesToLayout: function(chartInstance) {\\n\\t\\t\\t// Adds each scale to the chart.boxes array to be sized accordingly\\n\\t\\t\\thelpers.each(chartInstance.scales, function(scale) {\\n\\t\\t\\t\\tChart.layoutService.addBox(chartInstance, scale);\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n};\\n\\n},{}],34:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\t/**\\n\\t * Namespace to hold static tick generation functions\\n\\t * @namespace Chart.Ticks\\n\\t */\\n\\tChart.Ticks = {\\n\\t\\t/**\\n\\t\\t * Namespace to hold generators for different types of ticks\\n\\t\\t * @namespace Chart.Ticks.generators\\n\\t\\t */\\n\\t\\tgenerators: {\\n\\t\\t\\t/**\\n\\t\\t\\t * Interface for the options provided to the numeric tick generator\\n\\t\\t\\t * @interface INumericTickGenerationOptions\\n\\t\\t\\t */\\n\\t\\t\\t/**\\n\\t\\t\\t * The maximum number of ticks to display\\n\\t\\t\\t * @name INumericTickGenerationOptions#maxTicks\\n\\t\\t\\t * @type Number\\n\\t\\t\\t */\\n\\t\\t\\t/**\\n\\t\\t\\t * The distance between each tick.\\n\\t\\t\\t * @name INumericTickGenerationOptions#stepSize\\n\\t\\t\\t * @type Number\\n\\t\\t\\t * @optional\\n\\t\\t\\t */\\n\\t\\t\\t/**\\n\\t\\t\\t * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum\\n\\t\\t\\t * @name INumericTickGenerationOptions#min\\n\\t\\t\\t * @type Number\\n\\t\\t\\t * @optional\\n\\t\\t\\t */\\n\\t\\t\\t/**\\n\\t\\t\\t * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum\\n\\t\\t\\t * @name INumericTickGenerationOptions#max\\n\\t\\t\\t * @type Number\\n\\t\\t\\t * @optional\\n\\t\\t\\t */\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * Generate a set of linear ticks\\n\\t\\t\\t * @method Chart.Ticks.generators.linear\\n\\t\\t\\t * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\\n\\t\\t\\t * @param dataRange {IRange} the range of the data\\n\\t\\t\\t * @returns {Array<Number>} array of tick values\\n\\t\\t\\t */\\n\\t\\t\\tlinear: function(generationOptions, dataRange) {\\n\\t\\t\\t\\tvar ticks = [];\\n\\t\\t\\t\\t// To get a \\\"nice\\\" value for the tick spacing, we will use the appropriately named\\n\\t\\t\\t\\t// \\\"nice number\\\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\\n\\t\\t\\t\\t// for details.\\n\\n\\t\\t\\t\\tvar spacing;\\n\\t\\t\\t\\tif (generationOptions.stepSize && generationOptions.stepSize > 0) {\\n\\t\\t\\t\\t\\tspacing = generationOptions.stepSize;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvar niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\\n\\t\\t\\t\\t\\tspacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar niceMin = Math.floor(dataRange.min / spacing) * spacing;\\n\\t\\t\\t\\tvar niceMax = Math.ceil(dataRange.max / spacing) * spacing;\\n\\n\\t\\t\\t\\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\\n\\t\\t\\t\\tif (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\\n\\t\\t\\t\\t\\t// If very close to our whole number, use it.\\n\\t\\t\\t\\t\\tif (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\\n\\t\\t\\t\\t\\t\\tniceMin = generationOptions.min;\\n\\t\\t\\t\\t\\t\\tniceMax = generationOptions.max;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar numSpaces = (niceMax - niceMin) / spacing;\\n\\t\\t\\t\\t// If very close to our rounded value, use it.\\n\\t\\t\\t\\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\\n\\t\\t\\t\\t\\tnumSpaces = Math.round(numSpaces);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnumSpaces = Math.ceil(numSpaces);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Put the values into the ticks array\\n\\t\\t\\t\\tticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\\n\\t\\t\\t\\tfor (var j = 1; j < numSpaces; ++j) {\\n\\t\\t\\t\\t\\tticks.push(niceMin + (j * spacing));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\\n\\n\\t\\t\\t\\treturn ticks;\\n\\t\\t\\t},\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * Generate a set of logarithmic ticks\\n\\t\\t\\t * @method Chart.Ticks.generators.logarithmic\\n\\t\\t\\t * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\\n\\t\\t\\t * @param dataRange {IRange} the range of the data\\n\\t\\t\\t * @returns {Array<Number>} array of tick values\\n\\t\\t\\t */\\n\\t\\t\\tlogarithmic: function(generationOptions, dataRange) {\\n\\t\\t\\t\\tvar ticks = [];\\n\\t\\t\\t\\tvar getValueOrDefault = helpers.getValueOrDefault;\\n\\n\\t\\t\\t\\t// Figure out what the max number of ticks we can support it is based on the size of\\n\\t\\t\\t\\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\\n\\t\\t\\t\\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\\n\\t\\t\\t\\t// the graph\\n\\t\\t\\t\\tvar tickVal = getValueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\\n\\n\\t\\t\\t\\tvar endExp = Math.floor(helpers.log10(dataRange.max));\\n\\t\\t\\t\\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\\n\\t\\t\\t\\tvar exp;\\n\\t\\t\\t\\tvar significand;\\n\\n\\t\\t\\t\\tif (tickVal === 0) {\\n\\t\\t\\t\\t\\texp = Math.floor(helpers.log10(dataRange.minNotZero));\\n\\t\\t\\t\\t\\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\\n\\n\\t\\t\\t\\t\\tticks.push(tickVal);\\n\\t\\t\\t\\t\\ttickVal = significand * Math.pow(10, exp);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\texp = Math.floor(helpers.log10(tickVal));\\n\\t\\t\\t\\t\\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tticks.push(tickVal);\\n\\n\\t\\t\\t\\t\\t++significand;\\n\\t\\t\\t\\t\\tif (significand === 10) {\\n\\t\\t\\t\\t\\t\\tsignificand = 1;\\n\\t\\t\\t\\t\\t\\t++exp;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttickVal = significand * Math.pow(10, exp);\\n\\t\\t\\t\\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\\n\\n\\t\\t\\t\\tvar lastTick = getValueOrDefault(generationOptions.max, tickVal);\\n\\t\\t\\t\\tticks.push(lastTick);\\n\\n\\t\\t\\t\\treturn ticks;\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Namespace to hold formatters for different types of ticks\\n\\t\\t * @namespace Chart.Ticks.formatters\\n\\t\\t */\\n\\t\\tformatters: {\\n\\t\\t\\t/**\\n\\t\\t\\t * Formatter for value labels\\n\\t\\t\\t * @method Chart.Ticks.formatters.values\\n\\t\\t\\t * @param value the value to display\\n\\t\\t\\t * @return {String|Array} the label to display\\n\\t\\t\\t */\\n\\t\\t\\tvalues: function(value) {\\n\\t\\t\\t\\treturn helpers.isArray(value) ? value : '' + value;\\n\\t\\t\\t},\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * Formatter for linear numeric ticks\\n\\t\\t\\t * @method Chart.Ticks.formatters.linear\\n\\t\\t\\t * @param tickValue {Number} the value to be formatted\\n\\t\\t\\t * @param index {Number} the position of the tickValue parameter in the ticks array\\n\\t\\t\\t * @param ticks {Array<Number>} the list of ticks being converted\\n\\t\\t\\t * @return {String} string representation of the tickValue parameter\\n\\t\\t\\t */\\n\\t\\t\\tlinear: function(tickValue, index, ticks) {\\n\\t\\t\\t\\t// If we have lots of ticks, don't use the ones\\n\\t\\t\\t\\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\\n\\n\\t\\t\\t\\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\\n\\t\\t\\t\\tif (Math.abs(delta) > 1) {\\n\\t\\t\\t\\t\\tif (tickValue !== Math.floor(tickValue)) {\\n\\t\\t\\t\\t\\t\\t// not an integer\\n\\t\\t\\t\\t\\t\\tdelta = tickValue - Math.floor(tickValue);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar logDelta = helpers.log10(Math.abs(delta));\\n\\t\\t\\t\\tvar tickString = '';\\n\\n\\t\\t\\t\\tif (tickValue !== 0) {\\n\\t\\t\\t\\t\\tvar numDecimal = -1 * Math.floor(logDelta);\\n\\t\\t\\t\\t\\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\\n\\t\\t\\t\\t\\ttickString = tickValue.toFixed(numDecimal);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttickString = '0'; // never show decimal places for 0\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn tickString;\\n\\t\\t\\t},\\n\\n\\t\\t\\tlogarithmic: function(tickValue, index, ticks) {\\n\\t\\t\\t\\tvar remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));\\n\\n\\t\\t\\t\\tif (tickValue === 0) {\\n\\t\\t\\t\\t\\treturn '0';\\n\\t\\t\\t\\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\\n\\t\\t\\t\\t\\treturn tickValue.toExponential();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn '';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n};\\n\\n},{}],35:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.global.title = {\\n\\t\\tdisplay: false,\\n\\t\\tposition: 'top',\\n\\t\\tfullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)\\n\\n\\t\\tfontStyle: 'bold',\\n\\t\\tpadding: 10,\\n\\n\\t\\t// actual title\\n\\t\\ttext: ''\\n\\t};\\n\\n\\tvar noop = helpers.noop;\\n\\tChart.Title = Chart.Element.extend({\\n\\n\\t\\tinitialize: function(config) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\thelpers.extend(me, config);\\n\\n\\t\\t\\t// Contains hit boxes for each dataset (in dataset order)\\n\\t\\t\\tme.legendHitBoxes = [];\\n\\t\\t},\\n\\n\\t\\t// These methods are ordered by lifecycle. Utilities then follow.\\n\\n\\t\\tbeforeUpdate: noop,\\n\\t\\tupdate: function(maxWidth, maxHeight, margins) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\\n\\t\\t\\tme.beforeUpdate();\\n\\n\\t\\t\\t// Absorb the master measurements\\n\\t\\t\\tme.maxWidth = maxWidth;\\n\\t\\t\\tme.maxHeight = maxHeight;\\n\\t\\t\\tme.margins = margins;\\n\\n\\t\\t\\t// Dimensions\\n\\t\\t\\tme.beforeSetDimensions();\\n\\t\\t\\tme.setDimensions();\\n\\t\\t\\tme.afterSetDimensions();\\n\\t\\t\\t// Labels\\n\\t\\t\\tme.beforeBuildLabels();\\n\\t\\t\\tme.buildLabels();\\n\\t\\t\\tme.afterBuildLabels();\\n\\n\\t\\t\\t// Fit\\n\\t\\t\\tme.beforeFit();\\n\\t\\t\\tme.fit();\\n\\t\\t\\tme.afterFit();\\n\\t\\t\\t//\\n\\t\\t\\tme.afterUpdate();\\n\\n\\t\\t\\treturn me.minSize;\\n\\n\\t\\t},\\n\\t\\tafterUpdate: noop,\\n\\n\\t\\t//\\n\\n\\t\\tbeforeSetDimensions: noop,\\n\\t\\tsetDimensions: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\t// Set the unconstrained dimension before label rotation\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\t// Reset position before calculating rotation\\n\\t\\t\\t\\tme.width = me.maxWidth;\\n\\t\\t\\t\\tme.left = 0;\\n\\t\\t\\t\\tme.right = me.width;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.height = me.maxHeight;\\n\\n\\t\\t\\t\\t// Reset position before calculating rotation\\n\\t\\t\\t\\tme.top = 0;\\n\\t\\t\\t\\tme.bottom = me.height;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Reset padding\\n\\t\\t\\tme.paddingLeft = 0;\\n\\t\\t\\tme.paddingTop = 0;\\n\\t\\t\\tme.paddingRight = 0;\\n\\t\\t\\tme.paddingBottom = 0;\\n\\n\\t\\t\\t// Reset minSize\\n\\t\\t\\tme.minSize = {\\n\\t\\t\\t\\twidth: 0,\\n\\t\\t\\t\\theight: 0\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tafterSetDimensions: noop,\\n\\n\\t\\t//\\n\\n\\t\\tbeforeBuildLabels: noop,\\n\\t\\tbuildLabels: noop,\\n\\t\\tafterBuildLabels: noop,\\n\\n\\t\\t//\\n\\n\\t\\tbeforeFit: noop,\\n\\t\\tfit: function() {\\n\\t\\t\\tvar me = this,\\n\\t\\t\\t\\tvalueOrDefault = helpers.getValueOrDefault,\\n\\t\\t\\t\\topts = me.options,\\n\\t\\t\\t\\tglobalDefaults = Chart.defaults.global,\\n\\t\\t\\t\\tdisplay = opts.display,\\n\\t\\t\\t\\tfontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\\n\\t\\t\\t\\tminSize = me.minSize;\\n\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\tminSize.width = me.maxWidth; // fill all the width\\n\\t\\t\\t\\tminSize.height = display ? fontSize + (opts.padding * 2) : 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tminSize.width = display ? fontSize + (opts.padding * 2) : 0;\\n\\t\\t\\t\\tminSize.height = me.maxHeight; // fill all the height\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.width = minSize.width;\\n\\t\\t\\tme.height = minSize.height;\\n\\n\\t\\t},\\n\\t\\tafterFit: noop,\\n\\n\\t\\t// Shared Methods\\n\\t\\tisHorizontal: function() {\\n\\t\\t\\tvar pos = this.options.position;\\n\\t\\t\\treturn pos === 'top' || pos === 'bottom';\\n\\t\\t},\\n\\n\\t\\t// Actually draw the title block on the canvas\\n\\t\\tdraw: function() {\\n\\t\\t\\tvar me = this,\\n\\t\\t\\t\\tctx = me.ctx,\\n\\t\\t\\t\\tvalueOrDefault = helpers.getValueOrDefault,\\n\\t\\t\\t\\topts = me.options,\\n\\t\\t\\t\\tglobalDefaults = Chart.defaults.global;\\n\\n\\t\\t\\tif (opts.display) {\\n\\t\\t\\t\\tvar fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\\n\\t\\t\\t\\t\\tfontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle),\\n\\t\\t\\t\\t\\tfontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily),\\n\\t\\t\\t\\t\\ttitleFont = helpers.fontString(fontSize, fontStyle, fontFamily),\\n\\t\\t\\t\\t\\trotation = 0,\\n\\t\\t\\t\\t\\ttitleX,\\n\\t\\t\\t\\t\\ttitleY,\\n\\t\\t\\t\\t\\ttop = me.top,\\n\\t\\t\\t\\t\\tleft = me.left,\\n\\t\\t\\t\\t\\tbottom = me.bottom,\\n\\t\\t\\t\\t\\tright = me.right,\\n\\t\\t\\t\\t\\tmaxWidth;\\n\\n\\t\\t\\t\\tctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour\\n\\t\\t\\t\\tctx.font = titleFont;\\n\\n\\t\\t\\t\\t// Horizontal\\n\\t\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\t\\ttitleX = left + ((right - left) / 2); // midpoint of the width\\n\\t\\t\\t\\t\\ttitleY = top + ((bottom - top) / 2); // midpoint of the height\\n\\t\\t\\t\\t\\tmaxWidth = right - left;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttitleX = opts.position === 'left' ? left + (fontSize / 2) : right - (fontSize / 2);\\n\\t\\t\\t\\t\\ttitleY = top + ((bottom - top) / 2);\\n\\t\\t\\t\\t\\tmaxWidth = bottom - top;\\n\\t\\t\\t\\t\\trotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tctx.save();\\n\\t\\t\\t\\tctx.translate(titleX, titleY);\\n\\t\\t\\t\\tctx.rotate(rotation);\\n\\t\\t\\t\\tctx.textAlign = 'center';\\n\\t\\t\\t\\tctx.textBaseline = 'middle';\\n\\t\\t\\t\\tctx.fillText(opts.text, 0, 0, maxWidth);\\n\\t\\t\\t\\tctx.restore();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n\\n\\tfunction createNewTitleBlockAndAttach(chartInstance, titleOpts) {\\n\\t\\tvar title = new Chart.Title({\\n\\t\\t\\tctx: chartInstance.chart.ctx,\\n\\t\\t\\toptions: titleOpts,\\n\\t\\t\\tchart: chartInstance\\n\\t\\t});\\n\\t\\tchartInstance.titleBlock = title;\\n\\t\\tChart.layoutService.addBox(chartInstance, title);\\n\\t}\\n\\n\\t// Register the title plugin\\n\\tChart.plugins.register({\\n\\t\\tbeforeInit: function(chartInstance) {\\n\\t\\t\\tvar titleOpts = chartInstance.options.title;\\n\\n\\t\\t\\tif (titleOpts) {\\n\\t\\t\\t\\tcreateNewTitleBlockAndAttach(chartInstance, titleOpts);\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tbeforeUpdate: function(chartInstance) {\\n\\t\\t\\tvar titleOpts = chartInstance.options.title;\\n\\n\\t\\t\\tif (titleOpts) {\\n\\t\\t\\t\\ttitleOpts = helpers.configMerge(Chart.defaults.global.title, titleOpts);\\n\\n\\t\\t\\t\\tif (chartInstance.titleBlock) {\\n\\t\\t\\t\\t\\tchartInstance.titleBlock.options = titleOpts;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcreateNewTitleBlockAndAttach(chartInstance, titleOpts);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tChart.layoutService.removeBox(chartInstance, chartInstance.titleBlock);\\n\\t\\t\\t\\tdelete chartInstance.titleBlock;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],36:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\t/**\\n \\t * Helper method to merge the opacity into a color\\n \\t */\\n\\tfunction mergeOpacity(colorString, opacity) {\\n\\t\\tvar color = helpers.color(colorString);\\n\\t\\treturn color.alpha(opacity * color.alpha()).rgbaString();\\n\\t}\\n\\n\\tChart.defaults.global.tooltips = {\\n\\t\\tenabled: true,\\n\\t\\tcustom: null,\\n\\t\\tmode: 'nearest',\\n\\t\\tposition: 'average',\\n\\t\\tintersect: true,\\n\\t\\tbackgroundColor: 'rgba(0,0,0,0.8)',\\n\\t\\ttitleFontStyle: 'bold',\\n\\t\\ttitleSpacing: 2,\\n\\t\\ttitleMarginBottom: 6,\\n\\t\\ttitleFontColor: '#fff',\\n\\t\\ttitleAlign: 'left',\\n\\t\\tbodySpacing: 2,\\n\\t\\tbodyFontColor: '#fff',\\n\\t\\tbodyAlign: 'left',\\n\\t\\tfooterFontStyle: 'bold',\\n\\t\\tfooterSpacing: 2,\\n\\t\\tfooterMarginTop: 6,\\n\\t\\tfooterFontColor: '#fff',\\n\\t\\tfooterAlign: 'left',\\n\\t\\tyPadding: 6,\\n\\t\\txPadding: 6,\\n\\t\\tcaretSize: 5,\\n\\t\\tcornerRadius: 6,\\n\\t\\tmultiKeyBackground: '#fff',\\n\\t\\tdisplayColors: true,\\n\\t\\tcallbacks: {\\n\\t\\t\\t// Args are: (tooltipItems, data)\\n\\t\\t\\tbeforeTitle: helpers.noop,\\n\\t\\t\\ttitle: function(tooltipItems, data) {\\n\\t\\t\\t\\t// Pick first xLabel for now\\n\\t\\t\\t\\tvar title = '';\\n\\t\\t\\t\\tvar labels = data.labels;\\n\\t\\t\\t\\tvar labelCount = labels ? labels.length : 0;\\n\\n\\t\\t\\t\\tif (tooltipItems.length > 0) {\\n\\t\\t\\t\\t\\tvar item = tooltipItems[0];\\n\\n\\t\\t\\t\\t\\tif (item.xLabel) {\\n\\t\\t\\t\\t\\t\\ttitle = item.xLabel;\\n\\t\\t\\t\\t\\t} else if (labelCount > 0 && item.index < labelCount) {\\n\\t\\t\\t\\t\\t\\ttitle = labels[item.index];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn title;\\n\\t\\t\\t},\\n\\t\\t\\tafterTitle: helpers.noop,\\n\\n\\t\\t\\t// Args are: (tooltipItems, data)\\n\\t\\t\\tbeforeBody: helpers.noop,\\n\\n\\t\\t\\t// Args are: (tooltipItem, data)\\n\\t\\t\\tbeforeLabel: helpers.noop,\\n\\t\\t\\tlabel: function(tooltipItem, data) {\\n\\t\\t\\t\\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\\n\\t\\t\\t\\treturn datasetLabel + ': ' + tooltipItem.yLabel;\\n\\t\\t\\t},\\n\\t\\t\\tlabelColor: function(tooltipItem, chartInstance) {\\n\\t\\t\\t\\tvar meta = chartInstance.getDatasetMeta(tooltipItem.datasetIndex);\\n\\t\\t\\t\\tvar activeElement = meta.data[tooltipItem.index];\\n\\t\\t\\t\\tvar view = activeElement._view;\\n\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\tborderColor: view.borderColor,\\n\\t\\t\\t\\t\\tbackgroundColor: view.backgroundColor\\n\\t\\t\\t\\t};\\n\\t\\t\\t},\\n\\t\\t\\tafterLabel: helpers.noop,\\n\\n\\t\\t\\t// Args are: (tooltipItems, data)\\n\\t\\t\\tafterBody: helpers.noop,\\n\\n\\t\\t\\t// Args are: (tooltipItems, data)\\n\\t\\t\\tbeforeFooter: helpers.noop,\\n\\t\\t\\tfooter: helpers.noop,\\n\\t\\t\\tafterFooter: helpers.noop\\n\\t\\t}\\n\\t};\\n\\n\\t// Helper to push or concat based on if the 2nd parameter is an array or not\\n\\tfunction pushOrConcat(base, toPush) {\\n\\t\\tif (toPush) {\\n\\t\\t\\tif (helpers.isArray(toPush)) {\\n\\t\\t\\t\\t// base = base.concat(toPush);\\n\\t\\t\\t\\tArray.prototype.push.apply(base, toPush);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbase.push(toPush);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn base;\\n\\t}\\n\\n\\t// Private helper to create a tooltip item model\\n\\t// @param element : the chart element (point, arc, bar) to create the tooltip item for\\n\\t// @return : new tooltip item\\n\\tfunction createTooltipItem(element) {\\n\\t\\tvar xScale = element._xScale;\\n\\t\\tvar yScale = element._yScale || element._scale; // handle radar || polarArea charts\\n\\t\\tvar index = element._index,\\n\\t\\t\\tdatasetIndex = element._datasetIndex;\\n\\n\\t\\treturn {\\n\\t\\t\\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\\n\\t\\t\\tyLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\\n\\t\\t\\tindex: index,\\n\\t\\t\\tdatasetIndex: datasetIndex,\\n\\t\\t\\tx: element._model.x,\\n\\t\\t\\ty: element._model.y\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Helper to get the reset model for the tooltip\\n\\t * @param tooltipOpts {Object} the tooltip options\\n\\t */\\n\\tfunction getBaseModel(tooltipOpts) {\\n\\t\\tvar globalDefaults = Chart.defaults.global;\\n\\t\\tvar getValueOrDefault = helpers.getValueOrDefault;\\n\\n\\t\\treturn {\\n\\t\\t\\t// Positioning\\n\\t\\t\\txPadding: tooltipOpts.xPadding,\\n\\t\\t\\tyPadding: tooltipOpts.yPadding,\\n\\t\\t\\txAlign: tooltipOpts.xAlign,\\n\\t\\t\\tyAlign: tooltipOpts.yAlign,\\n\\n\\t\\t\\t// Body\\n\\t\\t\\tbodyFontColor: tooltipOpts.bodyFontColor,\\n\\t\\t\\t_bodyFontFamily: getValueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\\n\\t\\t\\t_bodyFontStyle: getValueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\\n\\t\\t\\t_bodyAlign: tooltipOpts.bodyAlign,\\n\\t\\t\\tbodyFontSize: getValueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\\n\\t\\t\\tbodySpacing: tooltipOpts.bodySpacing,\\n\\n\\t\\t\\t// Title\\n\\t\\t\\ttitleFontColor: tooltipOpts.titleFontColor,\\n\\t\\t\\t_titleFontFamily: getValueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\\n\\t\\t\\t_titleFontStyle: getValueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\\n\\t\\t\\ttitleFontSize: getValueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\\n\\t\\t\\t_titleAlign: tooltipOpts.titleAlign,\\n\\t\\t\\ttitleSpacing: tooltipOpts.titleSpacing,\\n\\t\\t\\ttitleMarginBottom: tooltipOpts.titleMarginBottom,\\n\\n\\t\\t\\t// Footer\\n\\t\\t\\tfooterFontColor: tooltipOpts.footerFontColor,\\n\\t\\t\\t_footerFontFamily: getValueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\\n\\t\\t\\t_footerFontStyle: getValueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\\n\\t\\t\\tfooterFontSize: getValueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\\n\\t\\t\\t_footerAlign: tooltipOpts.footerAlign,\\n\\t\\t\\tfooterSpacing: tooltipOpts.footerSpacing,\\n\\t\\t\\tfooterMarginTop: tooltipOpts.footerMarginTop,\\n\\n\\t\\t\\t// Appearance\\n\\t\\t\\tcaretSize: tooltipOpts.caretSize,\\n\\t\\t\\tcornerRadius: tooltipOpts.cornerRadius,\\n\\t\\t\\tbackgroundColor: tooltipOpts.backgroundColor,\\n\\t\\t\\topacity: 0,\\n\\t\\t\\tlegendColorBackground: tooltipOpts.multiKeyBackground,\\n\\t\\t\\tdisplayColors: tooltipOpts.displayColors\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Get the size of the tooltip\\n\\t */\\n\\tfunction getTooltipSize(tooltip, model) {\\n\\t\\tvar ctx = tooltip._chart.ctx;\\n\\n\\t\\tvar height = model.yPadding * 2; // Tooltip Padding\\n\\t\\tvar width = 0;\\n\\n\\t\\t// Count of all lines in the body\\n\\t\\tvar body = model.body;\\n\\t\\tvar combinedBodyLength = body.reduce(function(count, bodyItem) {\\n\\t\\t\\treturn count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\\n\\t\\t}, 0);\\n\\t\\tcombinedBodyLength += model.beforeBody.length + model.afterBody.length;\\n\\n\\t\\tvar titleLineCount = model.title.length;\\n\\t\\tvar footerLineCount = model.footer.length;\\n\\t\\tvar titleFontSize = model.titleFontSize,\\n\\t\\t\\tbodyFontSize = model.bodyFontSize,\\n\\t\\t\\tfooterFontSize = model.footerFontSize;\\n\\n\\t\\theight += titleLineCount * titleFontSize; // Title Lines\\n\\t\\theight += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\\n\\t\\theight += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\\n\\t\\theight += combinedBodyLength * bodyFontSize; // Body Lines\\n\\t\\theight += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\\n\\t\\theight += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\\n\\t\\theight += footerLineCount * (footerFontSize); // Footer Lines\\n\\t\\theight += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\\n\\n\\t\\t// Title width\\n\\t\\tvar widthPadding = 0;\\n\\t\\tvar maxLineWidth = function(line) {\\n\\t\\t\\twidth = Math.max(width, ctx.measureText(line).width + widthPadding);\\n\\t\\t};\\n\\n\\t\\tctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\\n\\t\\thelpers.each(model.title, maxLineWidth);\\n\\n\\t\\t// Body width\\n\\t\\tctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\\n\\t\\thelpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);\\n\\n\\t\\t// Body lines may include some extra width due to the color box\\n\\t\\twidthPadding = model.displayColors ? (bodyFontSize + 2) : 0;\\n\\t\\thelpers.each(body, function(bodyItem) {\\n\\t\\t\\thelpers.each(bodyItem.before, maxLineWidth);\\n\\t\\t\\thelpers.each(bodyItem.lines, maxLineWidth);\\n\\t\\t\\thelpers.each(bodyItem.after, maxLineWidth);\\n\\t\\t});\\n\\n\\t\\t// Reset back to 0\\n\\t\\twidthPadding = 0;\\n\\n\\t\\t// Footer width\\n\\t\\tctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\\n\\t\\thelpers.each(model.footer, maxLineWidth);\\n\\n\\t\\t// Add padding\\n\\t\\twidth += 2 * model.xPadding;\\n\\n\\t\\treturn {\\n\\t\\t\\twidth: width,\\n\\t\\t\\theight: height\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Helper to get the alignment of a tooltip given the size\\n\\t */\\n\\tfunction determineAlignment(tooltip, size) {\\n\\t\\tvar model = tooltip._model;\\n\\t\\tvar chart = tooltip._chart;\\n\\t\\tvar chartArea = tooltip._chartInstance.chartArea;\\n\\t\\tvar xAlign = 'center';\\n\\t\\tvar yAlign = 'center';\\n\\n\\t\\tif (model.y < size.height) {\\n\\t\\t\\tyAlign = 'top';\\n\\t\\t} else if (model.y > (chart.height - size.height)) {\\n\\t\\t\\tyAlign = 'bottom';\\n\\t\\t}\\n\\n\\t\\tvar lf, rf; // functions to determine left, right alignment\\n\\t\\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\\n\\t\\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\\n\\t\\tvar midX = (chartArea.left + chartArea.right) / 2;\\n\\t\\tvar midY = (chartArea.top + chartArea.bottom) / 2;\\n\\n\\t\\tif (yAlign === 'center') {\\n\\t\\t\\tlf = function(x) {\\n\\t\\t\\t\\treturn x <= midX;\\n\\t\\t\\t};\\n\\t\\t\\trf = function(x) {\\n\\t\\t\\t\\treturn x > midX;\\n\\t\\t\\t};\\n\\t\\t} else {\\n\\t\\t\\tlf = function(x) {\\n\\t\\t\\t\\treturn x <= (size.width / 2);\\n\\t\\t\\t};\\n\\t\\t\\trf = function(x) {\\n\\t\\t\\t\\treturn x >= (chart.width - (size.width / 2));\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\tolf = function(x) {\\n\\t\\t\\treturn x + size.width > chart.width;\\n\\t\\t};\\n\\t\\torf = function(x) {\\n\\t\\t\\treturn x - size.width < 0;\\n\\t\\t};\\n\\t\\tyf = function(y) {\\n\\t\\t\\treturn y <= midY ? 'top' : 'bottom';\\n\\t\\t};\\n\\n\\t\\tif (lf(model.x)) {\\n\\t\\t\\txAlign = 'left';\\n\\n\\t\\t\\t// Is tooltip too wide and goes over the right side of the chart.?\\n\\t\\t\\tif (olf(model.x)) {\\n\\t\\t\\t\\txAlign = 'center';\\n\\t\\t\\t\\tyAlign = yf(model.y);\\n\\t\\t\\t}\\n\\t\\t} else if (rf(model.x)) {\\n\\t\\t\\txAlign = 'right';\\n\\n\\t\\t\\t// Is tooltip too wide and goes outside left edge of canvas?\\n\\t\\t\\tif (orf(model.x)) {\\n\\t\\t\\t\\txAlign = 'center';\\n\\t\\t\\t\\tyAlign = yf(model.y);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvar opts = tooltip._options;\\n\\t\\treturn {\\n\\t\\t\\txAlign: opts.xAlign ? opts.xAlign : xAlign,\\n\\t\\t\\tyAlign: opts.yAlign ? opts.yAlign : yAlign\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\\n\\t */\\n\\tfunction getBackgroundPoint(vm, size, alignment) {\\n\\t\\t// Background Position\\n\\t\\tvar x = vm.x;\\n\\t\\tvar y = vm.y;\\n\\n\\t\\tvar caretSize = vm.caretSize,\\n\\t\\t\\tcaretPadding = vm.caretPadding,\\n\\t\\t\\tcornerRadius = vm.cornerRadius,\\n\\t\\t\\txAlign = alignment.xAlign,\\n\\t\\t\\tyAlign = alignment.yAlign,\\n\\t\\t\\tpaddingAndSize = caretSize + caretPadding,\\n\\t\\t\\tradiusAndPadding = cornerRadius + caretPadding;\\n\\n\\t\\tif (xAlign === 'right') {\\n\\t\\t\\tx -= size.width;\\n\\t\\t} else if (xAlign === 'center') {\\n\\t\\t\\tx -= (size.width / 2);\\n\\t\\t}\\n\\n\\t\\tif (yAlign === 'top') {\\n\\t\\t\\ty += paddingAndSize;\\n\\t\\t} else if (yAlign === 'bottom') {\\n\\t\\t\\ty -= size.height + paddingAndSize;\\n\\t\\t} else {\\n\\t\\t\\ty -= (size.height / 2);\\n\\t\\t}\\n\\n\\t\\tif (yAlign === 'center') {\\n\\t\\t\\tif (xAlign === 'left') {\\n\\t\\t\\t\\tx += paddingAndSize;\\n\\t\\t\\t} else if (xAlign === 'right') {\\n\\t\\t\\t\\tx -= paddingAndSize;\\n\\t\\t\\t}\\n\\t\\t} else if (xAlign === 'left') {\\n\\t\\t\\tx -= radiusAndPadding;\\n\\t\\t} else if (xAlign === 'right') {\\n\\t\\t\\tx += radiusAndPadding;\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tx: x,\\n\\t\\t\\ty: y\\n\\t\\t};\\n\\t}\\n\\n\\tChart.Tooltip = Chart.Element.extend({\\n\\t\\tinitialize: function() {\\n\\t\\t\\tthis._model = getBaseModel(this._options);\\n\\t\\t},\\n\\n\\t\\t// Get the title\\n\\t\\t// Args are: (tooltipItem, data)\\n\\t\\tgetTitle: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me._options;\\n\\t\\t\\tvar callbacks = opts.callbacks;\\n\\n\\t\\t\\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments),\\n\\t\\t\\t\\ttitle = callbacks.title.apply(me, arguments),\\n\\t\\t\\t\\tafterTitle = callbacks.afterTitle.apply(me, arguments);\\n\\n\\t\\t\\tvar lines = [];\\n\\t\\t\\tlines = pushOrConcat(lines, beforeTitle);\\n\\t\\t\\tlines = pushOrConcat(lines, title);\\n\\t\\t\\tlines = pushOrConcat(lines, afterTitle);\\n\\n\\t\\t\\treturn lines;\\n\\t\\t},\\n\\n\\t\\t// Args are: (tooltipItem, data)\\n\\t\\tgetBeforeBody: function() {\\n\\t\\t\\tvar lines = this._options.callbacks.beforeBody.apply(this, arguments);\\n\\t\\t\\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\\n\\t\\t},\\n\\n\\t\\t// Args are: (tooltipItem, data)\\n\\t\\tgetBody: function(tooltipItems, data) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar callbacks = me._options.callbacks;\\n\\t\\t\\tvar bodyItems = [];\\n\\n\\t\\t\\thelpers.each(tooltipItems, function(tooltipItem) {\\n\\t\\t\\t\\tvar bodyItem = {\\n\\t\\t\\t\\t\\tbefore: [],\\n\\t\\t\\t\\t\\tlines: [],\\n\\t\\t\\t\\t\\tafter: []\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tpushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));\\n\\t\\t\\t\\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\\n\\t\\t\\t\\tpushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));\\n\\n\\t\\t\\t\\tbodyItems.push(bodyItem);\\n\\t\\t\\t});\\n\\n\\t\\t\\treturn bodyItems;\\n\\t\\t},\\n\\n\\t\\t// Args are: (tooltipItem, data)\\n\\t\\tgetAfterBody: function() {\\n\\t\\t\\tvar lines = this._options.callbacks.afterBody.apply(this, arguments);\\n\\t\\t\\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\\n\\t\\t},\\n\\n\\t\\t// Get the footer and beforeFooter and afterFooter lines\\n\\t\\t// Args are: (tooltipItem, data)\\n\\t\\tgetFooter: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar callbacks = me._options.callbacks;\\n\\n\\t\\t\\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\\n\\t\\t\\tvar footer = callbacks.footer.apply(me, arguments);\\n\\t\\t\\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\\n\\n\\t\\t\\tvar lines = [];\\n\\t\\t\\tlines = pushOrConcat(lines, beforeFooter);\\n\\t\\t\\tlines = pushOrConcat(lines, footer);\\n\\t\\t\\tlines = pushOrConcat(lines, afterFooter);\\n\\n\\t\\t\\treturn lines;\\n\\t\\t},\\n\\n\\t\\tupdate: function(changed) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me._options;\\n\\n\\t\\t\\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\\n\\t\\t\\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\\n\\t\\t\\t// which breaks any animations.\\n\\t\\t\\tvar existingModel = me._model;\\n\\t\\t\\tvar model = me._model = getBaseModel(opts);\\n\\t\\t\\tvar active = me._active;\\n\\n\\t\\t\\tvar data = me._data;\\n\\t\\t\\tvar chartInstance = me._chartInstance;\\n\\n\\t\\t\\t// In the case where active.length === 0 we need to keep these at existing values for good animations\\n\\t\\t\\tvar alignment = {\\n\\t\\t\\t\\txAlign: existingModel.xAlign,\\n\\t\\t\\t\\tyAlign: existingModel.yAlign\\n\\t\\t\\t};\\n\\t\\t\\tvar backgroundPoint = {\\n\\t\\t\\t\\tx: existingModel.x,\\n\\t\\t\\t\\ty: existingModel.y\\n\\t\\t\\t};\\n\\t\\t\\tvar tooltipSize = {\\n\\t\\t\\t\\twidth: existingModel.width,\\n\\t\\t\\t\\theight: existingModel.height\\n\\t\\t\\t};\\n\\t\\t\\tvar tooltipPosition = {\\n\\t\\t\\t\\tx: existingModel.caretX,\\n\\t\\t\\t\\ty: existingModel.caretY\\n\\t\\t\\t};\\n\\n\\t\\t\\tvar i, len;\\n\\n\\t\\t\\tif (active.length) {\\n\\t\\t\\t\\tmodel.opacity = 1;\\n\\n\\t\\t\\t\\tvar labelColors = [];\\n\\t\\t\\t\\ttooltipPosition = Chart.Tooltip.positioners[opts.position](active, me._eventPosition);\\n\\n\\t\\t\\t\\tvar tooltipItems = [];\\n\\t\\t\\t\\tfor (i = 0, len = active.length; i < len; ++i) {\\n\\t\\t\\t\\t\\ttooltipItems.push(createTooltipItem(active[i]));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the user provided a filter function, use it to modify the tooltip items\\n\\t\\t\\t\\tif (opts.filter) {\\n\\t\\t\\t\\t\\ttooltipItems = tooltipItems.filter(function(a) {\\n\\t\\t\\t\\t\\t\\treturn opts.filter(a, data);\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the user provided a sorting function, use it to modify the tooltip items\\n\\t\\t\\t\\tif (opts.itemSort) {\\n\\t\\t\\t\\t\\ttooltipItems = tooltipItems.sort(function(a, b) {\\n\\t\\t\\t\\t\\t\\treturn opts.itemSort(a, b, data);\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Determine colors for boxes\\n\\t\\t\\t\\thelpers.each(tooltipItems, function(tooltipItem) {\\n\\t\\t\\t\\t\\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, chartInstance));\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t// Build the Text Lines\\n\\t\\t\\t\\tmodel.title = me.getTitle(tooltipItems, data);\\n\\t\\t\\t\\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\\n\\t\\t\\t\\tmodel.body = me.getBody(tooltipItems, data);\\n\\t\\t\\t\\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\\n\\t\\t\\t\\tmodel.footer = me.getFooter(tooltipItems, data);\\n\\n\\t\\t\\t\\t// Initial positioning and colors\\n\\t\\t\\t\\tmodel.x = Math.round(tooltipPosition.x);\\n\\t\\t\\t\\tmodel.y = Math.round(tooltipPosition.y);\\n\\t\\t\\t\\tmodel.caretPadding = helpers.getValueOrDefault(tooltipPosition.padding, 2);\\n\\t\\t\\t\\tmodel.labelColors = labelColors;\\n\\n\\t\\t\\t\\t// data points\\n\\t\\t\\t\\tmodel.dataPoints = tooltipItems;\\n\\n\\t\\t\\t\\t// We need to determine alignment of the tooltip\\n\\t\\t\\t\\ttooltipSize = getTooltipSize(this, model);\\n\\t\\t\\t\\talignment = determineAlignment(this, tooltipSize);\\n\\t\\t\\t\\t// Final Size and Position\\n\\t\\t\\t\\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmodel.opacity = 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tmodel.xAlign = alignment.xAlign;\\n\\t\\t\\tmodel.yAlign = alignment.yAlign;\\n\\t\\t\\tmodel.x = backgroundPoint.x;\\n\\t\\t\\tmodel.y = backgroundPoint.y;\\n\\t\\t\\tmodel.width = tooltipSize.width;\\n\\t\\t\\tmodel.height = tooltipSize.height;\\n\\n\\t\\t\\t// Point where the caret on the tooltip points to\\n\\t\\t\\tmodel.caretX = tooltipPosition.x;\\n\\t\\t\\tmodel.caretY = tooltipPosition.y;\\n\\n\\t\\t\\tme._model = model;\\n\\n\\t\\t\\tif (changed && opts.custom) {\\n\\t\\t\\t\\topts.custom.call(me, model);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn me;\\n\\t\\t},\\n\\t\\tdrawCaret: function(tooltipPoint, size, opacity) {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\tvar ctx = this._chart.ctx;\\n\\t\\t\\tvar x1, x2, x3;\\n\\t\\t\\tvar y1, y2, y3;\\n\\t\\t\\tvar caretSize = vm.caretSize;\\n\\t\\t\\tvar cornerRadius = vm.cornerRadius;\\n\\t\\t\\tvar xAlign = vm.xAlign,\\n\\t\\t\\t\\tyAlign = vm.yAlign;\\n\\t\\t\\tvar ptX = tooltipPoint.x,\\n\\t\\t\\t\\tptY = tooltipPoint.y;\\n\\t\\t\\tvar width = size.width,\\n\\t\\t\\t\\theight = size.height;\\n\\n\\t\\t\\tif (yAlign === 'center') {\\n\\t\\t\\t\\t// Left or right side\\n\\t\\t\\t\\tif (xAlign === 'left') {\\n\\t\\t\\t\\t\\tx1 = ptX;\\n\\t\\t\\t\\t\\tx2 = x1 - caretSize;\\n\\t\\t\\t\\t\\tx3 = x1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tx1 = ptX + width;\\n\\t\\t\\t\\t\\tx2 = x1 + caretSize;\\n\\t\\t\\t\\t\\tx3 = x1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ty2 = ptY + (height / 2);\\n\\t\\t\\t\\ty1 = y2 - caretSize;\\n\\t\\t\\t\\ty3 = y2 + caretSize;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (xAlign === 'left') {\\n\\t\\t\\t\\t\\tx1 = ptX + cornerRadius;\\n\\t\\t\\t\\t\\tx2 = x1 + caretSize;\\n\\t\\t\\t\\t\\tx3 = x2 + caretSize;\\n\\t\\t\\t\\t} else if (xAlign === 'right') {\\n\\t\\t\\t\\t\\tx1 = ptX + width - cornerRadius;\\n\\t\\t\\t\\t\\tx2 = x1 - caretSize;\\n\\t\\t\\t\\t\\tx3 = x2 - caretSize;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tx2 = ptX + (width / 2);\\n\\t\\t\\t\\t\\tx1 = x2 - caretSize;\\n\\t\\t\\t\\t\\tx3 = x2 + caretSize;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (yAlign === 'top') {\\n\\t\\t\\t\\t\\ty1 = ptY;\\n\\t\\t\\t\\t\\ty2 = y1 - caretSize;\\n\\t\\t\\t\\t\\ty3 = y1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ty1 = ptY + height;\\n\\t\\t\\t\\t\\ty2 = y1 + caretSize;\\n\\t\\t\\t\\t\\ty3 = y1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.moveTo(x1, y1);\\n\\t\\t\\tctx.lineTo(x2, y2);\\n\\t\\t\\tctx.lineTo(x3, y3);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tctx.fill();\\n\\t\\t},\\n\\t\\tdrawTitle: function(pt, vm, ctx, opacity) {\\n\\t\\t\\tvar title = vm.title;\\n\\n\\t\\t\\tif (title.length) {\\n\\t\\t\\t\\tctx.textAlign = vm._titleAlign;\\n\\t\\t\\t\\tctx.textBaseline = 'top';\\n\\n\\t\\t\\t\\tvar titleFontSize = vm.titleFontSize,\\n\\t\\t\\t\\t\\ttitleSpacing = vm.titleSpacing;\\n\\n\\t\\t\\t\\tctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);\\n\\t\\t\\t\\tctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\\n\\n\\t\\t\\t\\tvar i, len;\\n\\t\\t\\t\\tfor (i = 0, len = title.length; i < len; ++i) {\\n\\t\\t\\t\\t\\tctx.fillText(title[i], pt.x, pt.y);\\n\\t\\t\\t\\t\\tpt.y += titleFontSize + titleSpacing; // Line Height and spacing\\n\\n\\t\\t\\t\\t\\tif (i + 1 === title.length) {\\n\\t\\t\\t\\t\\t\\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tdrawBody: function(pt, vm, ctx, opacity) {\\n\\t\\t\\tvar bodyFontSize = vm.bodyFontSize;\\n\\t\\t\\tvar bodySpacing = vm.bodySpacing;\\n\\t\\t\\tvar body = vm.body;\\n\\n\\t\\t\\tctx.textAlign = vm._bodyAlign;\\n\\t\\t\\tctx.textBaseline = 'top';\\n\\n\\t\\t\\tvar textColor = mergeOpacity(vm.bodyFontColor, opacity);\\n\\t\\t\\tctx.fillStyle = textColor;\\n\\t\\t\\tctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\\n\\n\\t\\t\\t// Before Body\\n\\t\\t\\tvar xLinePadding = 0;\\n\\t\\t\\tvar fillLineOfText = function(line) {\\n\\t\\t\\t\\tctx.fillText(line, pt.x + xLinePadding, pt.y);\\n\\t\\t\\t\\tpt.y += bodyFontSize + bodySpacing;\\n\\t\\t\\t};\\n\\n\\t\\t\\t// Before body lines\\n\\t\\t\\thelpers.each(vm.beforeBody, fillLineOfText);\\n\\n\\t\\t\\tvar drawColorBoxes = vm.displayColors;\\n\\t\\t\\txLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;\\n\\n\\t\\t\\t// Draw body lines now\\n\\t\\t\\thelpers.each(body, function(bodyItem, i) {\\n\\t\\t\\t\\thelpers.each(bodyItem.before, fillLineOfText);\\n\\n\\t\\t\\t\\thelpers.each(bodyItem.lines, function(line) {\\n\\t\\t\\t\\t\\t// Draw Legend-like boxes if needed\\n\\t\\t\\t\\t\\tif (drawColorBoxes) {\\n\\t\\t\\t\\t\\t\\t// Fill a white rect so that colours merge nicely if the opacity is < 1\\n\\t\\t\\t\\t\\t\\tctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);\\n\\t\\t\\t\\t\\t\\tctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\\n\\n\\t\\t\\t\\t\\t\\t// Border\\n\\t\\t\\t\\t\\t\\tctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);\\n\\t\\t\\t\\t\\t\\tctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\\n\\n\\t\\t\\t\\t\\t\\t// Inner square\\n\\t\\t\\t\\t\\t\\tctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);\\n\\t\\t\\t\\t\\t\\tctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\\n\\n\\t\\t\\t\\t\\t\\tctx.fillStyle = textColor;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfillLineOfText(line);\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\thelpers.each(bodyItem.after, fillLineOfText);\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Reset back to 0 for after body\\n\\t\\t\\txLinePadding = 0;\\n\\n\\t\\t\\t// After body lines\\n\\t\\t\\thelpers.each(vm.afterBody, fillLineOfText);\\n\\t\\t\\tpt.y -= bodySpacing; // Remove last body spacing\\n\\t\\t},\\n\\t\\tdrawFooter: function(pt, vm, ctx, opacity) {\\n\\t\\t\\tvar footer = vm.footer;\\n\\n\\t\\t\\tif (footer.length) {\\n\\t\\t\\t\\tpt.y += vm.footerMarginTop;\\n\\n\\t\\t\\t\\tctx.textAlign = vm._footerAlign;\\n\\t\\t\\t\\tctx.textBaseline = 'top';\\n\\n\\t\\t\\t\\tctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);\\n\\t\\t\\t\\tctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\\n\\n\\t\\t\\t\\thelpers.each(footer, function(line) {\\n\\t\\t\\t\\t\\tctx.fillText(line, pt.x, pt.y);\\n\\t\\t\\t\\t\\tpt.y += vm.footerFontSize + vm.footerSpacing;\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tdrawBackground: function(pt, vm, ctx, tooltipSize, opacity) {\\n\\t\\t\\tctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\\n\\t\\t\\thelpers.drawRoundedRectangle(ctx, pt.x, pt.y, tooltipSize.width, tooltipSize.height, vm.cornerRadius);\\n\\t\\t\\tctx.fill();\\n\\t\\t},\\n\\t\\tdraw: function() {\\n\\t\\t\\tvar ctx = this._chart.ctx;\\n\\t\\t\\tvar vm = this._view;\\n\\n\\t\\t\\tif (vm.opacity === 0) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar tooltipSize = {\\n\\t\\t\\t\\twidth: vm.width,\\n\\t\\t\\t\\theight: vm.height\\n\\t\\t\\t};\\n\\t\\t\\tvar pt = {\\n\\t\\t\\t\\tx: vm.x,\\n\\t\\t\\t\\ty: vm.y\\n\\t\\t\\t};\\n\\n\\t\\t\\t// IE11/Edge does not like very small opacities, so snap to 0\\n\\t\\t\\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\\n\\n\\t\\t\\tif (this._options.enabled) {\\n\\t\\t\\t\\t// Draw Background\\n\\t\\t\\t\\tthis.drawBackground(pt, vm, ctx, tooltipSize, opacity);\\n\\n\\t\\t\\t\\t// Draw Caret\\n\\t\\t\\t\\tthis.drawCaret(pt, tooltipSize, opacity);\\n\\n\\t\\t\\t\\t// Draw Title, Body, and Footer\\n\\t\\t\\t\\tpt.x += vm.xPadding;\\n\\t\\t\\t\\tpt.y += vm.yPadding;\\n\\n\\t\\t\\t\\t// Titles\\n\\t\\t\\t\\tthis.drawTitle(pt, vm, ctx, opacity);\\n\\n\\t\\t\\t\\t// Body\\n\\t\\t\\t\\tthis.drawBody(pt, vm, ctx, opacity);\\n\\n\\t\\t\\t\\t// Footer\\n\\t\\t\\t\\tthis.drawFooter(pt, vm, ctx, opacity);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Handle an event\\n\\t\\t * @private\\n\\t\\t * @param {IEvent} event - The event to handle\\n\\t\\t * @returns {Boolean} true if the tooltip changed\\n\\t\\t */\\n\\t\\thandleEvent: function(e) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar options = me._options;\\n\\t\\t\\tvar changed = false;\\n\\n\\t\\t\\tme._lastActive = me._lastActive || [];\\n\\n\\t\\t\\t// Find Active Elements for tooltips\\n\\t\\t\\tif (e.type === 'mouseout') {\\n\\t\\t\\t\\tme._active = [];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme._active = me._chartInstance.getElementsAtEventForMode(e, options.mode, options);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Remember Last Actives\\n\\t\\t\\tchanged = !helpers.arrayEquals(me._active, me._lastActive);\\n\\t\\t\\tme._lastActive = me._active;\\n\\n\\t\\t\\tif (options.enabled || options.custom) {\\n\\t\\t\\t\\tme._eventPosition = {\\n\\t\\t\\t\\t\\tx: e.x,\\n\\t\\t\\t\\t\\ty: e.y\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tvar model = me._model;\\n\\t\\t\\t\\tme.update(true);\\n\\t\\t\\t\\tme.pivot();\\n\\n\\t\\t\\t\\t// See if our tooltip position changed\\n\\t\\t\\t\\tchanged |= (model.x !== me._model.x) || (model.y !== me._model.y);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn changed;\\n\\t\\t}\\n\\t});\\n\\n\\t/**\\n\\t * @namespace Chart.Tooltip.positioners\\n\\t */\\n\\tChart.Tooltip.positioners = {\\n\\t\\t/**\\n\\t\\t * Average mode places the tooltip at the average position of the elements shown\\n\\t\\t * @function Chart.Tooltip.positioners.average\\n\\t\\t * @param elements {ChartElement[]} the elements being displayed in the tooltip\\n\\t\\t * @returns {Point} tooltip position\\n\\t\\t */\\n\\t\\taverage: function(elements) {\\n\\t\\t\\tif (!elements.length) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar i, len;\\n\\t\\t\\tvar x = 0;\\n\\t\\t\\tvar y = 0;\\n\\t\\t\\tvar count = 0;\\n\\n\\t\\t\\tfor (i = 0, len = elements.length; i < len; ++i) {\\n\\t\\t\\t\\tvar el = elements[i];\\n\\t\\t\\t\\tif (el && el.hasValue()) {\\n\\t\\t\\t\\t\\tvar pos = el.tooltipPosition();\\n\\t\\t\\t\\t\\tx += pos.x;\\n\\t\\t\\t\\t\\ty += pos.y;\\n\\t\\t\\t\\t\\t++count;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: Math.round(x / count),\\n\\t\\t\\t\\ty: Math.round(y / count)\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Gets the tooltip position nearest of the item nearest to the event position\\n\\t\\t * @function Chart.Tooltip.positioners.nearest\\n\\t\\t * @param elements {Chart.Element[]} the tooltip elements\\n\\t\\t * @param eventPosition {Point} the position of the event in canvas coordinates\\n\\t\\t * @returns {Point} the tooltip position\\n\\t\\t */\\n\\t\\tnearest: function(elements, eventPosition) {\\n\\t\\t\\tvar x = eventPosition.x;\\n\\t\\t\\tvar y = eventPosition.y;\\n\\n\\t\\t\\tvar nearestElement;\\n\\t\\t\\tvar minDistance = Number.POSITIVE_INFINITY;\\n\\t\\t\\tvar i, len;\\n\\t\\t\\tfor (i = 0, len = elements.length; i < len; ++i) {\\n\\t\\t\\t\\tvar el = elements[i];\\n\\t\\t\\t\\tif (el && el.hasValue()) {\\n\\t\\t\\t\\t\\tvar center = el.getCenterPoint();\\n\\t\\t\\t\\t\\tvar d = helpers.distanceBetweenPoints(eventPosition, center);\\n\\n\\t\\t\\t\\t\\tif (d < minDistance) {\\n\\t\\t\\t\\t\\t\\tminDistance = d;\\n\\t\\t\\t\\t\\t\\tnearestElement = el;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (nearestElement) {\\n\\t\\t\\t\\tvar tp = nearestElement.tooltipPosition();\\n\\t\\t\\t\\tx = tp.x;\\n\\t\\t\\t\\ty = tp.y;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: x,\\n\\t\\t\\t\\ty: y\\n\\t\\t\\t};\\n\\t\\t}\\n\\t};\\n};\\n\\n},{}],37:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers,\\n\\t\\tglobalOpts = Chart.defaults.global;\\n\\n\\tglobalOpts.elements.arc = {\\n\\t\\tbackgroundColor: globalOpts.defaultColor,\\n\\t\\tborderColor: '#fff',\\n\\t\\tborderWidth: 2\\n\\t};\\n\\n\\tChart.elements.Arc = Chart.Element.extend({\\n\\t\\tinLabelRange: function(mouseX) {\\n\\t\\t\\tvar vm = this._view;\\n\\n\\t\\t\\tif (vm) {\\n\\t\\t\\t\\treturn (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t},\\n\\t\\tinRange: function(chartX, chartY) {\\n\\t\\t\\tvar vm = this._view;\\n\\n\\t\\t\\tif (vm) {\\n\\t\\t\\t\\tvar pointRelativePosition = helpers.getAngleFromPoint(vm, {\\n\\t\\t\\t\\t\\t\\tx: chartX,\\n\\t\\t\\t\\t\\t\\ty: chartY\\n\\t\\t\\t\\t\\t}),\\n\\t\\t\\t\\t\\tangle = pointRelativePosition.angle,\\n\\t\\t\\t\\t\\tdistance = pointRelativePosition.distance;\\n\\n\\t\\t\\t\\t// Sanitise angle range\\n\\t\\t\\t\\tvar startAngle = vm.startAngle;\\n\\t\\t\\t\\tvar endAngle = vm.endAngle;\\n\\t\\t\\t\\twhile (endAngle < startAngle) {\\n\\t\\t\\t\\t\\tendAngle += 2.0 * Math.PI;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twhile (angle > endAngle) {\\n\\t\\t\\t\\t\\tangle -= 2.0 * Math.PI;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twhile (angle < startAngle) {\\n\\t\\t\\t\\t\\tangle += 2.0 * Math.PI;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Check if within the range of the open/close angle\\n\\t\\t\\t\\tvar betweenAngles = (angle >= startAngle && angle <= endAngle),\\n\\t\\t\\t\\t\\twithinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);\\n\\n\\t\\t\\t\\treturn (betweenAngles && withinRadius);\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t},\\n\\t\\tgetCenterPoint: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\tvar halfAngle = (vm.startAngle + vm.endAngle) / 2;\\n\\t\\t\\tvar halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: vm.x + Math.cos(halfAngle) * halfRadius,\\n\\t\\t\\t\\ty: vm.y + Math.sin(halfAngle) * halfRadius\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tgetArea: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\treturn Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\\n\\t\\t},\\n\\t\\ttooltipPosition: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\n\\t\\t\\tvar centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2),\\n\\t\\t\\t\\trangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\\n\\t\\t\\t\\ty: vm.y + (Math.sin(centreAngle) * rangeFromCentre)\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tdraw: function() {\\n\\n\\t\\t\\tvar ctx = this._chart.ctx,\\n\\t\\t\\t\\tvm = this._view,\\n\\t\\t\\t\\tsA = vm.startAngle,\\n\\t\\t\\t\\teA = vm.endAngle;\\n\\n\\t\\t\\tctx.beginPath();\\n\\n\\t\\t\\tctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);\\n\\t\\t\\tctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\\n\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tctx.strokeStyle = vm.borderColor;\\n\\t\\t\\tctx.lineWidth = vm.borderWidth;\\n\\n\\t\\t\\tctx.fillStyle = vm.backgroundColor;\\n\\n\\t\\t\\tctx.fill();\\n\\t\\t\\tctx.lineJoin = 'bevel';\\n\\n\\t\\t\\tif (vm.borderWidth) {\\n\\t\\t\\t\\tctx.stroke();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],38:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\tvar globalDefaults = Chart.defaults.global;\\n\\n\\tChart.defaults.global.elements.line = {\\n\\t\\ttension: 0.4,\\n\\t\\tbackgroundColor: globalDefaults.defaultColor,\\n\\t\\tborderWidth: 3,\\n\\t\\tborderColor: globalDefaults.defaultColor,\\n\\t\\tborderCapStyle: 'butt',\\n\\t\\tborderDash: [],\\n\\t\\tborderDashOffset: 0.0,\\n\\t\\tborderJoinStyle: 'miter',\\n\\t\\tcapBezierPoints: true,\\n\\t\\tfill: true, // do we fill in the area between the line and its base axis\\n\\t};\\n\\n\\tChart.elements.Line = Chart.Element.extend({\\n\\t\\tdraw: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar vm = me._view;\\n\\t\\t\\tvar spanGaps = vm.spanGaps;\\n\\t\\t\\tvar fillPoint = vm.scaleZero;\\n\\t\\t\\tvar loop = me._loop;\\n\\n\\t\\t\\t// Handle different fill modes for cartesian lines\\n\\t\\t\\tif (!loop) {\\n\\t\\t\\t\\tif (vm.fill === 'top') {\\n\\t\\t\\t\\t\\tfillPoint = vm.scaleTop;\\n\\t\\t\\t\\t} else if (vm.fill === 'bottom') {\\n\\t\\t\\t\\t\\tfillPoint = vm.scaleBottom;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar ctx = me._chart.ctx;\\n\\t\\t\\tctx.save();\\n\\n\\t\\t\\t// Helper function to draw a line to a point\\n\\t\\t\\tfunction lineToPoint(previousPoint, point) {\\n\\t\\t\\t\\tvar pointVM = point._view;\\n\\t\\t\\t\\tif (point._view.steppedLine === true) {\\n\\t\\t\\t\\t\\tctx.lineTo(pointVM.x, previousPoint._view.y);\\n\\t\\t\\t\\t\\tctx.lineTo(pointVM.x, pointVM.y);\\n\\t\\t\\t\\t} else if (point._view.tension === 0) {\\n\\t\\t\\t\\t\\tctx.lineTo(pointVM.x, pointVM.y);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tctx.bezierCurveTo(\\n\\t\\t\\t\\t\\t\\tpreviousPoint._view.controlPointNextX,\\n\\t\\t\\t\\t\\t\\tpreviousPoint._view.controlPointNextY,\\n\\t\\t\\t\\t\\t\\tpointVM.controlPointPreviousX,\\n\\t\\t\\t\\t\\t\\tpointVM.controlPointPreviousY,\\n\\t\\t\\t\\t\\t\\tpointVM.x,\\n\\t\\t\\t\\t\\t\\tpointVM.y\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar points = me._children.slice(); // clone array\\n\\t\\t\\tvar lastDrawnIndex = -1;\\n\\n\\t\\t\\t// If we are looping, adding the first point again\\n\\t\\t\\tif (loop && points.length) {\\n\\t\\t\\t\\tpoints.push(points[0]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar index, current, previous, currentVM;\\n\\n\\t\\t\\t// Fill Line\\n\\t\\t\\tif (points.length && vm.fill) {\\n\\t\\t\\t\\tctx.beginPath();\\n\\n\\t\\t\\t\\tfor (index = 0; index < points.length; ++index) {\\n\\t\\t\\t\\t\\tcurrent = points[index];\\n\\t\\t\\t\\t\\tprevious = helpers.previousItem(points, index);\\n\\t\\t\\t\\t\\tcurrentVM = current._view;\\n\\n\\t\\t\\t\\t\\t// First point moves to it's starting position no matter what\\n\\t\\t\\t\\t\\tif (index === 0) {\\n\\t\\t\\t\\t\\t\\tif (loop) {\\n\\t\\t\\t\\t\\t\\t\\tctx.moveTo(fillPoint.x, fillPoint.y);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tctx.moveTo(currentVM.x, fillPoint);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif (!currentVM.skip) {\\n\\t\\t\\t\\t\\t\\t\\tlastDrawnIndex = index;\\n\\t\\t\\t\\t\\t\\t\\tctx.lineTo(currentVM.x, currentVM.y);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\\n\\n\\t\\t\\t\\t\\t\\tif (currentVM.skip) {\\n\\t\\t\\t\\t\\t\\t\\t// Only do this if this is the first point that is skipped\\n\\t\\t\\t\\t\\t\\t\\tif (!spanGaps && lastDrawnIndex === (index - 1)) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (loop) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tctx.lineTo(fillPoint.x, fillPoint.y);\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tctx.lineTo(previous._view.x, fillPoint);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tif (lastDrawnIndex !== (index - 1)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// There was a gap and this is the first point after the gap. If we've never drawn a point, this is a special case.\\n\\t\\t\\t\\t\\t\\t\\t\\t// If the first data point is NaN, then there is no real gap to skip\\n\\t\\t\\t\\t\\t\\t\\t\\tif (spanGaps && lastDrawnIndex !== -1) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// We are spanning the gap, so simple draw a line to this point\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tlineToPoint(previous, current);\\n\\t\\t\\t\\t\\t\\t\\t\\t} else if (loop) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tctx.lineTo(currentVM.x, currentVM.y);\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tctx.lineTo(currentVM.x, fillPoint);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tctx.lineTo(currentVM.x, currentVM.y);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t// Line to next point\\n\\t\\t\\t\\t\\t\\t\\t\\tlineToPoint(previous, current);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tlastDrawnIndex = index;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (!loop && lastDrawnIndex !== -1) {\\n\\t\\t\\t\\t\\tctx.lineTo(points[lastDrawnIndex]._view.x, fillPoint);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tctx.fillStyle = vm.backgroundColor || globalDefaults.defaultColor;\\n\\t\\t\\t\\tctx.closePath();\\n\\t\\t\\t\\tctx.fill();\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Stroke Line Options\\n\\t\\t\\tvar globalOptionLineElements = globalDefaults.elements.line;\\n\\t\\t\\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\\n\\n\\t\\t\\t// IE 9 and 10 do not support line dash\\n\\t\\t\\tif (ctx.setLineDash) {\\n\\t\\t\\t\\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\\n\\t\\t\\t}\\n\\n\\t\\t\\tctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\\n\\t\\t\\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\\n\\t\\t\\tctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\\n\\t\\t\\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\\n\\n\\t\\t\\t// Stroke Line\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tlastDrawnIndex = -1;\\n\\n\\t\\t\\tfor (index = 0; index < points.length; ++index) {\\n\\t\\t\\t\\tcurrent = points[index];\\n\\t\\t\\t\\tprevious = helpers.previousItem(points, index);\\n\\t\\t\\t\\tcurrentVM = current._view;\\n\\n\\t\\t\\t\\t// First point moves to it's starting position no matter what\\n\\t\\t\\t\\tif (index === 0) {\\n\\t\\t\\t\\t\\tif (!currentVM.skip) {\\n\\t\\t\\t\\t\\t\\tctx.moveTo(currentVM.x, currentVM.y);\\n\\t\\t\\t\\t\\t\\tlastDrawnIndex = index;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\\n\\n\\t\\t\\t\\t\\tif (!currentVM.skip) {\\n\\t\\t\\t\\t\\t\\tif ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\\n\\t\\t\\t\\t\\t\\t\\t// There was a gap and this is the first point after the gap\\n\\t\\t\\t\\t\\t\\t\\tctx.moveTo(currentVM.x, currentVM.y);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Line to next point\\n\\t\\t\\t\\t\\t\\t\\tlineToPoint(previous, current);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tlastDrawnIndex = index;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tctx.stroke();\\n\\t\\t\\tctx.restore();\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],39:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers,\\n\\t\\tglobalOpts = Chart.defaults.global,\\n\\t\\tdefaultColor = globalOpts.defaultColor;\\n\\n\\tglobalOpts.elements.point = {\\n\\t\\tradius: 3,\\n\\t\\tpointStyle: 'circle',\\n\\t\\tbackgroundColor: defaultColor,\\n\\t\\tborderWidth: 1,\\n\\t\\tborderColor: defaultColor,\\n\\t\\t// Hover\\n\\t\\thitRadius: 1,\\n\\t\\thoverRadius: 4,\\n\\t\\thoverBorderWidth: 1\\n\\t};\\n\\n\\tfunction xRange(mouseX) {\\n\\t\\tvar vm = this._view;\\n\\t\\treturn vm ? (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;\\n\\t}\\n\\n\\tfunction yRange(mouseY) {\\n\\t\\tvar vm = this._view;\\n\\t\\treturn vm ? (Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;\\n\\t}\\n\\n\\tChart.elements.Point = Chart.Element.extend({\\n\\t\\tinRange: function(mouseX, mouseY) {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\treturn vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;\\n\\t\\t},\\n\\n\\t\\tinLabelRange: xRange,\\n\\t\\tinXRange: xRange,\\n\\t\\tinYRange: yRange,\\n\\n\\t\\tgetCenterPoint: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: vm.x,\\n\\t\\t\\t\\ty: vm.y\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tgetArea: function() {\\n\\t\\t\\treturn Math.PI * Math.pow(this._view.radius, 2);\\n\\t\\t},\\n\\t\\ttooltipPosition: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: vm.x,\\n\\t\\t\\t\\ty: vm.y,\\n\\t\\t\\t\\tpadding: vm.radius + vm.borderWidth\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tdraw: function(chartArea) {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\tvar model = this._model;\\n\\t\\t\\tvar ctx = this._chart.ctx;\\n\\t\\t\\tvar pointStyle = vm.pointStyle;\\n\\t\\t\\tvar radius = vm.radius;\\n\\t\\t\\tvar x = vm.x;\\n\\t\\t\\tvar y = vm.y;\\n\\t\\t\\tvar color = Chart.helpers.color;\\n\\t\\t\\tvar errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)\\n\\t\\t\\tvar ratio = 0;\\n\\n\\t\\t\\tif (vm.skip) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tctx.strokeStyle = vm.borderColor || defaultColor;\\n\\t\\t\\tctx.lineWidth = helpers.getValueOrDefault(vm.borderWidth, globalOpts.elements.point.borderWidth);\\n\\t\\t\\tctx.fillStyle = vm.backgroundColor || defaultColor;\\n\\n\\t\\t\\t// Cliping for Points.\\n\\t\\t\\t// going out from inner charArea?\\n\\t\\t\\tif ((chartArea !== undefined) && ((model.x < chartArea.left) || (chartArea.right*errMargin < model.x) || (model.y < chartArea.top) || (chartArea.bottom*errMargin < model.y))) {\\n\\t\\t\\t\\t// Point fade out\\n\\t\\t\\t\\tif (model.x < chartArea.left) {\\n\\t\\t\\t\\t\\tratio = (x - model.x) / (chartArea.left - model.x);\\n\\t\\t\\t\\t} else if (chartArea.right*errMargin < model.x) {\\n\\t\\t\\t\\t\\tratio = (model.x - x) / (model.x - chartArea.right);\\n\\t\\t\\t\\t} else if (model.y < chartArea.top) {\\n\\t\\t\\t\\t\\tratio = (y - model.y) / (chartArea.top - model.y);\\n\\t\\t\\t\\t} else if (chartArea.bottom*errMargin < model.y) {\\n\\t\\t\\t\\t\\tratio = (model.y - y) / (model.y - chartArea.bottom);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tratio = Math.round(ratio*100) / 100;\\n\\t\\t\\t\\tctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();\\n\\t\\t\\t\\tctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();\\n\\t\\t\\t}\\n\\n\\t\\t\\tChart.canvasHelpers.drawPoint(ctx, pointStyle, radius, x, y);\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],40:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar globalOpts = Chart.defaults.global;\\n\\n\\tglobalOpts.elements.rectangle = {\\n\\t\\tbackgroundColor: globalOpts.defaultColor,\\n\\t\\tborderWidth: 0,\\n\\t\\tborderColor: globalOpts.defaultColor,\\n\\t\\tborderSkipped: 'bottom'\\n\\t};\\n\\n\\tfunction isVertical(bar) {\\n\\t\\treturn bar._view.width !== undefined;\\n\\t}\\n\\n\\t/**\\n\\t * Helper function to get the bounds of the bar regardless of the orientation\\n\\t * @private\\n\\t * @param bar {Chart.Element.Rectangle} the bar\\n\\t * @return {Bounds} bounds of the bar\\n\\t */\\n\\tfunction getBarBounds(bar) {\\n\\t\\tvar vm = bar._view;\\n\\t\\tvar x1, x2, y1, y2;\\n\\n\\t\\tif (isVertical(bar)) {\\n\\t\\t\\t// vertical\\n\\t\\t\\tvar halfWidth = vm.width / 2;\\n\\t\\t\\tx1 = vm.x - halfWidth;\\n\\t\\t\\tx2 = vm.x + halfWidth;\\n\\t\\t\\ty1 = Math.min(vm.y, vm.base);\\n\\t\\t\\ty2 = Math.max(vm.y, vm.base);\\n\\t\\t} else {\\n\\t\\t\\t// horizontal bar\\n\\t\\t\\tvar halfHeight = vm.height / 2;\\n\\t\\t\\tx1 = Math.min(vm.x, vm.base);\\n\\t\\t\\tx2 = Math.max(vm.x, vm.base);\\n\\t\\t\\ty1 = vm.y - halfHeight;\\n\\t\\t\\ty2 = vm.y + halfHeight;\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tleft: x1,\\n\\t\\t\\ttop: y1,\\n\\t\\t\\tright: x2,\\n\\t\\t\\tbottom: y2\\n\\t\\t};\\n\\t}\\n\\n\\tChart.elements.Rectangle = Chart.Element.extend({\\n\\t\\tdraw: function() {\\n\\t\\t\\tvar ctx = this._chart.ctx;\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\tvar left, right, top, bottom, signX, signY, borderSkipped;\\n\\t\\t\\tvar borderWidth = vm.borderWidth;\\n\\n\\t\\t\\tif (!vm.horizontal) {\\n\\t\\t\\t\\t// bar\\n\\t\\t\\t\\tleft = vm.x - vm.width / 2;\\n\\t\\t\\t\\tright = vm.x + vm.width / 2;\\n\\t\\t\\t\\ttop = vm.y;\\n\\t\\t\\t\\tbottom = vm.base;\\n\\t\\t\\t\\tsignX = 1;\\n\\t\\t\\t\\tsignY = bottom > top? 1: -1;\\n\\t\\t\\t\\tborderSkipped = vm.borderSkipped || 'bottom';\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// horizontal bar\\n\\t\\t\\t\\tleft = vm.base;\\n\\t\\t\\t\\tright = vm.x;\\n\\t\\t\\t\\ttop = vm.y - vm.height / 2;\\n\\t\\t\\t\\tbottom = vm.y + vm.height / 2;\\n\\t\\t\\t\\tsignX = right > left? 1: -1;\\n\\t\\t\\t\\tsignY = 1;\\n\\t\\t\\t\\tborderSkipped = vm.borderSkipped || 'left';\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Canvas doesn't allow us to stroke inside the width so we can\\n\\t\\t\\t// adjust the sizes to fit if we're setting a stroke on the line\\n\\t\\t\\tif (borderWidth) {\\n\\t\\t\\t\\t// borderWidth shold be less than bar width and bar height.\\n\\t\\t\\t\\tvar barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\\n\\t\\t\\t\\tborderWidth = borderWidth > barSize? barSize: borderWidth;\\n\\t\\t\\t\\tvar halfStroke = borderWidth / 2;\\n\\t\\t\\t\\t// Adjust borderWidth when bar top position is near vm.base(zero).\\n\\t\\t\\t\\tvar borderLeft = left + (borderSkipped !== 'left'? halfStroke * signX: 0);\\n\\t\\t\\t\\tvar borderRight = right + (borderSkipped !== 'right'? -halfStroke * signX: 0);\\n\\t\\t\\t\\tvar borderTop = top + (borderSkipped !== 'top'? halfStroke * signY: 0);\\n\\t\\t\\t\\tvar borderBottom = bottom + (borderSkipped !== 'bottom'? -halfStroke * signY: 0);\\n\\t\\t\\t\\t// not become a vertical line?\\n\\t\\t\\t\\tif (borderLeft !== borderRight) {\\n\\t\\t\\t\\t\\ttop = borderTop;\\n\\t\\t\\t\\t\\tbottom = borderBottom;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// not become a horizontal line?\\n\\t\\t\\t\\tif (borderTop !== borderBottom) {\\n\\t\\t\\t\\t\\tleft = borderLeft;\\n\\t\\t\\t\\t\\tright = borderRight;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.fillStyle = vm.backgroundColor;\\n\\t\\t\\tctx.strokeStyle = vm.borderColor;\\n\\t\\t\\tctx.lineWidth = borderWidth;\\n\\n\\t\\t\\t// Corner points, from bottom-left to bottom-right clockwise\\n\\t\\t\\t// | 1 2 |\\n\\t\\t\\t// | 0 3 |\\n\\t\\t\\tvar corners = [\\n\\t\\t\\t\\t[left, bottom],\\n\\t\\t\\t\\t[left, top],\\n\\t\\t\\t\\t[right, top],\\n\\t\\t\\t\\t[right, bottom]\\n\\t\\t\\t];\\n\\n\\t\\t\\t// Find first (starting) corner with fallback to 'bottom'\\n\\t\\t\\tvar borders = ['bottom', 'left', 'top', 'right'];\\n\\t\\t\\tvar startCorner = borders.indexOf(borderSkipped, 0);\\n\\t\\t\\tif (startCorner === -1) {\\n\\t\\t\\t\\tstartCorner = 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction cornerAt(index) {\\n\\t\\t\\t\\treturn corners[(startCorner + index) % 4];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Draw rectangle from 'startCorner'\\n\\t\\t\\tvar corner = cornerAt(0);\\n\\t\\t\\tctx.moveTo(corner[0], corner[1]);\\n\\n\\t\\t\\tfor (var i = 1; i < 4; i++) {\\n\\t\\t\\t\\tcorner = cornerAt(i);\\n\\t\\t\\t\\tctx.lineTo(corner[0], corner[1]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tctx.fill();\\n\\t\\t\\tif (borderWidth) {\\n\\t\\t\\t\\tctx.stroke();\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\theight: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\treturn vm.base - vm.y;\\n\\t\\t},\\n\\t\\tinRange: function(mouseX, mouseY) {\\n\\t\\t\\tvar inRange = false;\\n\\n\\t\\t\\tif (this._view) {\\n\\t\\t\\t\\tvar bounds = getBarBounds(this);\\n\\t\\t\\t\\tinRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn inRange;\\n\\t\\t},\\n\\t\\tinLabelRange: function(mouseX, mouseY) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (!me._view) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar inRange = false;\\n\\t\\t\\tvar bounds = getBarBounds(me);\\n\\n\\t\\t\\tif (isVertical(me)) {\\n\\t\\t\\t\\tinRange = mouseX >= bounds.left && mouseX <= bounds.right;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tinRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn inRange;\\n\\t\\t},\\n\\t\\tinXRange: function(mouseX) {\\n\\t\\t\\tvar bounds = getBarBounds(this);\\n\\t\\t\\treturn mouseX >= bounds.left && mouseX <= bounds.right;\\n\\t\\t},\\n\\t\\tinYRange: function(mouseY) {\\n\\t\\t\\tvar bounds = getBarBounds(this);\\n\\t\\t\\treturn mouseY >= bounds.top && mouseY <= bounds.bottom;\\n\\t\\t},\\n\\t\\tgetCenterPoint: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\tvar x, y;\\n\\t\\t\\tif (isVertical(this)) {\\n\\t\\t\\t\\tx = vm.x;\\n\\t\\t\\t\\ty = (vm.y + vm.base) / 2;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tx = (vm.x + vm.base) / 2;\\n\\t\\t\\t\\ty = vm.y;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn {x: x, y: y};\\n\\t\\t},\\n\\t\\tgetArea: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\treturn vm.width * Math.abs(vm.y - vm.base);\\n\\t\\t},\\n\\t\\ttooltipPosition: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: vm.x,\\n\\t\\t\\t\\ty: vm.y\\n\\t\\t\\t};\\n\\t\\t}\\n\\t});\\n\\n};\\n\\n},{}],41:[function(require,module,exports){\\n'use strict';\\n\\n// Chart.Platform implementation for targeting a web browser\\nmodule.exports = function(Chart) {\\n\\tvar helpers = Chart.helpers;\\n\\n\\t// DOM event types -> Chart.js event types.\\n\\t// Note: only events with different types are mapped.\\n\\t// https://developer.mozilla.org/en-US/docs/Web/Events\\n\\tvar eventTypeMap = {\\n\\t\\t// Touch events\\n\\t\\ttouchstart: 'mousedown',\\n\\t\\ttouchmove: 'mousemove',\\n\\t\\ttouchend: 'mouseup',\\n\\n\\t\\t// Pointer events\\n\\t\\tpointerenter: 'mouseenter',\\n\\t\\tpointerdown: 'mousedown',\\n\\t\\tpointermove: 'mousemove',\\n\\t\\tpointerup: 'mouseup',\\n\\t\\tpointerleave: 'mouseout',\\n\\t\\tpointerout: 'mouseout'\\n\\t};\\n\\n\\t/**\\n\\t * The \\\"used\\\" size is the final value of a dimension property after all calculations have\\n\\t * been performed. This method uses the computed style of `element` but returns undefined\\n\\t * if the computed style is not expressed in pixels. That can happen in some cases where\\n\\t * `element` has a size relative to its parent and this last one is not yet displayed,\\n\\t * for example because of `display: none` on a parent node.\\n\\t * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\\n\\t * @returns {Number} Size in pixels or undefined if unknown.\\n\\t */\\n\\tfunction readUsedSize(element, property) {\\n\\t\\tvar value = helpers.getStyle(element, property);\\n\\t\\tvar matches = value && value.match(/(\\\\d+)px/);\\n\\t\\treturn matches? Number(matches[1]) : undefined;\\n\\t}\\n\\n\\t/**\\n\\t * Initializes the canvas style and render size without modifying the canvas display size,\\n\\t * since responsiveness is handled by the controller.resize() method. The config is used\\n\\t * to determine the aspect ratio to apply in case no explicit height has been specified.\\n\\t */\\n\\tfunction initCanvas(canvas, config) {\\n\\t\\tvar style = canvas.style;\\n\\n\\t\\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\\n\\t\\t// returns null or '' if no explicit value has been set to the canvas attribute.\\n\\t\\tvar renderHeight = canvas.getAttribute('height');\\n\\t\\tvar renderWidth = canvas.getAttribute('width');\\n\\n\\t\\t// Chart.js modifies some canvas values that we want to restore on destroy\\n\\t\\tcanvas._chartjs = {\\n\\t\\t\\tinitial: {\\n\\t\\t\\t\\theight: renderHeight,\\n\\t\\t\\t\\twidth: renderWidth,\\n\\t\\t\\t\\tstyle: {\\n\\t\\t\\t\\t\\tdisplay: style.display,\\n\\t\\t\\t\\t\\theight: style.height,\\n\\t\\t\\t\\t\\twidth: style.width\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\t// Force canvas to display as block to avoid extra space caused by inline\\n\\t\\t// elements, which would interfere with the responsive resize process.\\n\\t\\t// https://github.com/chartjs/Chart.js/issues/2538\\n\\t\\tstyle.display = style.display || 'block';\\n\\n\\t\\tif (renderWidth === null || renderWidth === '') {\\n\\t\\t\\tvar displayWidth = readUsedSize(canvas, 'width');\\n\\t\\t\\tif (displayWidth !== undefined) {\\n\\t\\t\\t\\tcanvas.width = displayWidth;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (renderHeight === null || renderHeight === '') {\\n\\t\\t\\tif (canvas.style.height === '') {\\n\\t\\t\\t\\t// If no explicit render height and style height, let's apply the aspect ratio,\\n\\t\\t\\t\\t// which one can be specified by the user but also by charts as default option\\n\\t\\t\\t\\t// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\\n\\t\\t\\t\\tcanvas.height = canvas.width / (config.options.aspectRatio || 2);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvar displayHeight = readUsedSize(canvas, 'height');\\n\\t\\t\\t\\tif (displayWidth !== undefined) {\\n\\t\\t\\t\\t\\tcanvas.height = displayHeight;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn canvas;\\n\\t}\\n\\n\\tfunction createEvent(type, chart, x, y, native) {\\n\\t\\treturn {\\n\\t\\t\\ttype: type,\\n\\t\\t\\tchart: chart,\\n\\t\\t\\tnative: native || null,\\n\\t\\t\\tx: x !== undefined? x : null,\\n\\t\\t\\ty: y !== undefined? y : null,\\n\\t\\t};\\n\\t}\\n\\n\\tfunction fromNativeEvent(event, chart) {\\n\\t\\tvar type = eventTypeMap[event.type] || event.type;\\n\\t\\tvar pos = helpers.getRelativePosition(event, chart);\\n\\t\\treturn createEvent(type, chart, pos.x, pos.y, event);\\n\\t}\\n\\n\\tfunction createResizer(handler) {\\n\\t\\tvar iframe = document.createElement('iframe');\\n\\t\\tiframe.className = 'chartjs-hidden-iframe';\\n\\t\\tiframe.style.cssText =\\n\\t\\t\\t'display:block;'+\\n\\t\\t\\t'overflow:hidden;'+\\n\\t\\t\\t'border:0;'+\\n\\t\\t\\t'margin:0;'+\\n\\t\\t\\t'top:0;'+\\n\\t\\t\\t'left:0;'+\\n\\t\\t\\t'bottom:0;'+\\n\\t\\t\\t'right:0;'+\\n\\t\\t\\t'height:100%;'+\\n\\t\\t\\t'width:100%;'+\\n\\t\\t\\t'position:absolute;'+\\n\\t\\t\\t'pointer-events:none;'+\\n\\t\\t\\t'z-index:-1;';\\n\\n\\t\\t// Prevent the iframe to gain focus on tab.\\n\\t\\t// https://github.com/chartjs/Chart.js/issues/3090\\n\\t\\tiframe.tabIndex = -1;\\n\\n\\t\\t// If the iframe is re-attached to the DOM, the resize listener is removed because the\\n\\t\\t// content is reloaded, so make sure to install the handler after the iframe is loaded.\\n\\t\\t// https://github.com/chartjs/Chart.js/issues/3521\\n\\t\\thelpers.addEvent(iframe, 'load', function() {\\n\\t\\t\\thelpers.addEvent(iframe.contentWindow || iframe, 'resize', handler);\\n\\n\\t\\t\\t// The iframe size might have changed while loading, which can also\\n\\t\\t\\t// happen if the size has been changed while detached from the DOM.\\n\\t\\t\\thandler();\\n\\t\\t});\\n\\n\\t\\treturn iframe;\\n\\t}\\n\\n\\tfunction addResizeListener(node, listener, chart) {\\n\\t\\tvar stub = node._chartjs = {\\n\\t\\t\\tticking: false\\n\\t\\t};\\n\\n\\t\\t// Throttle the callback notification until the next animation frame.\\n\\t\\tvar notify = function() {\\n\\t\\t\\tif (!stub.ticking) {\\n\\t\\t\\t\\tstub.ticking = true;\\n\\t\\t\\t\\thelpers.requestAnimFrame.call(window, function() {\\n\\t\\t\\t\\t\\tif (stub.resizer) {\\n\\t\\t\\t\\t\\t\\tstub.ticking = false;\\n\\t\\t\\t\\t\\t\\treturn listener(createEvent('resize', chart));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\t// Let's keep track of this added iframe and thus avoid DOM query when removing it.\\n\\t\\tstub.resizer = createResizer(notify);\\n\\n\\t\\tnode.insertBefore(stub.resizer, node.firstChild);\\n\\t}\\n\\n\\tfunction removeResizeListener(node) {\\n\\t\\tif (!node || !node._chartjs) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar resizer = node._chartjs.resizer;\\n\\t\\tif (resizer) {\\n\\t\\t\\tresizer.parentNode.removeChild(resizer);\\n\\t\\t\\tnode._chartjs.resizer = null;\\n\\t\\t}\\n\\n\\t\\tdelete node._chartjs;\\n\\t}\\n\\n\\treturn {\\n\\t\\tacquireContext: function(item, config) {\\n\\t\\t\\tif (typeof item === 'string') {\\n\\t\\t\\t\\titem = document.getElementById(item);\\n\\t\\t\\t} else if (item.length) {\\n\\t\\t\\t\\t// Support for array based queries (such as jQuery)\\n\\t\\t\\t\\titem = item[0];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (item && item.canvas) {\\n\\t\\t\\t\\t// Support for any object associated to a canvas (including a context2d)\\n\\t\\t\\t\\titem = item.canvas;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (item instanceof HTMLCanvasElement) {\\n\\t\\t\\t\\t// To prevent canvas fingerprinting, some add-ons undefine the getContext\\n\\t\\t\\t\\t// method, for example: https://github.com/kkapsner/CanvasBlocker\\n\\t\\t\\t\\t// https://github.com/chartjs/Chart.js/issues/2807\\n\\t\\t\\t\\tvar context = item.getContext && item.getContext('2d');\\n\\t\\t\\t\\tif (context instanceof CanvasRenderingContext2D) {\\n\\t\\t\\t\\t\\tinitCanvas(item, config);\\n\\t\\t\\t\\t\\treturn context;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\t\\t},\\n\\n\\t\\treleaseContext: function(context) {\\n\\t\\t\\tvar canvas = context.canvas;\\n\\t\\t\\tif (!canvas._chartjs) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar initial = canvas._chartjs.initial;\\n\\t\\t\\t['height', 'width'].forEach(function(prop) {\\n\\t\\t\\t\\tvar value = initial[prop];\\n\\t\\t\\t\\tif (value === undefined || value === null) {\\n\\t\\t\\t\\t\\tcanvas.removeAttribute(prop);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcanvas.setAttribute(prop, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\thelpers.each(initial.style || {}, function(value, key) {\\n\\t\\t\\t\\tcanvas.style[key] = value;\\n\\t\\t\\t});\\n\\n\\t\\t\\t// The canvas render size might have been changed (and thus the state stack discarded),\\n\\t\\t\\t// we can't use save() and restore() to restore the initial state. So make sure that at\\n\\t\\t\\t// least the canvas context is reset to the default state by setting the canvas width.\\n\\t\\t\\t// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\\n\\t\\t\\tcanvas.width = canvas.width;\\n\\n\\t\\t\\tdelete canvas._chartjs;\\n\\t\\t},\\n\\n\\t\\taddEventListener: function(chart, type, listener) {\\n\\t\\t\\tvar canvas = chart.chart.canvas;\\n\\t\\t\\tif (type === 'resize') {\\n\\t\\t\\t\\t// Note: the resize event is not supported on all browsers.\\n\\t\\t\\t\\taddResizeListener(canvas.parentNode, listener, chart.chart);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar stub = listener._chartjs || (listener._chartjs = {});\\n\\t\\t\\tvar proxies = stub.proxies || (stub.proxies = {});\\n\\t\\t\\tvar proxy = proxies[chart.id + '_' + type] = function(event) {\\n\\t\\t\\t\\tlistener(fromNativeEvent(event, chart.chart));\\n\\t\\t\\t};\\n\\n\\t\\t\\thelpers.addEvent(canvas, type, proxy);\\n\\t\\t},\\n\\n\\t\\tremoveEventListener: function(chart, type, listener) {\\n\\t\\t\\tvar canvas = chart.chart.canvas;\\n\\t\\t\\tif (type === 'resize') {\\n\\t\\t\\t\\t// Note: the resize event is not supported on all browsers.\\n\\t\\t\\t\\tremoveResizeListener(canvas.parentNode, listener);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar stub = listener._chartjs || {};\\n\\t\\t\\tvar proxies = stub.proxies || {};\\n\\t\\t\\tvar proxy = proxies[chart.id + '_' + type];\\n\\t\\t\\tif (!proxy) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.removeEvent(canvas, type, proxy);\\n\\t\\t}\\n\\t};\\n};\\n\\n},{}],42:[function(require,module,exports){\\n'use strict';\\n\\n// By default, select the browser (DOM) platform.\\n// @TODO Make possible to select another platform at build time.\\nvar implementation = require(41);\\n\\nmodule.exports = function(Chart) {\\n\\t/**\\n\\t * @namespace Chart.platform\\n\\t * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\\n\\t * @since 2.4.0\\n\\t */\\n\\tChart.platform = {\\n\\t\\t/**\\n\\t\\t * Called at chart construction time, returns a context2d instance implementing\\n\\t\\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\\n\\t\\t * @param {*} item - The native item from which to acquire context (platform specific)\\n\\t\\t * @param {Object} options - The chart options\\n\\t\\t * @returns {CanvasRenderingContext2D} context2d instance\\n\\t\\t */\\n\\t\\tacquireContext: function() {},\\n\\n\\t\\t/**\\n\\t\\t * Called at chart destruction time, releases any resources associated to the context\\n\\t\\t * previously returned by the acquireContext() method.\\n\\t\\t * @param {CanvasRenderingContext2D} context - The context2d instance\\n\\t\\t * @returns {Boolean} true if the method succeeded, else false\\n\\t\\t */\\n\\t\\treleaseContext: function() {},\\n\\n\\t\\t/**\\n\\t\\t * Registers the specified listener on the given chart.\\n\\t\\t * @param {Chart} chart - Chart from which to listen for event\\n\\t\\t * @param {String} type - The ({@link IEvent}) type to listen for\\n\\t\\t * @param {Function} listener - Receives a notification (an object that implements\\n\\t\\t * the {@link IEvent} interface) when an event of the specified type occurs.\\n\\t\\t */\\n\\t\\taddEventListener: function() {},\\n\\n\\t\\t/**\\n\\t\\t * Removes the specified listener previously registered with addEventListener.\\n\\t\\t * @param {Chart} chart -Chart from which to remove the listener\\n\\t\\t * @param {String} type - The ({@link IEvent}) type to remove\\n\\t\\t * @param {Function} listener - The listener function to remove from the event target.\\n\\t\\t */\\n\\t\\tremoveEventListener: function() {}\\n\\t};\\n\\n\\t/**\\n\\t * @interface IPlatform\\n\\t * Allows abstracting platform dependencies away from the chart\\n\\t * @borrows Chart.platform.acquireContext as acquireContext\\n\\t * @borrows Chart.platform.releaseContext as releaseContext\\n\\t * @borrows Chart.platform.addEventListener as addEventListener\\n\\t * @borrows Chart.platform.removeEventListener as removeEventListener\\n\\t */\\n\\n\\t/**\\n\\t * @interface IEvent\\n\\t * @prop {String} type - The event type name, possible values are:\\n\\t * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',\\n\\t * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'\\n\\t * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')\\n\\t * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)\\n\\t * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)\\n\\t */\\n\\n\\tChart.helpers.extend(Chart.platform, implementation(Chart));\\n};\\n\\n},{\\\"41\\\":41}],43:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\t// Default config for a category scale\\n\\tvar defaultConfig = {\\n\\t\\tposition: 'bottom'\\n\\t};\\n\\n\\tvar DatasetScale = Chart.Scale.extend({\\n\\t\\t/**\\n\\t\\t* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\\n\\t\\t* else fall back to data.labels\\n\\t\\t* @private\\n\\t\\t*/\\n\\t\\tgetLabels: function() {\\n\\t\\t\\tvar data = this.chart.data;\\n\\t\\t\\treturn (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\\n\\t\\t},\\n\\t\\t// Implement this so that\\n\\t\\tdetermineDataLimits: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar labels = me.getLabels();\\n\\t\\t\\tme.minIndex = 0;\\n\\t\\t\\tme.maxIndex = labels.length - 1;\\n\\t\\t\\tvar findIndex;\\n\\n\\t\\t\\tif (me.options.ticks.min !== undefined) {\\n\\t\\t\\t\\t// user specified min value\\n\\t\\t\\t\\tfindIndex = helpers.indexOf(labels, me.options.ticks.min);\\n\\t\\t\\t\\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (me.options.ticks.max !== undefined) {\\n\\t\\t\\t\\t// user specified max value\\n\\t\\t\\t\\tfindIndex = helpers.indexOf(labels, me.options.ticks.max);\\n\\t\\t\\t\\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.min = labels[me.minIndex];\\n\\t\\t\\tme.max = labels[me.maxIndex];\\n\\t\\t},\\n\\n\\t\\tbuildTicks: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar labels = me.getLabels();\\n\\t\\t\\t// If we are viewing some subset of labels, slice the original array\\n\\t\\t\\tme.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\\n\\t\\t},\\n\\n\\t\\tgetLabelForIndex: function(index, datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar data = me.chart.data;\\n\\t\\t\\tvar isHorizontal = me.isHorizontal();\\n\\n\\t\\t\\tif (data.yLabels && !isHorizontal) {\\n\\t\\t\\t\\treturn me.getRightValue(data.datasets[datasetIndex].data[index]);\\n\\t\\t\\t}\\n\\t\\t\\treturn me.ticks[index - me.minIndex];\\n\\t\\t},\\n\\n\\t\\t// Used to get data value locations.  Value can either be an index or a numerical value\\n\\t\\tgetPixelForValue: function(value, index, datasetIndex, includeOffset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\t// 1 is added because we need the length but we have the indexes\\n\\t\\t\\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\\n\\n\\t\\t\\tif (value !== undefined && isNaN(index)) {\\n\\t\\t\\t\\tvar labels = me.getLabels();\\n\\t\\t\\t\\tvar idx = labels.indexOf(value);\\n\\t\\t\\t\\tindex = idx !== -1 ? idx : index;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\tvar valueWidth = me.width / offsetAmt;\\n\\t\\t\\t\\tvar widthOffset = (valueWidth * (index - me.minIndex));\\n\\n\\t\\t\\t\\tif (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {\\n\\t\\t\\t\\t\\twidthOffset += (valueWidth / 2);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn me.left + Math.round(widthOffset);\\n\\t\\t\\t}\\n\\t\\t\\tvar valueHeight = me.height / offsetAmt;\\n\\t\\t\\tvar heightOffset = (valueHeight * (index - me.minIndex));\\n\\n\\t\\t\\tif (me.options.gridLines.offsetGridLines && includeOffset) {\\n\\t\\t\\t\\theightOffset += (valueHeight / 2);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn me.top + Math.round(heightOffset);\\n\\t\\t},\\n\\t\\tgetPixelForTick: function(index, includeOffset) {\\n\\t\\t\\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);\\n\\t\\t},\\n\\t\\tgetValueForPixel: function(pixel) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar value;\\n\\t\\t\\tvar offsetAmt = Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\\n\\t\\t\\tvar horz = me.isHorizontal();\\n\\t\\t\\tvar valueDimension = (horz ? me.width : me.height) / offsetAmt;\\n\\n\\t\\t\\tpixel -= horz ? me.left : me.top;\\n\\n\\t\\t\\tif (me.options.gridLines.offsetGridLines) {\\n\\t\\t\\t\\tpixel -= (valueDimension / 2);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (pixel <= 0) {\\n\\t\\t\\t\\tvalue = 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue = Math.round(pixel / valueDimension);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value;\\n\\t\\t},\\n\\t\\tgetBasePixel: function() {\\n\\t\\t\\treturn this.bottom;\\n\\t\\t}\\n\\t});\\n\\n\\tChart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);\\n\\n};\\n\\n},{}],44:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tvar defaultConfig = {\\n\\t\\tposition: 'left',\\n\\t\\tticks: {\\n\\t\\t\\tcallback: Chart.Ticks.formatters.linear\\n\\t\\t}\\n\\t};\\n\\n\\tvar LinearScale = Chart.LinearScaleBase.extend({\\n\\t\\tdetermineDataLimits: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\tvar data = chart.data;\\n\\t\\t\\tvar datasets = data.datasets;\\n\\t\\t\\tvar isHorizontal = me.isHorizontal();\\n\\n\\t\\t\\tfunction IDMatches(meta) {\\n\\t\\t\\t\\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// First Calculate the range\\n\\t\\t\\tme.min = null;\\n\\t\\t\\tme.max = null;\\n\\n\\t\\t\\tvar hasStacks = opts.stacked;\\n\\t\\t\\tif (hasStacks === undefined) {\\n\\t\\t\\t\\thelpers.each(datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\t\\tif (hasStacks) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\t\\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\\n\\t\\t\\t\\t\\t\\tmeta.stack !== undefined) {\\n\\t\\t\\t\\t\\t\\thasStacks = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (opts.stacked || hasStacks) {\\n\\t\\t\\t\\tvar valuesPerStack = {};\\n\\n\\t\\t\\t\\thelpers.each(datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\t\\tvar key = [\\n\\t\\t\\t\\t\\t\\tmeta.type,\\n\\t\\t\\t\\t\\t\\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\\n\\t\\t\\t\\t\\t\\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\\n\\t\\t\\t\\t\\t\\tmeta.stack\\n\\t\\t\\t\\t\\t].join('.');\\n\\n\\t\\t\\t\\t\\tif (valuesPerStack[key] === undefined) {\\n\\t\\t\\t\\t\\t\\tvaluesPerStack[key] = {\\n\\t\\t\\t\\t\\t\\t\\tpositiveValues: [],\\n\\t\\t\\t\\t\\t\\t\\tnegativeValues: []\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Store these per type\\n\\t\\t\\t\\t\\tvar positiveValues = valuesPerStack[key].positiveValues;\\n\\t\\t\\t\\t\\tvar negativeValues = valuesPerStack[key].negativeValues;\\n\\n\\t\\t\\t\\t\\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\\n\\t\\t\\t\\t\\t\\thelpers.each(dataset.data, function(rawValue, index) {\\n\\t\\t\\t\\t\\t\\t\\tvar value = +me.getRightValue(rawValue);\\n\\t\\t\\t\\t\\t\\t\\tif (isNaN(value) || meta.data[index].hidden) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tpositiveValues[index] = positiveValues[index] || 0;\\n\\t\\t\\t\\t\\t\\t\\tnegativeValues[index] = negativeValues[index] || 0;\\n\\n\\t\\t\\t\\t\\t\\t\\tif (opts.relativePoints) {\\n\\t\\t\\t\\t\\t\\t\\t\\tpositiveValues[index] = 100;\\n\\t\\t\\t\\t\\t\\t\\t} else if (value < 0) {\\n\\t\\t\\t\\t\\t\\t\\t\\tnegativeValues[index] += value;\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tpositiveValues[index] += value;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\thelpers.each(valuesPerStack, function(valuesForType) {\\n\\t\\t\\t\\t\\tvar values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\\n\\t\\t\\t\\t\\tvar minVal = helpers.min(values);\\n\\t\\t\\t\\t\\tvar maxVal = helpers.max(values);\\n\\t\\t\\t\\t\\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\\n\\t\\t\\t\\t\\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thelpers.each(datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\t\\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\\n\\t\\t\\t\\t\\t\\thelpers.each(dataset.data, function(rawValue, index) {\\n\\t\\t\\t\\t\\t\\t\\tvar value = +me.getRightValue(rawValue);\\n\\t\\t\\t\\t\\t\\t\\tif (isNaN(value) || meta.data[index].hidden) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif (me.min === null) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.min = value;\\n\\t\\t\\t\\t\\t\\t\\t} else if (value < me.min) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.min = value;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif (me.max === null) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.max = value;\\n\\t\\t\\t\\t\\t\\t\\t} else if (value > me.max) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.max = value;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\\n\\t\\t\\tthis.handleTickRangeOptions();\\n\\t\\t},\\n\\t\\tgetTickLimit: function() {\\n\\t\\t\\tvar maxTicks;\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar tickOpts = me.options.ticks;\\n\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// The factor of 2 used to scale the font size has been experimentally determined.\\n\\t\\t\\t\\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart.defaults.global.defaultFontSize);\\n\\t\\t\\t\\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn maxTicks;\\n\\t\\t},\\n\\t\\t// Called after the ticks are built. We need\\n\\t\\thandleDirectionalChanges: function() {\\n\\t\\t\\tif (!this.isHorizontal()) {\\n\\t\\t\\t\\t// We are in a vertical orientation. The top value is the highest. So reverse the array\\n\\t\\t\\t\\tthis.ticks.reverse();\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tgetLabelForIndex: function(index, datasetIndex) {\\n\\t\\t\\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\\n\\t\\t},\\n\\t\\t// Utils\\n\\t\\tgetPixelForValue: function(value) {\\n\\t\\t\\t// This must be called after fit has been run so that\\n\\t\\t\\t// this.left, this.top, this.right, and this.bottom have been defined\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar start = me.start;\\n\\n\\t\\t\\tvar rightValue = +me.getRightValue(value);\\n\\t\\t\\tvar pixel;\\n\\t\\t\\tvar range = me.end - start;\\n\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\tpixel = me.left + (me.width / range * (rightValue - start));\\n\\t\\t\\t\\treturn Math.round(pixel);\\n\\t\\t\\t}\\n\\n\\t\\t\\tpixel = me.bottom - (me.height / range * (rightValue - start));\\n\\t\\t\\treturn Math.round(pixel);\\n\\t\\t},\\n\\t\\tgetValueForPixel: function(pixel) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar isHorizontal = me.isHorizontal();\\n\\t\\t\\tvar innerDimension = isHorizontal ? me.width : me.height;\\n\\t\\t\\tvar offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\\n\\t\\t\\treturn me.start + ((me.end - me.start) * offset);\\n\\t\\t},\\n\\t\\tgetPixelForTick: function(index) {\\n\\t\\t\\treturn this.getPixelForValue(this.ticksAsNumbers[index]);\\n\\t\\t}\\n\\t});\\n\\tChart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);\\n\\n};\\n\\n},{}],45:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers,\\n\\t\\tnoop = helpers.noop;\\n\\n\\tChart.LinearScaleBase = Chart.Scale.extend({\\n\\t\\thandleTickRangeOptions: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar tickOpts = opts.ticks;\\n\\n\\t\\t\\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\\n\\t\\t\\t// do nothing since that would make the chart weird. If the user really wants a weird chart\\n\\t\\t\\t// axis, they can manually override it\\n\\t\\t\\tif (tickOpts.beginAtZero) {\\n\\t\\t\\t\\tvar minSign = helpers.sign(me.min);\\n\\t\\t\\t\\tvar maxSign = helpers.sign(me.max);\\n\\n\\t\\t\\t\\tif (minSign < 0 && maxSign < 0) {\\n\\t\\t\\t\\t\\t// move the top up to 0\\n\\t\\t\\t\\t\\tme.max = 0;\\n\\t\\t\\t\\t} else if (minSign > 0 && maxSign > 0) {\\n\\t\\t\\t\\t\\t// move the bottom down to 0\\n\\t\\t\\t\\t\\tme.min = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (tickOpts.min !== undefined) {\\n\\t\\t\\t\\tme.min = tickOpts.min;\\n\\t\\t\\t} else if (tickOpts.suggestedMin !== undefined) {\\n\\t\\t\\t\\tme.min = Math.min(me.min, tickOpts.suggestedMin);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (tickOpts.max !== undefined) {\\n\\t\\t\\t\\tme.max = tickOpts.max;\\n\\t\\t\\t} else if (tickOpts.suggestedMax !== undefined) {\\n\\t\\t\\t\\tme.max = Math.max(me.max, tickOpts.suggestedMax);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (me.min === me.max) {\\n\\t\\t\\t\\tme.max++;\\n\\n\\t\\t\\t\\tif (!tickOpts.beginAtZero) {\\n\\t\\t\\t\\t\\tme.min--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tgetTickLimit: noop,\\n\\t\\thandleDirectionalChanges: noop,\\n\\n\\t\\tbuildTicks: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar tickOpts = opts.ticks;\\n\\n\\t\\t\\t// Figure out what the max number of ticks we can support it is based on the size of\\n\\t\\t\\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\\n\\t\\t\\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\\n\\t\\t\\t// the graph. Make sure we always have at least 2 ticks\\n\\t\\t\\tvar maxTicks = me.getTickLimit();\\n\\t\\t\\tmaxTicks = Math.max(2, maxTicks);\\n\\n\\t\\t\\tvar numericGeneratorOptions = {\\n\\t\\t\\t\\tmaxTicks: maxTicks,\\n\\t\\t\\t\\tmin: tickOpts.min,\\n\\t\\t\\t\\tmax: tickOpts.max,\\n\\t\\t\\t\\tstepSize: helpers.getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\\n\\t\\t\\t};\\n\\t\\t\\tvar ticks = me.ticks = Chart.Ticks.generators.linear(numericGeneratorOptions, me);\\n\\n\\t\\t\\tme.handleDirectionalChanges();\\n\\n\\t\\t\\t// At this point, we need to update our max and min given the tick values since we have expanded the\\n\\t\\t\\t// range of the scale\\n\\t\\t\\tme.max = helpers.max(ticks);\\n\\t\\t\\tme.min = helpers.min(ticks);\\n\\n\\t\\t\\tif (tickOpts.reverse) {\\n\\t\\t\\t\\tticks.reverse();\\n\\n\\t\\t\\t\\tme.start = me.max;\\n\\t\\t\\t\\tme.end = me.min;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.start = me.min;\\n\\t\\t\\t\\tme.end = me.max;\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tconvertTicksToLabels: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tme.ticksAsNumbers = me.ticks.slice();\\n\\t\\t\\tme.zeroLineIndex = me.ticks.indexOf(0);\\n\\n\\t\\t\\tChart.Scale.prototype.convertTicksToLabels.call(me);\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],46:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tvar defaultConfig = {\\n\\t\\tposition: 'left',\\n\\n\\t\\t// label settings\\n\\t\\tticks: {\\n\\t\\t\\tcallback: Chart.Ticks.formatters.logarithmic\\n\\t\\t}\\n\\t};\\n\\n\\tvar LogarithmicScale = Chart.Scale.extend({\\n\\t\\tdetermineDataLimits: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar tickOpts = opts.ticks;\\n\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\tvar data = chart.data;\\n\\t\\t\\tvar datasets = data.datasets;\\n\\t\\t\\tvar getValueOrDefault = helpers.getValueOrDefault;\\n\\t\\t\\tvar isHorizontal = me.isHorizontal();\\n\\t\\t\\tfunction IDMatches(meta) {\\n\\t\\t\\t\\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Calculate Range\\n\\t\\t\\tme.min = null;\\n\\t\\t\\tme.max = null;\\n\\t\\t\\tme.minNotZero = null;\\n\\n\\t\\t\\tvar hasStacks = opts.stacked;\\n\\t\\t\\tif (hasStacks === undefined) {\\n\\t\\t\\t\\thelpers.each(datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\t\\tif (hasStacks) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\t\\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\\n\\t\\t\\t\\t\\t\\tmeta.stack !== undefined) {\\n\\t\\t\\t\\t\\t\\thasStacks = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (opts.stacked || hasStacks) {\\n\\t\\t\\t\\tvar valuesPerStack = {};\\n\\n\\t\\t\\t\\thelpers.each(datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\t\\tvar key = [\\n\\t\\t\\t\\t\\t\\tmeta.type,\\n\\t\\t\\t\\t\\t\\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\\n\\t\\t\\t\\t\\t\\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\\n\\t\\t\\t\\t\\t\\tmeta.stack\\n\\t\\t\\t\\t\\t].join('.');\\n\\n\\t\\t\\t\\t\\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\\n\\t\\t\\t\\t\\t\\tif (valuesPerStack[key] === undefined) {\\n\\t\\t\\t\\t\\t\\t\\tvaluesPerStack[key] = [];\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\thelpers.each(dataset.data, function(rawValue, index) {\\n\\t\\t\\t\\t\\t\\t\\tvar values = valuesPerStack[key];\\n\\t\\t\\t\\t\\t\\t\\tvar value = +me.getRightValue(rawValue);\\n\\t\\t\\t\\t\\t\\t\\tif (isNaN(value) || meta.data[index].hidden) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tvalues[index] = values[index] || 0;\\n\\n\\t\\t\\t\\t\\t\\t\\tif (opts.relativePoints) {\\n\\t\\t\\t\\t\\t\\t\\t\\tvalues[index] = 100;\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t// Don't need to split positive and negative since the log scale can't handle a 0 crossing\\n\\t\\t\\t\\t\\t\\t\\t\\tvalues[index] += value;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\thelpers.each(valuesPerStack, function(valuesForType) {\\n\\t\\t\\t\\t\\tvar minVal = helpers.min(valuesForType);\\n\\t\\t\\t\\t\\tvar maxVal = helpers.max(valuesForType);\\n\\t\\t\\t\\t\\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\\n\\t\\t\\t\\t\\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thelpers.each(datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\t\\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\\n\\t\\t\\t\\t\\t\\thelpers.each(dataset.data, function(rawValue, index) {\\n\\t\\t\\t\\t\\t\\t\\tvar value = +me.getRightValue(rawValue);\\n\\t\\t\\t\\t\\t\\t\\tif (isNaN(value) || meta.data[index].hidden) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif (me.min === null) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.min = value;\\n\\t\\t\\t\\t\\t\\t\\t} else if (value < me.min) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.min = value;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif (me.max === null) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.max = value;\\n\\t\\t\\t\\t\\t\\t\\t} else if (value > me.max) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.max = value;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.minNotZero = value;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.min = getValueOrDefault(tickOpts.min, me.min);\\n\\t\\t\\tme.max = getValueOrDefault(tickOpts.max, me.max);\\n\\n\\t\\t\\tif (me.min === me.max) {\\n\\t\\t\\t\\tif (me.min !== 0 && me.min !== null) {\\n\\t\\t\\t\\t\\tme.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\\n\\t\\t\\t\\t\\tme.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tme.min = 1;\\n\\t\\t\\t\\t\\tme.max = 10;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tbuildTicks: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar tickOpts = opts.ticks;\\n\\n\\t\\t\\tvar generationOptions = {\\n\\t\\t\\t\\tmin: tickOpts.min,\\n\\t\\t\\t\\tmax: tickOpts.max\\n\\t\\t\\t};\\n\\t\\t\\tvar ticks = me.ticks = Chart.Ticks.generators.logarithmic(generationOptions, me);\\n\\n\\t\\t\\tif (!me.isHorizontal()) {\\n\\t\\t\\t\\t// We are in a vertical orientation. The top value is the highest. So reverse the array\\n\\t\\t\\t\\tticks.reverse();\\n\\t\\t\\t}\\n\\n\\t\\t\\t// At this point, we need to update our max and min given the tick values since we have expanded the\\n\\t\\t\\t// range of the scale\\n\\t\\t\\tme.max = helpers.max(ticks);\\n\\t\\t\\tme.min = helpers.min(ticks);\\n\\n\\t\\t\\tif (tickOpts.reverse) {\\n\\t\\t\\t\\tticks.reverse();\\n\\n\\t\\t\\t\\tme.start = me.max;\\n\\t\\t\\t\\tme.end = me.min;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.start = me.min;\\n\\t\\t\\t\\tme.end = me.max;\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tconvertTicksToLabels: function() {\\n\\t\\t\\tthis.tickValues = this.ticks.slice();\\n\\n\\t\\t\\tChart.Scale.prototype.convertTicksToLabels.call(this);\\n\\t\\t},\\n\\t\\t// Get the correct tooltip label\\n\\t\\tgetLabelForIndex: function(index, datasetIndex) {\\n\\t\\t\\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\\n\\t\\t},\\n\\t\\tgetPixelForTick: function(index) {\\n\\t\\t\\treturn this.getPixelForValue(this.tickValues[index]);\\n\\t\\t},\\n\\t\\tgetPixelForValue: function(value) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar innerDimension;\\n\\t\\t\\tvar pixel;\\n\\n\\t\\t\\tvar start = me.start;\\n\\t\\t\\tvar newVal = +me.getRightValue(value);\\n\\t\\t\\tvar range;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar tickOpts = opts.ticks;\\n\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\trange = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0\\n\\t\\t\\t\\tif (newVal === 0) {\\n\\t\\t\\t\\t\\tpixel = me.left;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tinnerDimension = me.width;\\n\\t\\t\\t\\t\\tpixel = me.left + (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Bottom - top since pixels increase downward on a screen\\n\\t\\t\\t\\tinnerDimension = me.height;\\n\\t\\t\\t\\tif (start === 0 && !tickOpts.reverse) {\\n\\t\\t\\t\\t\\trange = helpers.log10(me.end) - helpers.log10(me.minNotZero);\\n\\t\\t\\t\\t\\tif (newVal === start) {\\n\\t\\t\\t\\t\\t\\tpixel = me.bottom;\\n\\t\\t\\t\\t\\t} else if (newVal === me.minNotZero) {\\n\\t\\t\\t\\t\\t\\tpixel = me.bottom - innerDimension * 0.02;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tpixel = me.bottom - innerDimension * 0.02 - (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if (me.end === 0 && tickOpts.reverse) {\\n\\t\\t\\t\\t\\trange = helpers.log10(me.start) - helpers.log10(me.minNotZero);\\n\\t\\t\\t\\t\\tif (newVal === me.end) {\\n\\t\\t\\t\\t\\t\\tpixel = me.top;\\n\\t\\t\\t\\t\\t} else if (newVal === me.minNotZero) {\\n\\t\\t\\t\\t\\t\\tpixel = me.top + innerDimension * 0.02;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tpixel = me.top + innerDimension * 0.02 + (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\trange = helpers.log10(me.end) - helpers.log10(start);\\n\\t\\t\\t\\t\\tinnerDimension = me.height;\\n\\t\\t\\t\\t\\tpixel = me.bottom - (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn pixel;\\n\\t\\t},\\n\\t\\tgetValueForPixel: function(pixel) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar range = helpers.log10(me.end) - helpers.log10(me.start);\\n\\t\\t\\tvar value, innerDimension;\\n\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\tinnerDimension = me.width;\\n\\t\\t\\t\\tvalue = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);\\n\\t\\t\\t} else {  // todo: if start === 0\\n\\t\\t\\t\\tinnerDimension = me.height;\\n\\t\\t\\t\\tvalue = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;\\n\\t\\t\\t}\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\t});\\n\\tChart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\\n\\n};\\n\\n},{}],47:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\tvar globalDefaults = Chart.defaults.global;\\n\\n\\tvar defaultConfig = {\\n\\t\\tdisplay: true,\\n\\n\\t\\t// Boolean - Whether to animate scaling the chart from the centre\\n\\t\\tanimate: true,\\n\\t\\tlineArc: false,\\n\\t\\tposition: 'chartArea',\\n\\n\\t\\tangleLines: {\\n\\t\\t\\tdisplay: true,\\n\\t\\t\\tcolor: 'rgba(0, 0, 0, 0.1)',\\n\\t\\t\\tlineWidth: 1\\n\\t\\t},\\n\\n\\t\\t// label settings\\n\\t\\tticks: {\\n\\t\\t\\t// Boolean - Show a backdrop to the scale label\\n\\t\\t\\tshowLabelBackdrop: true,\\n\\n\\t\\t\\t// String - The colour of the label backdrop\\n\\t\\t\\tbackdropColor: 'rgba(255,255,255,0.75)',\\n\\n\\t\\t\\t// Number - The backdrop padding above & below the label in pixels\\n\\t\\t\\tbackdropPaddingY: 2,\\n\\n\\t\\t\\t// Number - The backdrop padding to the side of the label in pixels\\n\\t\\t\\tbackdropPaddingX: 2,\\n\\n\\t\\t\\tcallback: Chart.Ticks.formatters.linear\\n\\t\\t},\\n\\n\\t\\tpointLabels: {\\n\\t\\t\\t// Number - Point label font size in pixels\\n\\t\\t\\tfontSize: 10,\\n\\n\\t\\t\\t// Function - Used to convert point labels\\n\\t\\t\\tcallback: function(label) {\\n\\t\\t\\t\\treturn label;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tfunction getValueCount(scale) {\\n\\t\\treturn !scale.options.lineArc ? scale.chart.data.labels.length : 0;\\n\\t}\\n\\n\\tfunction getPointLabelFontOptions(scale) {\\n\\t\\tvar pointLabelOptions = scale.options.pointLabels;\\n\\t\\tvar fontSize = helpers.getValueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);\\n\\t\\tvar fontStyle = helpers.getValueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);\\n\\t\\tvar fontFamily = helpers.getValueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);\\n\\t\\tvar font = helpers.fontString(fontSize, fontStyle, fontFamily);\\n\\n\\t\\treturn {\\n\\t\\t\\tsize: fontSize,\\n\\t\\t\\tstyle: fontStyle,\\n\\t\\t\\tfamily: fontFamily,\\n\\t\\t\\tfont: font\\n\\t\\t};\\n\\t}\\n\\n\\tfunction measureLabelSize(ctx, fontSize, label) {\\n\\t\\tif (helpers.isArray(label)) {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tw: helpers.longestText(ctx, ctx.font, label),\\n\\t\\t\\t\\th: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tw: ctx.measureText(label).width,\\n\\t\\t\\th: fontSize\\n\\t\\t};\\n\\t}\\n\\n\\tfunction determineLimits(angle, pos, size, min, max) {\\n\\t\\tif (angle === min || angle === max) {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tstart: pos - (size / 2),\\n\\t\\t\\t\\tend: pos + (size / 2)\\n\\t\\t\\t};\\n\\t\\t} else if (angle < min || angle > max) {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tstart: pos - size - 5,\\n\\t\\t\\t\\tend: pos\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tstart: pos,\\n\\t\\t\\tend: pos + size + 5\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Helper function to fit a radial linear scale with point labels\\n\\t */\\n\\tfunction fitWithPointLabels(scale) {\\n\\t\\t/*\\n\\t\\t * Right, this is really confusing and there is a lot of maths going on here\\n\\t\\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\\n\\t\\t *\\n\\t\\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\\n\\t\\t *\\n\\t\\t * Solution:\\n\\t\\t *\\n\\t\\t * We assume the radius of the polygon is half the size of the canvas at first\\n\\t\\t * at each index we check if the text overlaps.\\n\\t\\t *\\n\\t\\t * Where it does, we store that angle and that index.\\n\\t\\t *\\n\\t\\t * After finding the largest index and angle we calculate how much we need to remove\\n\\t\\t * from the shape radius to move the point inwards by that x.\\n\\t\\t *\\n\\t\\t * We average the left and right distances to get the maximum shape radius that can fit in the box\\n\\t\\t * along with labels.\\n\\t\\t *\\n\\t\\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\\n\\t\\t * on each side, removing that from the size, halving it and adding the left x protrusion width.\\n\\t\\t *\\n\\t\\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\\n\\t\\t * and position it in the most space efficient manner\\n\\t\\t *\\n\\t\\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\\n\\t\\t */\\n\\n\\t\\tvar plFont = getPointLabelFontOptions(scale);\\n\\n\\t\\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\\n\\t\\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\\n\\t\\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\\n\\t\\tvar furthestLimits = {\\n\\t\\t\\tl: scale.width,\\n\\t\\t\\tr: 0,\\n\\t\\t\\tt: scale.height,\\n\\t\\t\\tb: 0\\n\\t\\t};\\n\\t\\tvar furthestAngles = {};\\n\\t\\tvar i;\\n\\t\\tvar textSize;\\n\\t\\tvar pointPosition;\\n\\n\\t\\tscale.ctx.font = plFont.font;\\n\\t\\tscale._pointLabelSizes = [];\\n\\n\\t\\tvar valueCount = getValueCount(scale);\\n\\t\\tfor (i = 0; i < valueCount; i++) {\\n\\t\\t\\tpointPosition = scale.getPointPosition(i, largestPossibleRadius);\\n\\t\\t\\ttextSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');\\n\\t\\t\\tscale._pointLabelSizes[i] = textSize;\\n\\n\\t\\t\\t// Add quarter circle to make degree 0 mean top of circle\\n\\t\\t\\tvar angleRadians = scale.getIndexAngle(i);\\n\\t\\t\\tvar angle = helpers.toDegrees(angleRadians) % 360;\\n\\t\\t\\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\\n\\t\\t\\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\\n\\n\\t\\t\\tif (hLimits.start < furthestLimits.l) {\\n\\t\\t\\t\\tfurthestLimits.l = hLimits.start;\\n\\t\\t\\t\\tfurthestAngles.l = angleRadians;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (hLimits.end > furthestLimits.r) {\\n\\t\\t\\t\\tfurthestLimits.r = hLimits.end;\\n\\t\\t\\t\\tfurthestAngles.r = angleRadians;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (vLimits.start < furthestLimits.t) {\\n\\t\\t\\t\\tfurthestLimits.t = vLimits.start;\\n\\t\\t\\t\\tfurthestAngles.t = angleRadians;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (vLimits.end > furthestLimits.b) {\\n\\t\\t\\t\\tfurthestLimits.b = vLimits.end;\\n\\t\\t\\t\\tfurthestAngles.b = angleRadians;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tscale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);\\n\\t}\\n\\n\\t/**\\n\\t * Helper function to fit a radial linear scale with no point labels\\n\\t */\\n\\tfunction fit(scale) {\\n\\t\\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\\n\\t\\tscale.drawingArea = Math.round(largestPossibleRadius);\\n\\t\\tscale.setCenterPoint(0, 0, 0, 0);\\n\\t}\\n\\n\\tfunction getTextAlignForAngle(angle) {\\n\\t\\tif (angle === 0 || angle === 180) {\\n\\t\\t\\treturn 'center';\\n\\t\\t} else if (angle < 180) {\\n\\t\\t\\treturn 'left';\\n\\t\\t}\\n\\n\\t\\treturn 'right';\\n\\t}\\n\\n\\tfunction fillText(ctx, text, position, fontSize) {\\n\\t\\tif (helpers.isArray(text)) {\\n\\t\\t\\tvar y = position.y;\\n\\t\\t\\tvar spacing = 1.5 * fontSize;\\n\\n\\t\\t\\tfor (var i = 0; i < text.length; ++i) {\\n\\t\\t\\t\\tctx.fillText(text[i], position.x, y);\\n\\t\\t\\t\\ty+= spacing;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tctx.fillText(text, position.x, position.y);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction adjustPointPositionForLabelHeight(angle, textSize, position) {\\n\\t\\tif (angle === 90 || angle === 270) {\\n\\t\\t\\tposition.y -= (textSize.h / 2);\\n\\t\\t} else if (angle > 270 || angle < 90) {\\n\\t\\t\\tposition.y -= textSize.h;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction drawPointLabels(scale) {\\n\\t\\tvar ctx = scale.ctx;\\n\\t\\tvar getValueOrDefault = helpers.getValueOrDefault;\\n\\t\\tvar opts = scale.options;\\n\\t\\tvar angleLineOpts = opts.angleLines;\\n\\t\\tvar pointLabelOpts = opts.pointLabels;\\n\\n\\t\\tctx.lineWidth = angleLineOpts.lineWidth;\\n\\t\\tctx.strokeStyle = angleLineOpts.color;\\n\\n\\t\\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.reverse ? scale.min : scale.max);\\n\\n\\t\\t// Point Label Font\\n\\t\\tvar plFont = getPointLabelFontOptions(scale);\\n\\n\\t\\tctx.textBaseline = 'top';\\n\\n\\t\\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\\n\\t\\t\\tif (angleLineOpts.display) {\\n\\t\\t\\t\\tvar outerPosition = scale.getPointPosition(i, outerDistance);\\n\\t\\t\\t\\tctx.beginPath();\\n\\t\\t\\t\\tctx.moveTo(scale.xCenter, scale.yCenter);\\n\\t\\t\\t\\tctx.lineTo(outerPosition.x, outerPosition.y);\\n\\t\\t\\t\\tctx.stroke();\\n\\t\\t\\t\\tctx.closePath();\\n\\t\\t\\t}\\n\\t\\t\\t// Extra 3px out for some label spacing\\n\\t\\t\\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);\\n\\n\\t\\t\\t// Keep this in loop since we may support array properties here\\n\\t\\t\\tvar pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);\\n\\t\\t\\tctx.font = plFont.font;\\n\\t\\t\\tctx.fillStyle = pointLabelFontColor;\\n\\n\\t\\t\\tvar angleRadians = scale.getIndexAngle(i);\\n\\t\\t\\tvar angle = helpers.toDegrees(angleRadians);\\n\\t\\t\\tctx.textAlign = getTextAlignForAngle(angle);\\n\\t\\t\\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\\n\\t\\t\\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\\n\\t\\tvar ctx = scale.ctx;\\n\\t\\tctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);\\n\\t\\tctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\\n\\n\\t\\tif (scale.options.lineArc) {\\n\\t\\t\\t// Draw circular arcs between the points\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tctx.stroke();\\n\\t\\t} else {\\n\\t\\t\\t// Draw straight lines connecting each index\\n\\t\\t\\tvar valueCount = getValueCount(scale);\\n\\n\\t\\t\\tif (valueCount === 0) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tvar pointPosition = scale.getPointPosition(0, radius);\\n\\t\\t\\tctx.moveTo(pointPosition.x, pointPosition.y);\\n\\n\\t\\t\\tfor (var i = 1; i < valueCount; i++) {\\n\\t\\t\\t\\tpointPosition = scale.getPointPosition(i, radius);\\n\\t\\t\\t\\tctx.lineTo(pointPosition.x, pointPosition.y);\\n\\t\\t\\t}\\n\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tctx.stroke();\\n\\t\\t}\\n\\t}\\n\\n\\tfunction numberOrZero(param) {\\n\\t\\treturn helpers.isNumber(param) ? param : 0;\\n\\t}\\n\\n\\tvar LinearRadialScale = Chart.LinearScaleBase.extend({\\n\\t\\tsetDimensions: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar tickOpts = opts.ticks;\\n\\t\\t\\t// Set the unconstrained dimension before label rotation\\n\\t\\t\\tme.width = me.maxWidth;\\n\\t\\t\\tme.height = me.maxHeight;\\n\\t\\t\\tme.xCenter = Math.round(me.width / 2);\\n\\t\\t\\tme.yCenter = Math.round(me.height / 2);\\n\\n\\t\\t\\tvar minSize = helpers.min([me.height, me.width]);\\n\\t\\t\\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\\n\\t\\t\\tme.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);\\n\\t\\t},\\n\\t\\tdetermineDataLimits: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\tvar min = Number.POSITIVE_INFINITY;\\n\\t\\t\\tvar max = Number.NEGATIVE_INFINITY;\\n\\n\\t\\t\\thelpers.each(chart.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tif (chart.isDatasetVisible(datasetIndex)) {\\n\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(datasetIndex);\\n\\n\\t\\t\\t\\t\\thelpers.each(dataset.data, function(rawValue, index) {\\n\\t\\t\\t\\t\\t\\tvar value = +me.getRightValue(rawValue);\\n\\t\\t\\t\\t\\t\\tif (isNaN(value) || meta.data[index].hidden) {\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tmin = Math.min(value, min);\\n\\t\\t\\t\\t\\t\\tmax = Math.max(value, max);\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tme.min = (min === Number.POSITIVE_INFINITY ? 0 : min);\\n\\t\\t\\tme.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);\\n\\n\\t\\t\\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\\n\\t\\t\\tme.handleTickRangeOptions();\\n\\t\\t},\\n\\t\\tgetTickLimit: function() {\\n\\t\\t\\tvar tickOpts = this.options.ticks;\\n\\t\\t\\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\\n\\t\\t\\treturn Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\\n\\t\\t},\\n\\t\\tconvertTicksToLabels: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tChart.LinearScaleBase.prototype.convertTicksToLabels.call(me);\\n\\n\\t\\t\\t// Point labels\\n\\t\\t\\tme.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\\n\\t\\t},\\n\\t\\tgetLabelForIndex: function(index, datasetIndex) {\\n\\t\\t\\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\\n\\t\\t},\\n\\t\\tfit: function() {\\n\\t\\t\\tif (this.options.lineArc) {\\n\\t\\t\\t\\tfit(this);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfitWithPointLabels(this);\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\t/**\\n\\t\\t * Set radius reductions and determine new radius and center point\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\\n\\t\\t\\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\\n\\t\\t\\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\\n\\t\\t\\tvar radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);\\n\\n\\t\\t\\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\\n\\t\\t\\tradiusReductionRight = numberOrZero(radiusReductionRight);\\n\\t\\t\\tradiusReductionTop = numberOrZero(radiusReductionTop);\\n\\t\\t\\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\\n\\n\\t\\t\\tme.drawingArea = Math.min(\\n\\t\\t\\t\\tMath.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\\n\\t\\t\\t\\tMath.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\\n\\t\\t\\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\\n\\t\\t},\\n\\t\\tsetCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar maxRight = me.width - rightMovement - me.drawingArea,\\n\\t\\t\\t\\tmaxLeft = leftMovement + me.drawingArea,\\n\\t\\t\\t\\tmaxTop = topMovement + me.drawingArea,\\n\\t\\t\\t\\tmaxBottom = me.height - bottomMovement - me.drawingArea;\\n\\n\\t\\t\\tme.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);\\n\\t\\t\\tme.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);\\n\\t\\t},\\n\\n\\t\\tgetIndexAngle: function(index) {\\n\\t\\t\\tvar angleMultiplier = (Math.PI * 2) / getValueCount(this);\\n\\t\\t\\tvar startAngle = this.chart.options && this.chart.options.startAngle ?\\n\\t\\t\\t\\tthis.chart.options.startAngle :\\n\\t\\t\\t\\t0;\\n\\n\\t\\t\\tvar startAngleRadians = startAngle * Math.PI * 2 / 360;\\n\\n\\t\\t\\t// Start from the top instead of right, so remove a quarter of the circle\\n\\t\\t\\treturn index * angleMultiplier + startAngleRadians;\\n\\t\\t},\\n\\t\\tgetDistanceFromCenterForValue: function(value) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tif (value === null) {\\n\\t\\t\\t\\treturn 0; // null always in center\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Take into account half font size + the yPadding of the top value\\n\\t\\t\\tvar scalingFactor = me.drawingArea / (me.max - me.min);\\n\\t\\t\\tif (me.options.reverse) {\\n\\t\\t\\t\\treturn (me.max - value) * scalingFactor;\\n\\t\\t\\t}\\n\\t\\t\\treturn (value - me.min) * scalingFactor;\\n\\t\\t},\\n\\t\\tgetPointPosition: function(index, distanceFromCenter) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar thisAngle = me.getIndexAngle(index) - (Math.PI / 2);\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\\n\\t\\t\\t\\ty: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tgetPointPositionForValue: function(index, value) {\\n\\t\\t\\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\\n\\t\\t},\\n\\n\\t\\tgetBasePosition: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar min = me.min;\\n\\t\\t\\tvar max = me.max;\\n\\n\\t\\t\\treturn me.getPointPositionForValue(0,\\n\\t\\t\\t\\tme.beginAtZero? 0:\\n\\t\\t\\t\\tmin < 0 && max < 0? max :\\n\\t\\t\\t\\tmin > 0 && max > 0? min :\\n\\t\\t\\t\\t0);\\n\\t\\t},\\n\\n\\t\\tdraw: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar gridLineOpts = opts.gridLines;\\n\\t\\t\\tvar tickOpts = opts.ticks;\\n\\t\\t\\tvar getValueOrDefault = helpers.getValueOrDefault;\\n\\n\\t\\t\\tif (opts.display) {\\n\\t\\t\\t\\tvar ctx = me.ctx;\\n\\n\\t\\t\\t\\t// Tick Font\\n\\t\\t\\t\\tvar tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\\n\\t\\t\\t\\tvar tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\\n\\t\\t\\t\\tvar tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\\n\\t\\t\\t\\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\\n\\n\\t\\t\\t\\thelpers.each(me.ticks, function(label, index) {\\n\\t\\t\\t\\t\\t// Don't draw a centre value (if it is minimum)\\n\\t\\t\\t\\t\\tif (index > 0 || opts.reverse) {\\n\\t\\t\\t\\t\\t\\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\\n\\t\\t\\t\\t\\t\\tvar yHeight = me.yCenter - yCenterOffset;\\n\\n\\t\\t\\t\\t\\t\\t// Draw circular lines around the scale\\n\\t\\t\\t\\t\\t\\tif (gridLineOpts.display && index !== 0) {\\n\\t\\t\\t\\t\\t\\t\\tdrawRadiusLine(me, gridLineOpts, yCenterOffset, index);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif (tickOpts.display) {\\n\\t\\t\\t\\t\\t\\t\\tvar tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\\n\\t\\t\\t\\t\\t\\t\\tctx.font = tickLabelFont;\\n\\n\\t\\t\\t\\t\\t\\t\\tif (tickOpts.showLabelBackdrop) {\\n\\t\\t\\t\\t\\t\\t\\t\\tvar labelWidth = ctx.measureText(label).width;\\n\\t\\t\\t\\t\\t\\t\\t\\tctx.fillStyle = tickOpts.backdropColor;\\n\\t\\t\\t\\t\\t\\t\\t\\tctx.fillRect(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tme.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tyHeight - tickFontSize / 2 - tickOpts.backdropPaddingY,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tlabelWidth + tickOpts.backdropPaddingX * 2,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttickFontSize + tickOpts.backdropPaddingY * 2\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tctx.textAlign = 'center';\\n\\t\\t\\t\\t\\t\\t\\tctx.textBaseline = 'middle';\\n\\t\\t\\t\\t\\t\\t\\tctx.fillStyle = tickFontColor;\\n\\t\\t\\t\\t\\t\\t\\tctx.fillText(label, me.xCenter, yHeight);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tif (!opts.lineArc) {\\n\\t\\t\\t\\t\\tdrawPointLabels(me);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n\\tChart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\\n\\n};\\n\\n},{}],48:[function(require,module,exports){\\n/* global window: false */\\n'use strict';\\n\\nvar moment = require(1);\\nmoment = typeof(moment) === 'function' ? moment : window.moment;\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\tvar time = {\\n\\t\\tunits: [{\\n\\t\\t\\tname: 'millisecond',\\n\\t\\t\\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\\n\\t\\t}, {\\n\\t\\t\\tname: 'second',\\n\\t\\t\\tsteps: [1, 2, 5, 10, 30]\\n\\t\\t}, {\\n\\t\\t\\tname: 'minute',\\n\\t\\t\\tsteps: [1, 2, 5, 10, 30]\\n\\t\\t}, {\\n\\t\\t\\tname: 'hour',\\n\\t\\t\\tsteps: [1, 2, 3, 6, 12]\\n\\t\\t}, {\\n\\t\\t\\tname: 'day',\\n\\t\\t\\tsteps: [1, 2, 5]\\n\\t\\t}, {\\n\\t\\t\\tname: 'week',\\n\\t\\t\\tmaxStep: 4\\n\\t\\t}, {\\n\\t\\t\\tname: 'month',\\n\\t\\t\\tmaxStep: 3\\n\\t\\t}, {\\n\\t\\t\\tname: 'quarter',\\n\\t\\t\\tmaxStep: 4\\n\\t\\t}, {\\n\\t\\t\\tname: 'year',\\n\\t\\t\\tmaxStep: false\\n\\t\\t}]\\n\\t};\\n\\n\\tvar defaultConfig = {\\n\\t\\tposition: 'bottom',\\n\\n\\t\\ttime: {\\n\\t\\t\\tparser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\\n\\t\\t\\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\\n\\t\\t\\tunit: false, // false == automatic or override with week, month, year, etc.\\n\\t\\t\\tround: false, // none, or override with week, month, year, etc.\\n\\t\\t\\tdisplayFormat: false, // DEPRECATED\\n\\t\\t\\tisoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\\n\\t\\t\\tminUnit: 'millisecond',\\n\\n\\t\\t\\t// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\\n\\t\\t\\tdisplayFormats: {\\n\\t\\t\\t\\tmillisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\\n\\t\\t\\t\\tsecond: 'h:mm:ss a', // 11:20:01 AM\\n\\t\\t\\t\\tminute: 'h:mm:ss a', // 11:20:01 AM\\n\\t\\t\\t\\thour: 'MMM D, hA', // Sept 4, 5PM\\n\\t\\t\\t\\tday: 'll', // Sep 4 2015\\n\\t\\t\\t\\tweek: 'll', // Week 46, or maybe \\\"[W]WW - YYYY\\\" ?\\n\\t\\t\\t\\tmonth: 'MMM YYYY', // Sept 2015\\n\\t\\t\\t\\tquarter: '[Q]Q - YYYY', // Q3\\n\\t\\t\\t\\tyear: 'YYYY' // 2015\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tticks: {\\n\\t\\t\\tautoSkip: false\\n\\t\\t}\\n\\t};\\n\\n\\tvar TimeScale = Chart.Scale.extend({\\n\\t\\tinitialize: function() {\\n\\t\\t\\tif (!moment) {\\n\\t\\t\\t\\tthrow new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\\n\\t\\t\\t}\\n\\n\\t\\t\\tChart.Scale.prototype.initialize.call(this);\\n\\t\\t},\\n\\t\\tgetLabelMoment: function(datasetIndex, index) {\\n\\t\\t\\tif (datasetIndex === null || index === null) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (typeof this.labelMoments[datasetIndex] !== 'undefined') {\\n\\t\\t\\t\\treturn this.labelMoments[datasetIndex][index];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\t\\t},\\n\\t\\tgetLabelDiff: function(datasetIndex, index) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (datasetIndex === null || index === null) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (me.labelDiffs === undefined) {\\n\\t\\t\\t\\tme.buildLabelDiffs();\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (typeof me.labelDiffs[datasetIndex] !== 'undefined') {\\n\\t\\t\\t\\treturn me.labelDiffs[datasetIndex][index];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\t\\t},\\n\\t\\tgetMomentStartOf: function(tick) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (me.options.time.unit === 'week' && me.options.time.isoWeekday !== false) {\\n\\t\\t\\t\\treturn tick.clone().startOf('isoWeek').isoWeekday(me.options.time.isoWeekday);\\n\\t\\t\\t}\\n\\t\\t\\treturn tick.clone().startOf(me.tickUnit);\\n\\t\\t},\\n\\t\\tdetermineDataLimits: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tme.labelMoments = [];\\n\\n\\t\\t\\t// Only parse these once. If the dataset does not have data as x,y pairs, we will use\\n\\t\\t\\t// these\\n\\t\\t\\tvar scaleLabelMoments = [];\\n\\t\\t\\tif (me.chart.data.labels && me.chart.data.labels.length > 0) {\\n\\t\\t\\t\\thelpers.each(me.chart.data.labels, function(label) {\\n\\t\\t\\t\\t\\tvar labelMoment = me.parseTime(label);\\n\\n\\t\\t\\t\\t\\tif (labelMoment.isValid()) {\\n\\t\\t\\t\\t\\t\\tif (me.options.time.round) {\\n\\t\\t\\t\\t\\t\\t\\tlabelMoment.startOf(me.options.time.round);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tscaleLabelMoments.push(labelMoment);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}, me);\\n\\n\\t\\t\\t\\tme.firstTick = moment.min.call(me, scaleLabelMoments);\\n\\t\\t\\t\\tme.lastTick = moment.max.call(me, scaleLabelMoments);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.firstTick = null;\\n\\t\\t\\t\\tme.lastTick = null;\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tvar momentsForDataset = [];\\n\\t\\t\\t\\tvar datasetVisible = me.chart.isDatasetVisible(datasetIndex);\\n\\n\\t\\t\\t\\tif (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {\\n\\t\\t\\t\\t\\thelpers.each(dataset.data, function(value) {\\n\\t\\t\\t\\t\\t\\tvar labelMoment = me.parseTime(me.getRightValue(value));\\n\\n\\t\\t\\t\\t\\t\\tif (labelMoment.isValid()) {\\n\\t\\t\\t\\t\\t\\t\\tif (me.options.time.round) {\\n\\t\\t\\t\\t\\t\\t\\t\\tlabelMoment.startOf(me.options.time.round);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tmomentsForDataset.push(labelMoment);\\n\\n\\t\\t\\t\\t\\t\\t\\tif (datasetVisible) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// May have gone outside the scale ranges, make sure we keep the first and last ticks updated\\n\\t\\t\\t\\t\\t\\t\\t\\tme.firstTick = me.firstTick !== null ? moment.min(me.firstTick, labelMoment) : labelMoment;\\n\\t\\t\\t\\t\\t\\t\\t\\tme.lastTick = me.lastTick !== null ? moment.max(me.lastTick, labelMoment) : labelMoment;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}, me);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// We have no labels. Use the ones from the scale\\n\\t\\t\\t\\t\\tmomentsForDataset = scaleLabelMoments;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tme.labelMoments.push(momentsForDataset);\\n\\t\\t\\t}, me);\\n\\n\\t\\t\\t// Set these after we've done all the data\\n\\t\\t\\tif (me.options.time.min) {\\n\\t\\t\\t\\tme.firstTick = me.parseTime(me.options.time.min);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (me.options.time.max) {\\n\\t\\t\\t\\tme.lastTick = me.parseTime(me.options.time.max);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// We will modify these, so clone for later\\n\\t\\t\\tme.firstTick = (me.firstTick || moment()).clone();\\n\\t\\t\\tme.lastTick = (me.lastTick || moment()).clone();\\n\\t\\t},\\n\\t\\tbuildLabelDiffs: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tme.labelDiffs = [];\\n\\t\\t\\tvar scaleLabelDiffs = [];\\n\\t\\t\\t// Parse common labels once\\n\\t\\t\\tif (me.chart.data.labels && me.chart.data.labels.length > 0) {\\n\\t\\t\\t\\thelpers.each(me.chart.data.labels, function(label) {\\n\\t\\t\\t\\t\\tvar labelMoment = me.parseTime(label);\\n\\n\\t\\t\\t\\t\\tif (labelMoment.isValid()) {\\n\\t\\t\\t\\t\\t\\tif (me.options.time.round) {\\n\\t\\t\\t\\t\\t\\t\\tlabelMoment.startOf(me.options.time.round);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tscaleLabelDiffs.push(labelMoment.diff(me.firstTick, me.tickUnit, true));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}, me);\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.each(me.chart.data.datasets, function(dataset) {\\n\\t\\t\\t\\tvar diffsForDataset = [];\\n\\n\\t\\t\\t\\tif (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {\\n\\t\\t\\t\\t\\thelpers.each(dataset.data, function(value) {\\n\\t\\t\\t\\t\\t\\tvar labelMoment = me.parseTime(me.getRightValue(value));\\n\\n\\t\\t\\t\\t\\t\\tif (labelMoment.isValid()) {\\n\\t\\t\\t\\t\\t\\t\\tif (me.options.time.round) {\\n\\t\\t\\t\\t\\t\\t\\t\\tlabelMoment.startOf(me.options.time.round);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tdiffsForDataset.push(labelMoment.diff(me.firstTick, me.tickUnit, true));\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}, me);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// We have no labels. Use common ones\\n\\t\\t\\t\\t\\tdiffsForDataset = scaleLabelDiffs;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tme.labelDiffs.push(diffsForDataset);\\n\\t\\t\\t}, me);\\n\\t\\t},\\n\\t\\tbuildTicks: function() {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tme.ctx.save();\\n\\t\\t\\tvar tickFontSize = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);\\n\\t\\t\\tvar tickFontStyle = helpers.getValueOrDefault(me.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);\\n\\t\\t\\tvar tickFontFamily = helpers.getValueOrDefault(me.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);\\n\\t\\t\\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\\n\\t\\t\\tme.ctx.font = tickLabelFont;\\n\\n\\t\\t\\tme.ticks = [];\\n\\t\\t\\tme.unitScale = 1; // How much we scale the unit by, ie 2 means 2x unit per step\\n\\t\\t\\tme.scaleSizeInUnits = 0; // How large the scale is in the base unit (seconds, minutes, etc)\\n\\n\\t\\t\\t// Set unit override if applicable\\n\\t\\t\\tif (me.options.time.unit) {\\n\\t\\t\\t\\tme.tickUnit = me.options.time.unit || 'day';\\n\\t\\t\\t\\tme.displayFormat = me.options.time.displayFormats[me.tickUnit];\\n\\t\\t\\t\\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\\n\\t\\t\\t\\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Determine the smallest needed unit of the time\\n\\t\\t\\t\\tvar innerWidth = me.isHorizontal() ? me.width : me.height;\\n\\n\\t\\t\\t\\t// Crude approximation of what the label length might be\\n\\t\\t\\t\\tvar tempFirstLabel = me.tickFormatFunction(me.firstTick, 0, []);\\n\\t\\t\\t\\tvar tickLabelWidth = me.ctx.measureText(tempFirstLabel).width;\\n\\t\\t\\t\\tvar cosRotation = Math.cos(helpers.toRadians(me.options.ticks.maxRotation));\\n\\t\\t\\t\\tvar sinRotation = Math.sin(helpers.toRadians(me.options.ticks.maxRotation));\\n\\t\\t\\t\\ttickLabelWidth = (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\\n\\t\\t\\t\\tvar labelCapacity = innerWidth / (tickLabelWidth);\\n\\n\\t\\t\\t\\t// Start as small as possible\\n\\t\\t\\t\\tme.tickUnit = me.options.time.minUnit;\\n\\t\\t\\t\\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\\n\\t\\t\\t\\tme.displayFormat = me.options.time.displayFormats[me.tickUnit];\\n\\n\\t\\t\\t\\tvar unitDefinitionIndex = 0;\\n\\t\\t\\t\\tvar unitDefinition = time.units[unitDefinitionIndex];\\n\\n\\t\\t\\t\\t// While we aren't ideal and we don't have units left\\n\\t\\t\\t\\twhile (unitDefinitionIndex < time.units.length) {\\n\\t\\t\\t\\t\\t// Can we scale this unit. If `false` we can scale infinitely\\n\\t\\t\\t\\t\\tme.unitScale = 1;\\n\\n\\t\\t\\t\\t\\tif (helpers.isArray(unitDefinition.steps) && Math.ceil(me.scaleSizeInUnits / labelCapacity) < helpers.max(unitDefinition.steps)) {\\n\\t\\t\\t\\t\\t\\t// Use one of the predefined steps\\n\\t\\t\\t\\t\\t\\tfor (var idx = 0; idx < unitDefinition.steps.length; ++idx) {\\n\\t\\t\\t\\t\\t\\t\\tif (unitDefinition.steps[idx] >= Math.ceil(me.scaleSizeInUnits / labelCapacity)) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, unitDefinition.steps[idx]);\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t} else if ((unitDefinition.maxStep === false) || (Math.ceil(me.scaleSizeInUnits / labelCapacity) < unitDefinition.maxStep)) {\\n\\t\\t\\t\\t\\t\\t// We have a max step. Scale this unit\\n\\t\\t\\t\\t\\t\\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, Math.ceil(me.scaleSizeInUnits / labelCapacity));\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// Move to the next unit up\\n\\t\\t\\t\\t\\t\\t++unitDefinitionIndex;\\n\\t\\t\\t\\t\\t\\tunitDefinition = time.units[unitDefinitionIndex];\\n\\n\\t\\t\\t\\t\\t\\tme.tickUnit = unitDefinition.name;\\n\\t\\t\\t\\t\\t\\tvar leadingUnitBuffer = me.firstTick.diff(me.getMomentStartOf(me.firstTick), me.tickUnit, true);\\n\\t\\t\\t\\t\\t\\tvar trailingUnitBuffer = me.getMomentStartOf(me.lastTick.clone().add(1, me.tickUnit)).diff(me.lastTick, me.tickUnit, true);\\n\\t\\t\\t\\t\\t\\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true) + leadingUnitBuffer + trailingUnitBuffer;\\n\\t\\t\\t\\t\\t\\tme.displayFormat = me.options.time.displayFormats[unitDefinition.name];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar roundedStart;\\n\\n\\t\\t\\t// Only round the first tick if we have no hard minimum\\n\\t\\t\\tif (!me.options.time.min) {\\n\\t\\t\\t\\tme.firstTick = me.getMomentStartOf(me.firstTick);\\n\\t\\t\\t\\troundedStart = me.firstTick;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\troundedStart = me.getMomentStartOf(me.firstTick);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Only round the last tick if we have no hard maximum\\n\\t\\t\\tif (!me.options.time.max) {\\n\\t\\t\\t\\tvar roundedEnd = me.getMomentStartOf(me.lastTick);\\n\\t\\t\\t\\tvar delta = roundedEnd.diff(me.lastTick, me.tickUnit, true);\\n\\t\\t\\t\\tif (delta < 0) {\\n\\t\\t\\t\\t\\t// Do not use end of because we need me to be in the next time unit\\n\\t\\t\\t\\t\\tme.lastTick = me.getMomentStartOf(me.lastTick.add(1, me.tickUnit));\\n\\t\\t\\t\\t} else if (delta >= 0) {\\n\\t\\t\\t\\t\\tme.lastTick = roundedEnd;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Tick displayFormat override\\n\\t\\t\\tif (me.options.time.displayFormat) {\\n\\t\\t\\t\\tme.displayFormat = me.options.time.displayFormat;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// first tick. will have been rounded correctly if options.time.min is not specified\\n\\t\\t\\tme.ticks.push(me.firstTick.clone());\\n\\n\\t\\t\\t// For every unit in between the first and last moment, create a moment and add it to the ticks tick\\n\\t\\t\\tfor (var i = me.unitScale; i <= me.scaleSizeInUnits; i += me.unitScale) {\\n\\t\\t\\t\\tvar newTick = roundedStart.clone().add(i, me.tickUnit);\\n\\n\\t\\t\\t\\t// Are we greater than the max time\\n\\t\\t\\t\\tif (me.options.time.max && newTick.diff(me.lastTick, me.tickUnit, true) >= 0) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tme.ticks.push(newTick);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Always show the right tick\\n\\t\\t\\tvar diff = me.ticks[me.ticks.length - 1].diff(me.lastTick, me.tickUnit);\\n\\t\\t\\tif (diff !== 0 || me.scaleSizeInUnits === 0) {\\n\\t\\t\\t\\t// this is a weird case. If the <max> option is the same as the end option, we can't just diff the times because the tick was created from the roundedStart\\n\\t\\t\\t\\t// but the last tick was not rounded.\\n\\t\\t\\t\\tif (me.options.time.max) {\\n\\t\\t\\t\\t\\tme.ticks.push(me.lastTick.clone());\\n\\t\\t\\t\\t\\tme.scaleSizeInUnits = me.lastTick.diff(me.ticks[0], me.tickUnit, true);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tme.ticks.push(me.lastTick.clone());\\n\\t\\t\\t\\t\\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.ctx.restore();\\n\\n\\t\\t\\t// Invalidate label diffs cache\\n\\t\\t\\tme.labelDiffs = undefined;\\n\\t\\t},\\n\\t\\t// Get tooltip label\\n\\t\\tgetLabelForIndex: function(index, datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar label = me.chart.data.labels && index < me.chart.data.labels.length ? me.chart.data.labels[index] : '';\\n\\t\\t\\tvar value = me.chart.data.datasets[datasetIndex].data[index];\\n\\n\\t\\t\\tif (value !== null && typeof value === 'object') {\\n\\t\\t\\t\\tlabel = me.getRightValue(value);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Format nicely\\n\\t\\t\\tif (me.options.time.tooltipFormat) {\\n\\t\\t\\t\\tlabel = me.parseTime(label).format(me.options.time.tooltipFormat);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn label;\\n\\t\\t},\\n\\t\\t// Function to format an individual tick mark\\n\\t\\ttickFormatFunction: function(tick, index, ticks) {\\n\\t\\t\\tvar formattedTick = tick.format(this.displayFormat);\\n\\t\\t\\tvar tickOpts = this.options.ticks;\\n\\t\\t\\tvar callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);\\n\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\treturn callback(formattedTick, index, ticks);\\n\\t\\t\\t}\\n\\t\\t\\treturn formattedTick;\\n\\t\\t},\\n\\t\\tconvertTicksToLabels: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tme.tickMoments = me.ticks;\\n\\t\\t\\tme.ticks = me.ticks.map(me.tickFormatFunction, me);\\n\\t\\t},\\n\\t\\tgetPixelForValue: function(value, index, datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar offset = null;\\n\\t\\t\\tif (index !== undefined && datasetIndex !== undefined) {\\n\\t\\t\\t\\toffset = me.getLabelDiff(datasetIndex, index);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (offset === null) {\\n\\t\\t\\t\\tif (!value || !value.isValid) {\\n\\t\\t\\t\\t\\t// not already a moment object\\n\\t\\t\\t\\t\\tvalue = me.parseTime(me.getRightValue(value));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (value && value.isValid && value.isValid()) {\\n\\t\\t\\t\\t\\toffset = value.diff(me.firstTick, me.tickUnit, true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (offset !== null) {\\n\\t\\t\\t\\tvar decimal = offset !== 0 ? offset / me.scaleSizeInUnits : offset;\\n\\n\\t\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\t\\tvar valueOffset = (me.width * decimal);\\n\\t\\t\\t\\t\\treturn me.left + Math.round(valueOffset);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar heightOffset = (me.height * decimal);\\n\\t\\t\\t\\treturn me.top + Math.round(heightOffset);\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tgetPixelForTick: function(index) {\\n\\t\\t\\treturn this.getPixelForValue(this.tickMoments[index], null, null);\\n\\t\\t},\\n\\t\\tgetValueForPixel: function(pixel) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar innerDimension = me.isHorizontal() ? me.width : me.height;\\n\\t\\t\\tvar offset = (pixel - (me.isHorizontal() ? me.left : me.top)) / innerDimension;\\n\\t\\t\\toffset *= me.scaleSizeInUnits;\\n\\t\\t\\treturn me.firstTick.clone().add(moment.duration(offset, me.tickUnit).asSeconds(), 'seconds');\\n\\t\\t},\\n\\t\\tparseTime: function(label) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (typeof me.options.time.parser === 'string') {\\n\\t\\t\\t\\treturn moment(label, me.options.time.parser);\\n\\t\\t\\t}\\n\\t\\t\\tif (typeof me.options.time.parser === 'function') {\\n\\t\\t\\t\\treturn me.options.time.parser(label);\\n\\t\\t\\t}\\n\\t\\t\\t// Date objects\\n\\t\\t\\tif (typeof label.getMonth === 'function' || typeof label === 'number') {\\n\\t\\t\\t\\treturn moment(label);\\n\\t\\t\\t}\\n\\t\\t\\t// Moment support\\n\\t\\t\\tif (label.isValid && label.isValid()) {\\n\\t\\t\\t\\treturn label;\\n\\t\\t\\t}\\n\\t\\t\\t// Custom parsing (return an instance of moment)\\n\\t\\t\\tif (typeof me.options.time.format !== 'string' && me.options.time.format.call) {\\n\\t\\t\\t\\tconsole.warn('options.time.format is deprecated and replaced by options.time.parser. See http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale');\\n\\t\\t\\t\\treturn me.options.time.format(label);\\n\\t\\t\\t}\\n\\t\\t\\t// Moment format parsing\\n\\t\\t\\treturn moment(label, me.options.time.format);\\n\\t\\t}\\n\\t});\\n\\tChart.scaleService.registerScaleType('time', TimeScale, defaultConfig);\\n\\n};\\n\\n},{\\\"1\\\":1}]},{},[7])(7)\\n});\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/devon/Desktop/frontEnd/frontEnd/node_modules/raw-loader!/home/devon/Desktop/frontEnd/frontEnd/node_modules/chart.js/dist/Chart.js\n// module id = ../../../../raw-loader/index.js!../../../../chart.js/dist/Chart.js\n// module chunks = scripts","module.exports = \"/*! Hammer.JS - v2.0.7 - 2016-04-22\\n * http://hammerjs.github.io/\\n *\\n * Copyright (c) 2016 Jorik Tangelder;\\n * Licensed under the MIT license */\\n!function(a,b,c,d){\\\"use strict\\\";function e(a,b,c){return setTimeout(j(a,c),b)}function f(a,b,c){return Array.isArray(a)?(g(a,c[b],c),!0):!1}function g(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function h(b,c,d){var e=\\\"DEPRECATED METHOD: \\\"+c+\\\"\\\\n\\\"+d+\\\" AT \\\\n\\\";return function(){var c=new Error(\\\"get-stack-trace\\\"),d=c&&c.stack?c.stack.replace(/^[^\\\\(]+?[\\\\n$]/gm,\\\"\\\").replace(/^\\\\s+at\\\\s+/gm,\\\"\\\").replace(/^Object.<anonymous>\\\\s*\\\\(/gm,\\\"{anonymous}()@\\\"):\\\"Unknown Stack Trace\\\",f=a.console&&(a.console.warn||a.console.log);return f&&f.call(a.console,e,d),b.apply(this,arguments)}}function i(a,b,c){var d,e=b.prototype;d=a.prototype=Object.create(e),d.constructor=a,d._super=e,c&&la(d,c)}function j(a,b){return function(){return a.apply(b,arguments)}}function k(a,b){return typeof a==oa?a.apply(b?b[0]||d:d,b):a}function l(a,b){return a===d?b:a}function m(a,b,c){g(q(b),function(b){a.addEventListener(b,c,!1)})}function n(a,b,c){g(q(b),function(b){a.removeEventListener(b,c,!1)})}function o(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function p(a,b){return a.indexOf(b)>-1}function q(a){return a.trim().split(/\\\\s+/g)}function r(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function s(a){return Array.prototype.slice.call(a,0)}function t(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];r(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function u(a,b){for(var c,e,f=b[0].toUpperCase()+b.slice(1),g=0;g<ma.length;){if(c=ma[g],e=c?c+f:b,e in a)return e;g++}return d}function v(){return ua++}function w(b){var c=b.ownerDocument||b;return c.defaultView||c.parentWindow||a}function x(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){k(a.options.enable,[a])&&c.handler(b)},this.init()}function y(a){var b,c=a.options.inputClass;return new(b=c?c:xa?M:ya?P:wa?R:L)(a,z)}function z(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&Ea&&d-e===0,g=b&(Ga|Ha)&&d-e===0;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,A(a,c),a.emit(\\\"hammer.input\\\",c),a.recognize(c),a.session.prevInput=c}function A(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=D(b)),e>1&&!c.firstMultiple?c.firstMultiple=D(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=E(d);b.timeStamp=ra(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=I(h,i),b.distance=H(h,i),B(c,b),b.offsetDirection=G(b.deltaX,b.deltaY);var j=F(b.deltaTime,b.deltaX,b.deltaY);b.overallVelocityX=j.x,b.overallVelocityY=j.y,b.overallVelocity=qa(j.x)>qa(j.y)?j.x:j.y,b.scale=g?K(g.pointers,d):1,b.rotation=g?J(g.pointers,d):0,b.maxPointers=c.prevInput?b.pointers.length>c.prevInput.maxPointers?b.pointers.length:c.prevInput.maxPointers:b.pointers.length,C(c,b);var k=a.element;o(b.srcEvent.target,k)&&(k=b.srcEvent.target),b.target=k}function B(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};b.eventType!==Ea&&f.eventType!==Ga||(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function C(a,b){var c,e,f,g,h=a.lastInterval||b,i=b.timeStamp-h.timeStamp;if(b.eventType!=Ha&&(i>Da||h.velocity===d)){var j=b.deltaX-h.deltaX,k=b.deltaY-h.deltaY,l=F(i,j,k);e=l.x,f=l.y,c=qa(l.x)>qa(l.y)?l.x:l.y,g=G(j,k),a.lastInterval=b}else c=h.velocity,e=h.velocityX,f=h.velocityY,g=h.direction;b.velocity=c,b.velocityX=e,b.velocityY=f,b.direction=g}function D(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:pa(a.pointers[c].clientX),clientY:pa(a.pointers[c].clientY)},c++;return{timeStamp:ra(),pointers:b,center:E(b),deltaX:a.deltaX,deltaY:a.deltaY}}function E(a){var b=a.length;if(1===b)return{x:pa(a[0].clientX),y:pa(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:pa(c/b),y:pa(d/b)}}function F(a,b,c){return{x:b/a||0,y:c/a||0}}function G(a,b){return a===b?Ia:qa(a)>=qa(b)?0>a?Ja:Ka:0>b?La:Ma}function H(a,b,c){c||(c=Qa);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function I(a,b,c){c||(c=Qa);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function J(a,b){return I(b[1],b[0],Ra)+I(a[1],a[0],Ra)}function K(a,b){return H(b[0],b[1],Ra)/H(a[0],a[1],Ra)}function L(){this.evEl=Ta,this.evWin=Ua,this.pressed=!1,x.apply(this,arguments)}function M(){this.evEl=Xa,this.evWin=Ya,x.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function N(){this.evTarget=$a,this.evWin=_a,this.started=!1,x.apply(this,arguments)}function O(a,b){var c=s(a.touches),d=s(a.changedTouches);return b&(Ga|Ha)&&(c=t(c.concat(d),\\\"identifier\\\",!0)),[c,d]}function P(){this.evTarget=bb,this.targetIds={},x.apply(this,arguments)}function Q(a,b){var c=s(a.touches),d=this.targetIds;if(b&(Ea|Fa)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=s(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return o(a.target,i)}),b===Ea)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Ga|Ha)&&delete d[g[e].identifier],e++;return h.length?[t(f.concat(h),\\\"identifier\\\",!0),h]:void 0}function R(){x.apply(this,arguments);var a=j(this.handler,this);this.touch=new P(this.manager,a),this.mouse=new L(this.manager,a),this.primaryTouch=null,this.lastTouches=[]}function S(a,b){a&Ea?(this.primaryTouch=b.changedPointers[0].identifier,T.call(this,b)):a&(Ga|Ha)&&T.call(this,b)}function T(a){var b=a.changedPointers[0];if(b.identifier===this.primaryTouch){var c={x:b.clientX,y:b.clientY};this.lastTouches.push(c);var d=this.lastTouches,e=function(){var a=d.indexOf(c);a>-1&&d.splice(a,1)};setTimeout(e,cb)}}function U(a){for(var b=a.srcEvent.clientX,c=a.srcEvent.clientY,d=0;d<this.lastTouches.length;d++){var e=this.lastTouches[d],f=Math.abs(b-e.x),g=Math.abs(c-e.y);if(db>=f&&db>=g)return!0}return!1}function V(a,b){this.manager=a,this.set(b)}function W(a){if(p(a,jb))return jb;var b=p(a,kb),c=p(a,lb);return b&&c?jb:b||c?b?kb:lb:p(a,ib)?ib:hb}function X(){if(!fb)return!1;var b={},c=a.CSS&&a.CSS.supports;return[\\\"auto\\\",\\\"manipulation\\\",\\\"pan-y\\\",\\\"pan-x\\\",\\\"pan-x pan-y\\\",\\\"none\\\"].forEach(function(d){b[d]=c?a.CSS.supports(\\\"touch-action\\\",d):!0}),b}function Y(a){this.options=la({},this.defaults,a||{}),this.id=v(),this.manager=null,this.options.enable=l(this.options.enable,!0),this.state=nb,this.simultaneous={},this.requireFail=[]}function Z(a){return a&sb?\\\"cancel\\\":a&qb?\\\"end\\\":a&pb?\\\"move\\\":a&ob?\\\"start\\\":\\\"\\\"}function $(a){return a==Ma?\\\"down\\\":a==La?\\\"up\\\":a==Ja?\\\"left\\\":a==Ka?\\\"right\\\":\\\"\\\"}function _(a,b){var c=b.manager;return c?c.get(a):a}function aa(){Y.apply(this,arguments)}function ba(){aa.apply(this,arguments),this.pX=null,this.pY=null}function ca(){aa.apply(this,arguments)}function da(){Y.apply(this,arguments),this._timer=null,this._input=null}function ea(){aa.apply(this,arguments)}function fa(){aa.apply(this,arguments)}function ga(){Y.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function ha(a,b){return b=b||{},b.recognizers=l(b.recognizers,ha.defaults.preset),new ia(a,b)}function ia(a,b){this.options=la({},ha.defaults,b||{}),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=a,this.input=y(this),this.touchAction=new V(this,this.options.touchAction),ja(this,!0),g(this.options.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function ja(a,b){var c=a.element;if(c.style){var d;g(a.options.cssProps,function(e,f){d=u(c.style,f),b?(a.oldCssProps[d]=c.style[d],c.style[d]=e):c.style[d]=a.oldCssProps[d]||\\\"\\\"}),b||(a.oldCssProps={})}}function ka(a,c){var d=b.createEvent(\\\"Event\\\");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var la,ma=[\\\"\\\",\\\"webkit\\\",\\\"Moz\\\",\\\"MS\\\",\\\"ms\\\",\\\"o\\\"],na=b.createElement(\\\"div\\\"),oa=\\\"function\\\",pa=Math.round,qa=Math.abs,ra=Date.now;la=\\\"function\\\"!=typeof Object.assign?function(a){if(a===d||null===a)throw new TypeError(\\\"Cannot convert undefined or null to object\\\");for(var b=Object(a),c=1;c<arguments.length;c++){var e=arguments[c];if(e!==d&&null!==e)for(var f in e)e.hasOwnProperty(f)&&(b[f]=e[f])}return b}:Object.assign;var sa=h(function(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a},\\\"extend\\\",\\\"Use `assign`.\\\"),ta=h(function(a,b){return sa(a,b,!0)},\\\"merge\\\",\\\"Use `assign`.\\\"),ua=1,va=/mobile|tablet|ip(ad|hone|od)|android/i,wa=\\\"ontouchstart\\\"in a,xa=u(a,\\\"PointerEvent\\\")!==d,ya=wa&&va.test(navigator.userAgent),za=\\\"touch\\\",Aa=\\\"pen\\\",Ba=\\\"mouse\\\",Ca=\\\"kinect\\\",Da=25,Ea=1,Fa=2,Ga=4,Ha=8,Ia=1,Ja=2,Ka=4,La=8,Ma=16,Na=Ja|Ka,Oa=La|Ma,Pa=Na|Oa,Qa=[\\\"x\\\",\\\"y\\\"],Ra=[\\\"clientX\\\",\\\"clientY\\\"];x.prototype={handler:function(){},init:function(){this.evEl&&m(this.element,this.evEl,this.domHandler),this.evTarget&&m(this.target,this.evTarget,this.domHandler),this.evWin&&m(w(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&n(this.element,this.evEl,this.domHandler),this.evTarget&&n(this.target,this.evTarget,this.domHandler),this.evWin&&n(w(this.element),this.evWin,this.domHandler)}};var Sa={mousedown:Ea,mousemove:Fa,mouseup:Ga},Ta=\\\"mousedown\\\",Ua=\\\"mousemove mouseup\\\";i(L,x,{handler:function(a){var b=Sa[a.type];b&Ea&&0===a.button&&(this.pressed=!0),b&Fa&&1!==a.which&&(b=Ga),this.pressed&&(b&Ga&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:Ba,srcEvent:a}))}});var Va={pointerdown:Ea,pointermove:Fa,pointerup:Ga,pointercancel:Ha,pointerout:Ha},Wa={2:za,3:Aa,4:Ba,5:Ca},Xa=\\\"pointerdown\\\",Ya=\\\"pointermove pointerup pointercancel\\\";a.MSPointerEvent&&!a.PointerEvent&&(Xa=\\\"MSPointerDown\\\",Ya=\\\"MSPointerMove MSPointerUp MSPointerCancel\\\"),i(M,x,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace(\\\"ms\\\",\\\"\\\"),e=Va[d],f=Wa[a.pointerType]||a.pointerType,g=f==za,h=r(b,a.pointerId,\\\"pointerId\\\");e&Ea&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Ga|Ha)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var Za={touchstart:Ea,touchmove:Fa,touchend:Ga,touchcancel:Ha},$a=\\\"touchstart\\\",_a=\\\"touchstart touchmove touchend touchcancel\\\";i(N,x,{handler:function(a){var b=Za[a.type];if(b===Ea&&(this.started=!0),this.started){var c=O.call(this,a,b);b&(Ga|Ha)&&c[0].length-c[1].length===0&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:za,srcEvent:a})}}});var ab={touchstart:Ea,touchmove:Fa,touchend:Ga,touchcancel:Ha},bb=\\\"touchstart touchmove touchend touchcancel\\\";i(P,x,{handler:function(a){var b=ab[a.type],c=Q.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:za,srcEvent:a})}});var cb=2500,db=25;i(R,x,{handler:function(a,b,c){var d=c.pointerType==za,e=c.pointerType==Ba;if(!(e&&c.sourceCapabilities&&c.sourceCapabilities.firesTouchEvents)){if(d)S.call(this,b,c);else if(e&&U.call(this,c))return;this.callback(a,b,c)}},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var eb=u(na.style,\\\"touchAction\\\"),fb=eb!==d,gb=\\\"compute\\\",hb=\\\"auto\\\",ib=\\\"manipulation\\\",jb=\\\"none\\\",kb=\\\"pan-x\\\",lb=\\\"pan-y\\\",mb=X();V.prototype={set:function(a){a==gb&&(a=this.compute()),fb&&this.manager.element.style&&mb[a]&&(this.manager.element.style[eb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return g(this.manager.recognizers,function(b){k(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),W(a.join(\\\" \\\"))},preventDefaults:function(a){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return void b.preventDefault();var d=this.actions,e=p(d,jb)&&!mb[jb],f=p(d,lb)&&!mb[lb],g=p(d,kb)&&!mb[kb];if(e){var h=1===a.pointers.length,i=a.distance<2,j=a.deltaTime<250;if(h&&i&&j)return}return g&&f?void 0:e||f&&c&Na||g&&c&Oa?this.preventSrc(b):void 0},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var nb=1,ob=2,pb=4,qb=8,rb=qb,sb=16,tb=32;Y.prototype={defaults:{},set:function(a){return la(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(f(a,\\\"recognizeWith\\\",this))return this;var b=this.simultaneous;return a=_(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return f(a,\\\"dropRecognizeWith\\\",this)?this:(a=_(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(f(a,\\\"requireFailure\\\",this))return this;var b=this.requireFail;return a=_(a,this),-1===r(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(f(a,\\\"dropRequireFailure\\\",this))return this;a=_(a,this);var b=r(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function b(b){c.manager.emit(b,a)}var c=this,d=this.state;qb>d&&b(c.options.event+Z(d)),b(c.options.event),a.additionalEvent&&b(a.additionalEvent),d>=qb&&b(c.options.event+Z(d))},tryEmit:function(a){return this.canEmit()?this.emit(a):void(this.state=tb)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(tb|nb)))return!1;a++}return!0},recognize:function(a){var b=la({},a);return k(this.options.enable,[this,b])?(this.state&(rb|sb|tb)&&(this.state=nb),this.state=this.process(b),void(this.state&(ob|pb|qb|sb)&&this.tryEmit(b))):(this.reset(),void(this.state=tb))},process:function(a){},getTouchAction:function(){},reset:function(){}},i(aa,Y,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(ob|pb),e=this.attrTest(a);return d&&(c&Ha||!e)?b|sb:d||e?c&Ga?b|qb:b&ob?b|pb:ob:tb}}),i(ba,aa,{defaults:{event:\\\"pan\\\",threshold:10,pointers:1,direction:Pa},getTouchAction:function(){var a=this.options.direction,b=[];return a&Na&&b.push(lb),a&Oa&&b.push(kb),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&Na?(e=0===f?Ia:0>f?Ja:Ka,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?Ia:0>g?La:Ma,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return aa.prototype.attrTest.call(this,a)&&(this.state&ob||!(this.state&ob)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=$(a.direction);b&&(a.additionalEvent=this.options.event+b),this._super.emit.call(this,a)}}),i(ca,aa,{defaults:{event:\\\"pinch\\\",threshold:0,pointers:2},getTouchAction:function(){return[jb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&ob)},emit:function(a){if(1!==a.scale){var b=a.scale<1?\\\"in\\\":\\\"out\\\";a.additionalEvent=this.options.event+b}this._super.emit.call(this,a)}}),i(da,Y,{defaults:{event:\\\"press\\\",pointers:1,time:251,threshold:9},getTouchAction:function(){return[hb]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Ga|Ha)&&!f)this.reset();else if(a.eventType&Ea)this.reset(),this._timer=e(function(){this.state=rb,this.tryEmit()},b.time,this);else if(a.eventType&Ga)return rb;return tb},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===rb&&(a&&a.eventType&Ga?this.manager.emit(this.options.event+\\\"up\\\",a):(this._input.timeStamp=ra(),this.manager.emit(this.options.event,this._input)))}}),i(ea,aa,{defaults:{event:\\\"rotate\\\",threshold:0,pointers:2},getTouchAction:function(){return[jb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&ob)}}),i(fa,aa,{defaults:{event:\\\"swipe\\\",threshold:10,velocity:.3,direction:Na|Oa,pointers:1},getTouchAction:function(){return ba.prototype.getTouchAction.call(this)},attrTest:function(a){var b,c=this.options.direction;return c&(Na|Oa)?b=a.overallVelocity:c&Na?b=a.overallVelocityX:c&Oa&&(b=a.overallVelocityY),this._super.attrTest.call(this,a)&&c&a.offsetDirection&&a.distance>this.options.threshold&&a.maxPointers==this.options.pointers&&qa(b)>this.options.velocity&&a.eventType&Ga},emit:function(a){var b=$(a.offsetDirection);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),i(ga,Y,{defaults:{event:\\\"tap\\\",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},getTouchAction:function(){return[ib]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime<b.time;if(this.reset(),a.eventType&Ea&&0===this.count)return this.failTimeout();if(d&&f&&c){if(a.eventType!=Ga)return this.failTimeout();var g=this.pTime?a.timeStamp-this.pTime<b.interval:!0,h=!this.pCenter||H(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,h&&g?this.count+=1:this.count=1,this._input=a;var i=this.count%b.taps;if(0===i)return this.hasRequireFailures()?(this._timer=e(function(){this.state=rb,this.tryEmit()},b.interval,this),ob):rb}return tb},failTimeout:function(){return this._timer=e(function(){this.state=tb},this.options.interval,this),tb},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==rb&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),ha.VERSION=\\\"2.0.7\\\",ha.defaults={domEvents:!1,touchAction:gb,enable:!0,inputTarget:null,inputClass:null,preset:[[ea,{enable:!1}],[ca,{enable:!1},[\\\"rotate\\\"]],[fa,{direction:Na}],[ba,{direction:Na},[\\\"swipe\\\"]],[ga],[ga,{event:\\\"doubletap\\\",taps:2},[\\\"tap\\\"]],[da]],cssProps:{userSelect:\\\"none\\\",touchSelect:\\\"none\\\",touchCallout:\\\"none\\\",contentZooming:\\\"none\\\",userDrag:\\\"none\\\",tapHighlightColor:\\\"rgba(0,0,0,0)\\\"}};var ub=1,vb=2;ia.prototype={set:function(a){return la(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?vb:ub},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&rb)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===vb||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(ob|pb|qb)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof Y)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(f(a,\\\"add\\\",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(f(a,\\\"remove\\\",this))return this;if(a=this.get(a)){var b=this.recognizers,c=r(b,a);-1!==c&&(b.splice(c,1),this.touchAction.update())}return this},on:function(a,b){if(a!==d&&b!==d){var c=this.handlers;return g(q(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this}},off:function(a,b){if(a!==d){var c=this.handlers;return g(q(a),function(a){b?c[a]&&c[a].splice(r(c[a],b),1):delete c[a]}),this}},emit:function(a,b){this.options.domEvents&&ka(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&ja(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},la(ha,{INPUT_START:Ea,INPUT_MOVE:Fa,INPUT_END:Ga,INPUT_CANCEL:Ha,STATE_POSSIBLE:nb,STATE_BEGAN:ob,STATE_CHANGED:pb,STATE_ENDED:qb,STATE_RECOGNIZED:rb,STATE_CANCELLED:sb,STATE_FAILED:tb,DIRECTION_NONE:Ia,DIRECTION_LEFT:Ja,DIRECTION_RIGHT:Ka,DIRECTION_UP:La,DIRECTION_DOWN:Ma,DIRECTION_HORIZONTAL:Na,DIRECTION_VERTICAL:Oa,DIRECTION_ALL:Pa,Manager:ia,Input:x,TouchAction:V,TouchInput:P,MouseInput:L,PointerEventInput:M,TouchMouseInput:R,SingleTouchInput:N,Recognizer:Y,AttrRecognizer:aa,Tap:ga,Pan:ba,Swipe:fa,Pinch:ca,Rotate:ea,Press:da,on:m,off:n,each:g,merge:ta,extend:sa,assign:la,inherit:i,bindFn:j,prefixed:u});var wb=\\\"undefined\\\"!=typeof a?a:\\\"undefined\\\"!=typeof self?self:{};wb.Hammer=ha,\\\"function\\\"==typeof define&&define.amd?define(function(){return ha}):\\\"undefined\\\"!=typeof module&&module.exports?module.exports=ha:a[c]=ha}(window,document,\\\"Hammer\\\");\\n//# sourceMappingURL=hammer.min.js.map\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/devon/Desktop/frontEnd/frontEnd/node_modules/raw-loader!/home/devon/Desktop/frontEnd/frontEnd/node_modules/hammerjs/hammer.min.js\n// module id = ../../../../raw-loader/index.js!../../../../hammerjs/hammer.min.js\n// module chunks = scripts","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/devon/Desktop/frontEnd/frontEnd/node_modules/script-loader/addScript.js\n// module id = ../../../../script-loader/addScript.js\n// module chunks = scripts","require(\"!!/home/devon/Desktop/frontEnd/frontEnd/node_modules/script-loader/addScript.js\")(require(\"!!/home/devon/Desktop/frontEnd/frontEnd/node_modules/raw-loader/index.js!/home/devon/Desktop/frontEnd/frontEnd/node_modules/auth0-js/build/auth0.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/devon/Desktop/frontEnd/frontEnd/node_modules/script-loader!/home/devon/Desktop/frontEnd/frontEnd/node_modules/auth0-js/build/auth0.js\n// module id = ../../../../script-loader/index.js!../../../../auth0-js/build/auth0.js\n// module chunks = scripts","require(\"!!/home/devon/Desktop/frontEnd/frontEnd/node_modules/script-loader/addScript.js\")(require(\"!!/home/devon/Desktop/frontEnd/frontEnd/node_modules/raw-loader/index.js!/home/devon/Desktop/frontEnd/frontEnd/node_modules/chart.js/dist/Chart.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/devon/Desktop/frontEnd/frontEnd/node_modules/script-loader!/home/devon/Desktop/frontEnd/frontEnd/node_modules/chart.js/dist/Chart.js\n// module id = ../../../../script-loader/index.js!../../../../chart.js/dist/Chart.js\n// module chunks = scripts","require(\"!!/home/devon/Desktop/frontEnd/frontEnd/node_modules/script-loader/addScript.js\")(require(\"!!/home/devon/Desktop/frontEnd/frontEnd/node_modules/raw-loader/index.js!/home/devon/Desktop/frontEnd/frontEnd/node_modules/hammerjs/hammer.min.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/devon/Desktop/frontEnd/frontEnd/node_modules/script-loader!/home/devon/Desktop/frontEnd/frontEnd/node_modules/hammerjs/hammer.min.js\n// module id = ../../../../script-loader/index.js!../../../../hammerjs/hammer.min.js\n// module chunks = scripts"],"sourceRoot":"webpack:///"}